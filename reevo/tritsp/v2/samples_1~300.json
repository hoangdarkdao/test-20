[
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # We select solutions with the best average improvement potential\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the average distance improvement potential\n        total_dist = obj[0] + obj[1] + obj[2]\n        candidates.append((sol, total_dist))\n\n    # Sort by total distance (lower is better)\n    candidates.sort(key=lambda x: x[1])\n    # Select top 30% of candidates or at least 3 solutions\n    num_candidates = max(3, int(0.3 * len(candidates)))\n    selected_candidates = [c[0] for c in candidates[:num_candidates]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(selected_candidates).copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and objective-aware swaps\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: swap nodes that are close in at least one objective space\n            node1, node2 = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n\n            # If nodes are close in at least one objective space, swap them\n            if min(dist1, dist2, dist3) < 0.5 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2) + np.mean(distance_matrix_3))/3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7147831292716299,
            1.2472438216209412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # We select solutions with the best average improvement potential\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the average distance improvement potential\n        total_dist = obj[0] + obj[1] + obj[2]\n        candidates.append((sol, total_dist))\n\n    # Sort by total distance (lower is better)\n    candidates.sort(key=lambda x: x[1])\n    # Select top 30% of candidates or at least 3 solutions\n    num_candidates = max(3, int(0.3 * len(candidates)))\n    selected_candidates = [c[0] for c in candidates[:num_candidates]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(selected_candidates).copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and objective-aware swaps\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: swap nodes that are close in at least one objective space\n            node1, node2 = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n\n            # If nodes are close in at least one objective space, swap them\n            if min(dist1, dist2, dist3) < 0.5 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2) + np.mean(distance_matrix_3))/3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # We select solutions with the best average improvement potential\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the average distance improvement potential\n        total_dist = obj[0] + obj[1] + obj[2]\n        candidates.append((sol, total_dist))\n\n    # Sort by total distance (lower is better)\n    candidates.sort(key=lambda x: x[1])\n    # Select top 30% of candidates or at least 3 solutions\n    num_candidates = max(3, int(0.3 * len(candidates)))\n    selected_candidates = [c[0] for c in candidates[:num_candidates]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(selected_candidates).copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and objective-aware swaps\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: swap nodes that are close in at least one objective space\n            node1, node2 = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n\n            # If nodes are close in at least one objective space, swap them\n            if min(dist1, dist2, dist3) < 0.5 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2) + np.mean(distance_matrix_3))/3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7147831292716299,
            1.2472438216209412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # We select solutions with the best average improvement potential\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the average distance improvement potential\n        total_dist = obj[0] + obj[1] + obj[2]\n        candidates.append((sol, total_dist))\n\n    # Sort by total distance (lower is better)\n    candidates.sort(key=lambda x: x[1])\n    # Select top 30% of candidates or at least 3 solutions\n    num_candidates = max(3, int(0.3 * len(candidates)))\n    selected_candidates = [c[0] for c in candidates[:num_candidates]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(selected_candidates).copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and objective-aware swaps\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: swap nodes that are close in at least one objective space\n            node1, node2 = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n\n            # If nodes are close in at least one objective space, swap them\n            if min(dist1, dist2, dist3) < 0.5 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2) + np.mean(distance_matrix_3))/3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # We select solutions with the best average improvement potential\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the average distance improvement potential\n        total_dist = obj[0] + obj[1] + obj[2]\n        candidates.append((sol, total_dist))\n\n    # Sort by total distance (lower is better)\n    candidates.sort(key=lambda x: x[1])\n    # Select top 30% of candidates or at least 3 solutions\n    num_candidates = max(3, int(0.3 * len(candidates)))\n    selected_candidates = [c[0] for c in candidates[:num_candidates]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(selected_candidates).copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and objective-aware swaps\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: swap nodes that are close in at least one objective space\n            node1, node2 = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n\n            # If nodes are close in at least one objective space, swap them\n            if min(dist1, dist2, dist3) < 0.5 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2) + np.mean(distance_matrix_3))/3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7147831292716299,
            1.2472438216209412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # We select solutions with the best average improvement potential\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the average distance improvement potential\n        total_dist = obj[0] + obj[1] + obj[2]\n        candidates.append((sol, total_dist))\n\n    # Sort by total distance (lower is better)\n    candidates.sort(key=lambda x: x[1])\n    # Select top 30% of candidates or at least 3 solutions\n    num_candidates = max(3, int(0.3 * len(candidates)))\n    selected_candidates = [c[0] for c in candidates[:num_candidates]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(selected_candidates).copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and objective-aware swaps\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: swap nodes that are close in at least one objective space\n            node1, node2 = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n\n            # If nodes are close in at least one objective space, swap them\n            if min(dist1, dist2, dist3) < 0.5 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2) + np.mean(distance_matrix_3))/3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between 2-opt or node insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6743841892984692,
            1.0721757650375365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between 2-opt or node insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between 2-opt or node insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6743841892984692,
            1.0721757650375365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between 2-opt or node insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high diversity or non-dominated status)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve the solution structure\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware swaps to balance the three objectives\n    for _ in range(2):  # Perform a few swaps\n        # Calculate current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Find the most imbalanced objective\n        max_diff = max(current_obj) - min(current_obj)\n        if max_diff > 0.1 * sum(current_obj):  # If significant imbalance\n            # Try to improve the most imbalanced objective\n            best_improvement = 0\n            best_swap = None\n\n            for a in range(n):\n                for b in range(a+2, n):\n                    # Try swapping nodes a and b\n                    temp_solution = new_solution.copy()\n                    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n                    # Calculate new objective values\n                    new_obj = (\n                        sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                    )\n\n                    # Calculate improvement in the most imbalanced objective\n                    improvement = current_obj[np.argmax(current_obj)] - new_obj[np.argmax(current_obj)]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (a, b)\n\n            if best_swap is not None:\n                a, b = best_swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.719873029940023,
            4.402816867828369
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high diversity or non-dominated status)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve the solution structure\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware swaps to balance the three objectives\n    for _ in range(2):  # Perform a few swaps\n        # Calculate current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Find the most imbalanced objective\n        max_diff = max(current_obj) - min(current_obj)\n        if max_diff > 0.1 * sum(current_obj):  # If significant imbalance\n            # Try to improve the most imbalanced objective\n            best_improvement = 0\n            best_swap = None\n\n            for a in range(n):\n                for b in range(a+2, n):\n                    # Try swapping nodes a and b\n                    temp_solution = new_solution.copy()\n                    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n                    # Calculate new objective values\n                    new_obj = (\n                        sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                    )\n\n                    # Calculate improvement in the most imbalanced objective\n                    improvement = current_obj[np.argmax(current_obj)] - new_obj[np.argmax(current_obj)]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (a, b)\n\n            if best_swap is not None:\n                a, b = best_swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high diversity or non-dominated status)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve the solution structure\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware swaps to balance the three objectives\n    for _ in range(2):  # Perform a few swaps\n        # Calculate current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Find the most imbalanced objective\n        max_diff = max(current_obj) - min(current_obj)\n        if max_diff > 0.1 * sum(current_obj):  # If significant imbalance\n            # Try to improve the most imbalanced objective\n            best_improvement = 0\n            best_swap = None\n\n            for a in range(n):\n                for b in range(a+2, n):\n                    # Try swapping nodes a and b\n                    temp_solution = new_solution.copy()\n                    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n                    # Calculate new objective values\n                    new_obj = (\n                        sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                    )\n\n                    # Calculate improvement in the most imbalanced objective\n                    improvement = current_obj[np.argmax(current_obj)] - new_obj[np.argmax(current_obj)]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (a, b)\n\n            if best_swap is not None:\n                a, b = best_swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.719873029940023,
            4.402816867828369
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high diversity or non-dominated status)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve the solution structure\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware swaps to balance the three objectives\n    for _ in range(2):  # Perform a few swaps\n        # Calculate current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Find the most imbalanced objective\n        max_diff = max(current_obj) - min(current_obj)\n        if max_diff > 0.1 * sum(current_obj):  # If significant imbalance\n            # Try to improve the most imbalanced objective\n            best_improvement = 0\n            best_swap = None\n\n            for a in range(n):\n                for b in range(a+2, n):\n                    # Try swapping nodes a and b\n                    temp_solution = new_solution.copy()\n                    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n                    # Calculate new objective values\n                    new_obj = (\n                        sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                    )\n\n                    # Calculate improvement in the most imbalanced objective\n                    improvement = current_obj[np.argmax(current_obj)] - new_obj[np.argmax(current_obj)]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (a, b)\n\n            if best_swap is not None:\n                a, b = best_swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values for simplicity)\n    potentials = [1.0 / (sum(obj) + 1e-6) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    worst_obj = max(obj1, obj2, obj3)\n\n    if worst_obj == obj1:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    elif worst_obj == obj2:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    else:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.7630904668286096,
            1.0377737522125243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values for simplicity)\n    potentials = [1.0 / (sum(obj) + 1e-6) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    worst_obj = max(obj1, obj2, obj3)\n\n    if worst_obj == obj1:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    elif worst_obj == obj2:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    else:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values for simplicity)\n    potentials = [1.0 / (sum(obj) + 1e-6) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    worst_obj = max(obj1, obj2, obj3)\n\n    if worst_obj == obj1:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    elif worst_obj == obj2:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    else:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.7630904668286096,
            1.0377737522125243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values for simplicity)\n    potentials = [1.0 / (sum(obj) + 1e-6) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    worst_obj = max(obj1, obj2, obj3)\n\n    if worst_obj == obj1:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    elif worst_obj == obj2:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    else:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values for simplicity)\n    potentials = [1.0 / (sum(obj) + 1e-6) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    worst_obj = max(obj1, obj2, obj3)\n\n    if worst_obj == obj1:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    elif worst_obj == obj2:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    else:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.7630904668286096,
            1.0377737522125243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values for simplicity)\n    potentials = [1.0 / (sum(obj) + 1e-6) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    worst_obj = max(obj1, obj2, obj3)\n\n    if worst_obj == obj1:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    elif worst_obj == obj2:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    else:\n        # Improve the worst objective by swapping nodes that are far apart in this space\n        max_dist = -1\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest sum of objectives (worst solution)\n    # This is a heuristic to focus on solutions that may have room for improvement\n    _, objectives = zip(*archive)\n    sum_objectives = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge swap for the second objective\n    if n > 2:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(base_solution)):\n        # If invalid, revert to base solution with a small perturbation\n        new_solution = base_solution.copy()\n        m, p = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.5739451122611204,
            1.0911433815956115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest sum of objectives (worst solution)\n    # This is a heuristic to focus on solutions that may have room for improvement\n    _, objectives = zip(*archive)\n    sum_objectives = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge swap for the second objective\n    if n > 2:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(base_solution)):\n        # If invalid, revert to base solution with a small perturbation\n        new_solution = base_solution.copy()\n        m, p = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 or all if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective perturbation\n    n = len(base_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges to reverse\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Skip if it would create an invalid tour\n\n        # Apply 2-opt to reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective aware perturbation: randomly select one objective to prioritize\n        obj_to_optimize = np.random.choice([0, 1, 2])\n        if obj_to_optimize == 0:\n            # Optimize for first objective\n            for k in range(i, j):\n                current_cost = distance_matrix_1[new_solution[k], new_solution[k+1]]\n                for m in range(k+1, j+1):\n                    new_cost = distance_matrix_1[new_solution[k], new_solution[m]] + distance_matrix_1[new_solution[m], new_solution[k+1]]\n                    if new_cost < current_cost:\n                        # Swap nodes to reduce cost in first objective\n                        new_solution[k+1], new_solution[m] = new_solution[m], new_solution[k+1]\n                        break\n        elif obj_to_optimize == 1:\n            # Optimize for second objective\n            for k in range(i, j):\n                current_cost = distance_matrix_2[new_solution[k], new_solution[k+1]]\n                for m in range(k+1, j+1):\n                    new_cost = distance_matrix_2[new_solution[k], new_solution[m]] + distance_matrix_2[new_solution[m], new_solution[k+1]]\n                    if new_cost < current_cost:\n                        # Swap nodes to reduce cost in second objective\n                        new_solution[k+1], new_solution[m] = new_solution[m], new_solution[k+1]\n                        break\n        else:\n            # Optimize for third objective\n            for k in range(i, j):\n                current_cost = distance_matrix_3[new_solution[k], new_solution[k+1]]\n                for m in range(k+1, j+1):\n                    new_cost = distance_matrix_3[new_solution[k], new_solution[m]] + distance_matrix_3[new_solution[m], new_solution[k+1]]\n                    if new_cost < current_cost:\n                        # Swap nodes to reduce cost in third objective\n                        new_solution[k+1], new_solution[m] = new_solution[m], new_solution[k+1]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7577569149080691,
            2.248571217060089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 or all if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective perturbation\n    n = len(base_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges to reverse\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Skip if it would create an invalid tour\n\n        # Apply 2-opt to reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective aware perturbation: randomly select one objective to prioritize\n        obj_to_optimize = np.random.choice([0, 1, 2])\n        if obj_to_optimize == 0:\n            # Optimize for first objective\n            for k in range(i, j):\n                current_cost = distance_matrix_1[new_solution[k], new_solution[k+1]]\n                for m in range(k+1, j+1):\n                    new_cost = distance_matrix_1[new_solution[k], new_solution[m]] + distance_matrix_1[new_solution[m], new_solution[k+1]]\n                    if new_cost < current_cost:\n                        # Swap nodes to reduce cost in first objective\n                        new_solution[k+1], new_solution[m] = new_solution[m], new_solution[k+1]\n                        break\n        elif obj_to_optimize == 1:\n            # Optimize for second objective\n            for k in range(i, j):\n                current_cost = distance_matrix_2[new_solution[k], new_solution[k+1]]\n                for m in range(k+1, j+1):\n                    new_cost = distance_matrix_2[new_solution[k], new_solution[m]] + distance_matrix_2[new_solution[m], new_solution[k+1]]\n                    if new_cost < current_cost:\n                        # Swap nodes to reduce cost in second objective\n                        new_solution[k+1], new_solution[m] = new_solution[m], new_solution[k+1]\n                        break\n        else:\n            # Optimize for third objective\n            for k in range(i, j):\n                current_cost = distance_matrix_3[new_solution[k], new_solution[k+1]]\n                for m in range(k+1, j+1):\n                    new_cost = distance_matrix_3[new_solution[k], new_solution[m]] + distance_matrix_3[new_solution[m], new_solution[k+1]]\n                    if new_cost < current_cost:\n                        # Swap nodes to reduce cost in third objective\n                        new_solution[k+1], new_solution[m] = new_solution[m], new_solution[k+1]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that have at least one objective worse than the average\n    avg_costs = np.mean([obj for _, obj in archive], axis=0)\n    candidates = [(sol, obj) for sol, obj in archive if any(o > avg for o, avg in zip(obj, avg_costs))]\n\n    if not candidates:\n        candidates = archive\n\n    # Randomly select a candidate to avoid getting stuck\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform 2-opt on the objective with the highest cost\n    # 2. Apply a 3-exchange if the solution improves in at least two objectives\n    # 3. If no improvement, perform a random 2-opt\n\n    # Step 1: Identify the worst objective to improve\n    worst_obj = np.argmax(selected[1])\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Step 2: Apply 2-opt on the worst objective\n    improved = False\n    n = len(new_solution)\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            # Try reversing the segment between i and j\n            temp_solution = new_solution.copy()\n            temp_solution[i+1:j+1] = temp_solution[i+1:j+1][::-1]\n\n            # Calculate new cost for the worst objective\n            new_cost = 0\n            for k in range(n):\n                new_cost += distance_matrix[temp_solution[k], temp_solution[(k+1)%n]]\n\n            # If improvement, accept and check for multi-objective improvement\n            if new_cost < selected[1][worst_obj]:\n                new_solution = temp_solution\n                improved = True\n                break\n        if improved:\n            break\n\n    # Step 3: If improvement in worst objective, check if it improves in other objectives\n    if improved:\n        # Calculate new costs for all objectives\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # If at least two objectives improved, accept the solution\n        if sum(new_cost < old_cost for new_cost, old_cost in zip(new_costs, selected[1])) >= 2:\n            return new_solution\n\n        # Otherwise, try a 3-exchange\n        for i in range(n - 2):\n            for j in range(i + 2, n - 1):\n                for k in range(j + 2, n):\n                    temp_solution = new_solution.copy()\n                    # Perform 3-exchange: reverse segments between i-j and j-k\n                    temp_solution[i+1:j+1] = temp_solution[i+1:j+1][::-1]\n                    temp_solution[j+1:k+1] = temp_solution[j+1:k+1][::-1]\n\n                    # Calculate new costs\n                    new_costs = [\n                        sum(distance_matrix_1[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n)),\n                        sum(distance_matrix_2[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n)),\n                        sum(distance_matrix_3[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n))\n                    ]\n\n                    # If at least two objectives improved, accept\n                    if sum(new_cost < old_cost for new_cost, old_cost in zip(new_costs, selected[1])) >= 2:\n                        return temp_solution\n\n    # If no improvement, perform a random 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5783761936346945,
            3.3451564788818358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that have at least one objective worse than the average\n    avg_costs = np.mean([obj for _, obj in archive], axis=0)\n    candidates = [(sol, obj) for sol, obj in archive if any(o > avg for o, avg in zip(obj, avg_costs))]\n\n    if not candidates:\n        candidates = archive\n\n    # Randomly select a candidate to avoid getting stuck\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform 2-opt on the objective with the highest cost\n    # 2. Apply a 3-exchange if the solution improves in at least two objectives\n    # 3. If no improvement, perform a random 2-opt\n\n    # Step 1: Identify the worst objective to improve\n    worst_obj = np.argmax(selected[1])\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Step 2: Apply 2-opt on the worst objective\n    improved = False\n    n = len(new_solution)\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            # Try reversing the segment between i and j\n            temp_solution = new_solution.copy()\n            temp_solution[i+1:j+1] = temp_solution[i+1:j+1][::-1]\n\n            # Calculate new cost for the worst objective\n            new_cost = 0\n            for k in range(n):\n                new_cost += distance_matrix[temp_solution[k], temp_solution[(k+1)%n]]\n\n            # If improvement, accept and check for multi-objective improvement\n            if new_cost < selected[1][worst_obj]:\n                new_solution = temp_solution\n                improved = True\n                break\n        if improved:\n            break\n\n    # Step 3: If improvement in worst objective, check if it improves in other objectives\n    if improved:\n        # Calculate new costs for all objectives\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # If at least two objectives improved, accept the solution\n        if sum(new_cost < old_cost for new_cost, old_cost in zip(new_costs, selected[1])) >= 2:\n            return new_solution\n\n        # Otherwise, try a 3-exchange\n        for i in range(n - 2):\n            for j in range(i + 2, n - 1):\n                for k in range(j + 2, n):\n                    temp_solution = new_solution.copy()\n                    # Perform 3-exchange: reverse segments between i-j and j-k\n                    temp_solution[i+1:j+1] = temp_solution[i+1:j+1][::-1]\n                    temp_solution[j+1:k+1] = temp_solution[j+1:k+1][::-1]\n\n                    # Calculate new costs\n                    new_costs = [\n                        sum(distance_matrix_1[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n)),\n                        sum(distance_matrix_2[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n)),\n                        sum(distance_matrix_3[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n))\n                    ]\n\n                    # If at least two objectives improved, accept\n                    if sum(new_cost < old_cost for new_cost, old_cost in zip(new_costs, selected[1])) >= 2:\n                        return temp_solution\n\n    # If no improvement, perform a random 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objectives (e.g., sum of objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list (more potential for improvement)\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to modify\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Extract the segment\n        segment = new_solution[start:end]\n\n        # Apply a local search operation to the segment\n        if random.random() < 0.5:\n            # Reverse the segment (2-opt variant)\n            segment = segment[::-1]\n        else:\n            # Rotate the segment\n            k = random.randint(1, segment_size - 1)\n            segment = np.roll(segment, k)\n\n        # Insert the modified segment back\n        new_solution[start:end] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6371244580704923,
            1.2229036211967468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objectives (e.g., sum of objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list (more potential for improvement)\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to modify\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Extract the segment\n        segment = new_solution[start:end]\n\n        # Apply a local search operation to the segment\n        if random.random() < 0.5:\n            # Reverse the segment (2-opt variant)\n            segment = segment[::-1]\n        else:\n            # Rotate the segment\n            k = random.randint(1, segment_size - 1)\n            segment = np.roll(segment, k)\n\n        # Insert the modified segment back\n        new_solution[start:end] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        diversity_scores = np.sum(diversity * np.random.rand(3), axis=0)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt, 3-opt, and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between different local search operators\n        operator = np.random.choice(['2opt', '3opt', 'objective_aware'])\n\n        if operator == '2opt':\n            # 2-opt local search\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == '3opt':\n            # 3-opt local search\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        elif operator == 'objective_aware':\n            # Objective-aware swap that considers all three objectives\n            # Select two nodes with high potential for improvement\n            costs = np.zeros(n)\n            for i in range(n):\n                prev = new_solution[i-1]\n                next_node = new_solution[(i+1)%n]\n                costs[i] = (distance_matrix_1[prev, new_solution[i]] +\n                           distance_matrix_2[prev, new_solution[i]] +\n                           distance_matrix_3[prev, new_solution[i]] +\n                           distance_matrix_1[new_solution[i], next_node] +\n                           distance_matrix_2[new_solution[i], next_node] +\n                           distance_matrix_3[new_solution[i], next_node])\n\n            # Find nodes with highest cost\n            high_cost_nodes = np.argsort(costs)[-2:]\n            i, j = high_cost_nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6531872921427486,
            1.4075146675109864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        diversity_scores = np.sum(diversity * np.random.rand(3), axis=0)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt, 3-opt, and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between different local search operators\n        operator = np.random.choice(['2opt', '3opt', 'objective_aware'])\n\n        if operator == '2opt':\n            # 2-opt local search\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == '3opt':\n            # 3-opt local search\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        elif operator == 'objective_aware':\n            # Objective-aware swap that considers all three objectives\n            # Select two nodes with high potential for improvement\n            costs = np.zeros(n)\n            for i in range(n):\n                prev = new_solution[i-1]\n                next_node = new_solution[(i+1)%n]\n                costs[i] = (distance_matrix_1[prev, new_solution[i]] +\n                           distance_matrix_2[prev, new_solution[i]] +\n                           distance_matrix_3[prev, new_solution[i]] +\n                           distance_matrix_1[new_solution[i], next_node] +\n                           distance_matrix_2[new_solution[i], next_node] +\n                           distance_matrix_3[new_solution[i], next_node])\n\n            # Find nodes with highest cost\n            high_cost_nodes = np.argsort(costs)[-2:]\n            i, j = high_cost_nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its \"promise\" (inverse of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    # Normalize objectives to avoid division by zero\n    normalized_objectives = objectives + 1e-10\n    # Calculate selection probabilities (higher probability for solutions with lower objectives)\n    selection_probs = 1 / np.sum(normalized_objectives, axis=1)\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, apply a combination of 2-opt and node insertion\n        # First, perform 2-opt between two random segments\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Then, perform node insertion for one random node\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        # Remove node from its current position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        # Insert node at a random new position\n        l = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:l], [node], new_solution[l:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6927399002366647,
            1.0848463654518128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its \"promise\" (inverse of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    # Normalize objectives to avoid division by zero\n    normalized_objectives = objectives + 1e-10\n    # Calculate selection probabilities (higher probability for solutions with lower objectives)\n    selection_probs = 1 / np.sum(normalized_objectives, axis=1)\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, apply a combination of 2-opt and node insertion\n        # First, perform 2-opt between two random segments\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Then, perform node insertion for one random node\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        # Remove node from its current position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        # Insert node at a random new position\n        l = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:l], [node], new_solution[l:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # First, perform a 2-opt move to improve one objective\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Try random 2-opt moves to find the best improvement in any objective\n    for _ in range(10):  # Limit number of trials for efficiency\n        i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n        if i == 0 and j == n_nodes - 1:\n            continue  # Skip full reversal as it's symmetric\n\n        # Calculate original and new distances for all three objectives\n        orig_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change1 = new_dist1 - orig_dist1\n\n        orig_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change2 = new_dist2 - orig_dist2\n\n        orig_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change3 = new_dist3 - orig_dist3\n\n        # Calculate combined improvement (weighted sum of improvements)\n        improvement = (change1 + change2 + change3) / 3\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_i, best_j = i, j\n\n    if best_improvement < 0:  # Only apply if there's improvement\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # Second, perform objective-aware swaps to balance objectives\n    for _ in range(5):  # Limit number of swaps for efficiency\n        i, j = np.random.choice(n_nodes, 2, replace=False)\n\n        # Calculate original and new distances for all three objectives\n        orig_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change1 = new_dist1 - orig_dist1\n\n        orig_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change2 = new_dist2 - orig_dist2\n\n        orig_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change3 = new_dist3 - orig_dist3\n\n        # Calculate combined improvement\n        improvement = (change1 + change2 + change3) / 3\n\n        if improvement < 0:  # Only apply if there's improvement\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7803437482423333,
            2.8353098392486573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # First, perform a 2-opt move to improve one objective\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Try random 2-opt moves to find the best improvement in any objective\n    for _ in range(10):  # Limit number of trials for efficiency\n        i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n        if i == 0 and j == n_nodes - 1:\n            continue  # Skip full reversal as it's symmetric\n\n        # Calculate original and new distances for all three objectives\n        orig_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change1 = new_dist1 - orig_dist1\n\n        orig_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change2 = new_dist2 - orig_dist2\n\n        orig_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change3 = new_dist3 - orig_dist3\n\n        # Calculate combined improvement (weighted sum of improvements)\n        improvement = (change1 + change2 + change3) / 3\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_i, best_j = i, j\n\n    if best_improvement < 0:  # Only apply if there's improvement\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # Second, perform objective-aware swaps to balance objectives\n    for _ in range(5):  # Limit number of swaps for efficiency\n        i, j = np.random.choice(n_nodes, 2, replace=False)\n\n        # Calculate original and new distances for all three objectives\n        orig_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change1 = new_dist1 - orig_dist1\n\n        orig_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change2 = new_dist2 - orig_dist2\n\n        orig_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change3 = new_dist3 - orig_dist3\n\n        # Calculate combined improvement\n        improvement = (change1 + change2 + change3) / 3\n\n        if improvement < 0:  # Only apply if there's improvement\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # First, perform a 2-opt move to improve one objective\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Try random 2-opt moves to find the best improvement in any objective\n    for _ in range(10):  # Limit number of trials for efficiency\n        i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n        if i == 0 and j == n_nodes - 1:\n            continue  # Skip full reversal as it's symmetric\n\n        # Calculate original and new distances for all three objectives\n        orig_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change1 = new_dist1 - orig_dist1\n\n        orig_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change2 = new_dist2 - orig_dist2\n\n        orig_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change3 = new_dist3 - orig_dist3\n\n        # Calculate combined improvement (weighted sum of improvements)\n        improvement = (change1 + change2 + change3) / 3\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_i, best_j = i, j\n\n    if best_improvement < 0:  # Only apply if there's improvement\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # Second, perform objective-aware swaps to balance objectives\n    for _ in range(5):  # Limit number of swaps for efficiency\n        i, j = np.random.choice(n_nodes, 2, replace=False)\n\n        # Calculate original and new distances for all three objectives\n        orig_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change1 = new_dist1 - orig_dist1\n\n        orig_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change2 = new_dist2 - orig_dist2\n\n        orig_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change3 = new_dist3 - orig_dist3\n\n        # Calculate combined improvement\n        improvement = (change1 + change2 + change3) / 3\n\n        if improvement < 0:  # Only apply if there's improvement\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7803437482423333,
            2.8353098392486573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # First, perform a 2-opt move to improve one objective\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Try random 2-opt moves to find the best improvement in any objective\n    for _ in range(10):  # Limit number of trials for efficiency\n        i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n        if i == 0 and j == n_nodes - 1:\n            continue  # Skip full reversal as it's symmetric\n\n        # Calculate original and new distances for all three objectives\n        orig_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change1 = new_dist1 - orig_dist1\n\n        orig_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change2 = new_dist2 - orig_dist2\n\n        orig_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change3 = new_dist3 - orig_dist3\n\n        # Calculate combined improvement (weighted sum of improvements)\n        improvement = (change1 + change2 + change3) / 3\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_i, best_j = i, j\n\n    if best_improvement < 0:  # Only apply if there's improvement\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # Second, perform objective-aware swaps to balance objectives\n    for _ in range(5):  # Limit number of swaps for efficiency\n        i, j = np.random.choice(n_nodes, 2, replace=False)\n\n        # Calculate original and new distances for all three objectives\n        orig_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change1 = new_dist1 - orig_dist1\n\n        orig_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change2 = new_dist2 - orig_dist2\n\n        orig_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n_nodes]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]])\n        new_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[j], new_solution[(i+1)%n_nodes]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]])\n        change3 = new_dist3 - orig_dist3\n\n        # Calculate combined improvement\n        improvement = (change1 + change2 + change3) / 3\n\n        if improvement < 0:  # Only apply if there's improvement\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    # Here, we randomly select a solution with a low probability of being in the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # 1. Perform 2-opt on the worst-performing objective\n    objectives = [obj for _, obj in archive]\n    avg_obj = np.mean(objectives, axis=0)\n    worst_obj_idx = np.argmax(avg_obj)  # Index of the worst objective\n\n    # Select the distance matrix corresponding to the worst objective\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt on the worst objective\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Apply node insertion to reduce the worst objective\n    node_to_move = np.random.randint(0, n)\n    new_solution = np.delete(new_solution, node_to_move)\n    insert_pos = np.random.randint(0, n - 1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # 3. Perform objective-aware swaps to balance objectives\n    for _ in range(2):  # Limit the number of swaps to avoid excessive computation\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        # Swap nodes if it improves the worst objective\n        if dist_matrix[new_solution[a-1], new_solution[b]] + dist_matrix[new_solution[b], new_solution[(a+1)%n]] < \\\n           dist_matrix[new_solution[a-1], new_solution[a]] + dist_matrix[new_solution[b-1], new_solution[b]]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6151806236389677,
            0.5182987689971924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    # Here, we randomly select a solution with a low probability of being in the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # 1. Perform 2-opt on the worst-performing objective\n    objectives = [obj for _, obj in archive]\n    avg_obj = np.mean(objectives, axis=0)\n    worst_obj_idx = np.argmax(avg_obj)  # Index of the worst objective\n\n    # Select the distance matrix corresponding to the worst objective\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt on the worst objective\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Apply node insertion to reduce the worst objective\n    node_to_move = np.random.randint(0, n)\n    new_solution = np.delete(new_solution, node_to_move)\n    insert_pos = np.random.randint(0, n - 1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # 3. Perform objective-aware swaps to balance objectives\n    for _ in range(2):  # Limit the number of swaps to avoid excessive computation\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        # Swap nodes if it improves the worst objective\n        if dist_matrix[new_solution[a-1], new_solution[b]] + dist_matrix[new_solution[b], new_solution[(a+1)%n]] < \\\n           dist_matrix[new_solution[a-1], new_solution[a]] + dist_matrix[new_solution[b-1], new_solution[b]]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    # Here, we randomly select a solution with a low probability of being in the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # 1. Perform 2-opt on the worst-performing objective\n    objectives = [obj for _, obj in archive]\n    avg_obj = np.mean(objectives, axis=0)\n    worst_obj_idx = np.argmax(avg_obj)  # Index of the worst objective\n\n    # Select the distance matrix corresponding to the worst objective\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt on the worst objective\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Apply node insertion to reduce the worst objective\n    node_to_move = np.random.randint(0, n)\n    new_solution = np.delete(new_solution, node_to_move)\n    insert_pos = np.random.randint(0, n - 1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # 3. Perform objective-aware swaps to balance objectives\n    for _ in range(2):  # Limit the number of swaps to avoid excessive computation\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        # Swap nodes if it improves the worst objective\n        if dist_matrix[new_solution[a-1], new_solution[b]] + dist_matrix[new_solution[b], new_solution[(a+1)%n]] < \\\n           dist_matrix[new_solution[a-1], new_solution[a]] + dist_matrix[new_solution[b-1], new_solution[b]]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6151806236389677,
            0.5182987689971924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    # Here, we randomly select a solution with a low probability of being in the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # 1. Perform 2-opt on the worst-performing objective\n    objectives = [obj for _, obj in archive]\n    avg_obj = np.mean(objectives, axis=0)\n    worst_obj_idx = np.argmax(avg_obj)  # Index of the worst objective\n\n    # Select the distance matrix corresponding to the worst objective\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt on the worst objective\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Apply node insertion to reduce the worst objective\n    node_to_move = np.random.randint(0, n)\n    new_solution = np.delete(new_solution, node_to_move)\n    insert_pos = np.random.randint(0, n - 1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # 3. Perform objective-aware swaps to balance objectives\n    for _ in range(2):  # Limit the number of swaps to avoid excessive computation\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        # Swap nodes if it improves the worst objective\n        if dist_matrix[new_solution[a-1], new_solution[b]] + dist_matrix[new_solution[b], new_solution[(a+1)%n]] < \\\n           dist_matrix[new_solution[a-1], new_solution[a]] + dist_matrix[new_solution[b-1], new_solution[b]]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 13,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (e.g., one with the highest objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move (for the first objective)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Path relinking (for the second and third objectives)\n    # Select a reference solution from the archive (different from the base solution)\n    ref_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n    ref_solution = archive[ref_idx][0]\n\n    # Identify common segments between base and reference solutions\n    common_indices = [i for i in range(n) if base_solution[i] == ref_solution[i]]\n\n    if len(common_indices) > 1:\n        # Perform path relinking by swapping segments\n        start, end = sorted(np.random.choice(common_indices, 2, replace=False))\n        new_solution[start:end+1] = ref_solution[start:end+1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in missing_nodes:\n                new_solution[i] = np.random.choice(np.setdiff1d(np.arange(n), new_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.6628994275983242,
            1.2116239666938782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (e.g., one with the highest objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move (for the first objective)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Path relinking (for the second and third objectives)\n    # Select a reference solution from the archive (different from the base solution)\n    ref_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n    ref_solution = archive[ref_idx][0]\n\n    # Identify common segments between base and reference solutions\n    common_indices = [i for i in range(n) if base_solution[i] == ref_solution[i]]\n\n    if len(common_indices) > 1:\n        # Perform path relinking by swapping segments\n        start, end = sorted(np.random.choice(common_indices, 2, replace=False))\n        new_solution[start:end+1] = ref_solution[start:end+1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in missing_nodes:\n                new_solution[i] = np.random.choice(np.setdiff1d(np.arange(n), new_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 14,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    # Here, we select the solution with the highest sum of objectives (worst solution in the archive)\n    objectives = [obj for _, obj in archive]\n    worst_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and multi-objective edge swapping\n    n = len(new_solution)\n    i, j = np.random.randint(0, n, size=2)\n\n    # Ensure i < j to avoid redundant swaps\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swapping: swap edges if it improves any objective\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        # Calculate current and new distances for all three objectives\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(k+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(k+1)%n]]\n\n        current_cost3 = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]]\n        new_cost3 = distance_matrix_3[new_solution[k-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(k+1)%n]]\n\n        # If the swap improves any objective, perform it\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or (new_cost3 < current_cost3):\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6734034436716365,
            1.0359989166259767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    # Here, we select the solution with the highest sum of objectives (worst solution in the archive)\n    objectives = [obj for _, obj in archive]\n    worst_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and multi-objective edge swapping\n    n = len(new_solution)\n    i, j = np.random.randint(0, n, size=2)\n\n    # Ensure i < j to avoid redundant swaps\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swapping: swap edges if it improves any objective\n    for k in range(n):\n        if k == i or k == j:\n            continue\n\n        # Calculate current and new distances for all three objectives\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(k+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(k+1)%n]]\n\n        current_cost3 = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]]\n        new_cost3 = distance_matrix_3[new_solution[k-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(k+1)%n]]\n\n        # If the swap improves any objective, perform it\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or (new_cost3 < current_cost3):\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to balance all three objectives\n    # Calculate current objective values for the base solution\n    current_obj = archive[selected_idx][1]\n    current_cost1 = current_obj[0]\n    current_cost2 = current_obj[1]\n    current_cost3 = current_obj[2]\n\n    # Find the worst-performing objective\n    worst_obj = np.argmax([current_cost1, current_cost2, current_cost3])\n\n    # Try to improve the worst objective by swapping nodes\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a == b:\n            continue\n\n        # Calculate the change in each objective\n        delta1 = (distance_matrix_1[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_1[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_1[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_1[base_solution[b], base_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_2[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_2[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_2[base_solution[b], base_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_3[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_3[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_3[base_solution[b], base_solution[(b+1)%n]])\n\n        # Apply the swap if it improves the worst objective\n        if worst_obj == 0 and delta1 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n        elif worst_obj == 1 and delta2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n        elif worst_obj == 2 and delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7813414047057633,
            0.8167322754859925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to balance all three objectives\n    # Calculate current objective values for the base solution\n    current_obj = archive[selected_idx][1]\n    current_cost1 = current_obj[0]\n    current_cost2 = current_obj[1]\n    current_cost3 = current_obj[2]\n\n    # Find the worst-performing objective\n    worst_obj = np.argmax([current_cost1, current_cost2, current_cost3])\n\n    # Try to improve the worst objective by swapping nodes\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a == b:\n            continue\n\n        # Calculate the change in each objective\n        delta1 = (distance_matrix_1[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_1[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_1[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_1[base_solution[b], base_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_2[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_2[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_2[base_solution[b], base_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_3[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_3[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_3[base_solution[b], base_solution[(b+1)%n]])\n\n        # Apply the swap if it improves the worst objective\n        if worst_obj == 0 and delta1 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n        elif worst_obj == 1 and delta2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n        elif worst_obj == 2 and delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to balance all three objectives\n    # Calculate current objective values for the base solution\n    current_obj = archive[selected_idx][1]\n    current_cost1 = current_obj[0]\n    current_cost2 = current_obj[1]\n    current_cost3 = current_obj[2]\n\n    # Find the worst-performing objective\n    worst_obj = np.argmax([current_cost1, current_cost2, current_cost3])\n\n    # Try to improve the worst objective by swapping nodes\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a == b:\n            continue\n\n        # Calculate the change in each objective\n        delta1 = (distance_matrix_1[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_1[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_1[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_1[base_solution[b], base_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_2[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_2[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_2[base_solution[b], base_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_3[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_3[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_3[base_solution[b], base_solution[(b+1)%n]])\n\n        # Apply the swap if it improves the worst objective\n        if worst_obj == 0 and delta1 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n        elif worst_obj == 1 and delta2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n        elif worst_obj == 2 and delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7813414047057633,
            0.8167322754859925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to balance all three objectives\n    # Calculate current objective values for the base solution\n    current_obj = archive[selected_idx][1]\n    current_cost1 = current_obj[0]\n    current_cost2 = current_obj[1]\n    current_cost3 = current_obj[2]\n\n    # Find the worst-performing objective\n    worst_obj = np.argmax([current_cost1, current_cost2, current_cost3])\n\n    # Try to improve the worst objective by swapping nodes\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a == b:\n            continue\n\n        # Calculate the change in each objective\n        delta1 = (distance_matrix_1[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_1[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_1[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_1[base_solution[b], base_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_2[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_2[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_2[base_solution[b], base_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[base_solution[a-1], base_solution[b]] +\n                  distance_matrix_3[base_solution[b], base_solution[(a+1)%n]] -\n                  distance_matrix_3[base_solution[a-1], base_solution[a]] -\n                  distance_matrix_3[base_solution[b], base_solution[(b+1)%n]])\n\n        # Apply the swap if it improves the worst objective\n        if worst_obj == 0 and delta1 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n        elif worst_obj == 1 and delta2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n        elif worst_obj == 2 and delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not too similar to others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    improved = False\n\n    # First, try 2-opt for a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate the change in objectives\n    def calculate_objectives(sol):\n        total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (total1, total2, total3)\n\n    old_obj = archive[selected_idx][1]\n    new_obj = calculate_objectives(new_solution)\n\n    # If 2-opt doesn't improve all objectives, try objective-aware swaps\n    if not all(new_obj[i] <= old_obj[i] for i in range(3)):\n        # Find the most critical objective (one that worsened the most)\n        worst_obj_idx = np.argmax([(new_obj[i] - old_obj[i]) for i in range(3)])\n\n        # Try to improve this objective by swapping nodes\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            i, j = random.sample(range(n), 2)\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n            temp_obj = calculate_objectives(temp_sol)\n\n            if temp_obj[worst_obj_idx] < new_obj[worst_obj_idx]:\n                new_solution = temp_sol.copy()\n                new_obj = temp_obj\n                improved = True\n                break\n\n    # If no improvement found, try a different 2-opt segment\n    if not improved:\n        for _ in range(5):\n            i, j = sorted(random.sample(range(n), 2))\n            temp_sol = new_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n            temp_obj = calculate_objectives(temp_sol)\n\n            if all(temp_obj[i] <= new_obj[i] for i in range(3)):\n                new_solution = temp_sol.copy()\n                new_obj = temp_obj\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7963598024760128,
            1.0479237914085389
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not too similar to others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    improved = False\n\n    # First, try 2-opt for a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate the change in objectives\n    def calculate_objectives(sol):\n        total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (total1, total2, total3)\n\n    old_obj = archive[selected_idx][1]\n    new_obj = calculate_objectives(new_solution)\n\n    # If 2-opt doesn't improve all objectives, try objective-aware swaps\n    if not all(new_obj[i] <= old_obj[i] for i in range(3)):\n        # Find the most critical objective (one that worsened the most)\n        worst_obj_idx = np.argmax([(new_obj[i] - old_obj[i]) for i in range(3)])\n\n        # Try to improve this objective by swapping nodes\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            i, j = random.sample(range(n), 2)\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n            temp_obj = calculate_objectives(temp_sol)\n\n            if temp_obj[worst_obj_idx] < new_obj[worst_obj_idx]:\n                new_solution = temp_sol.copy()\n                new_obj = temp_obj\n                improved = True\n                break\n\n    # If no improvement found, try a different 2-opt segment\n    if not improved:\n        for _ in range(5):\n            i, j = sorted(random.sample(range(n), 2))\n            temp_sol = new_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n            temp_obj = calculate_objectives(temp_sol)\n\n            if all(temp_obj[i] <= new_obj[i] for i in range(3)):\n                new_solution = temp_sol.copy()\n                new_obj = temp_obj\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not too similar to others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    improved = False\n\n    # First, try 2-opt for a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate the change in objectives\n    def calculate_objectives(sol):\n        total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (total1, total2, total3)\n\n    old_obj = archive[selected_idx][1]\n    new_obj = calculate_objectives(new_solution)\n\n    # If 2-opt doesn't improve all objectives, try objective-aware swaps\n    if not all(new_obj[i] <= old_obj[i] for i in range(3)):\n        # Find the most critical objective (one that worsened the most)\n        worst_obj_idx = np.argmax([(new_obj[i] - old_obj[i]) for i in range(3)])\n\n        # Try to improve this objective by swapping nodes\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            i, j = random.sample(range(n), 2)\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n            temp_obj = calculate_objectives(temp_sol)\n\n            if temp_obj[worst_obj_idx] < new_obj[worst_obj_idx]:\n                new_solution = temp_sol.copy()\n                new_obj = temp_obj\n                improved = True\n                break\n\n    # If no improvement found, try a different 2-opt segment\n    if not improved:\n        for _ in range(5):\n            i, j = sorted(random.sample(range(n), 2))\n            temp_sol = new_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n            temp_obj = calculate_objectives(temp_sol)\n\n            if all(temp_obj[i] <= new_obj[i] for i in range(3)):\n                new_solution = temp_sol.copy()\n                new_obj = temp_obj\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7963598024760128,
            1.0479237914085389
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not too similar to others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    improved = False\n\n    # First, try 2-opt for a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate the change in objectives\n    def calculate_objectives(sol):\n        total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (total1, total2, total3)\n\n    old_obj = archive[selected_idx][1]\n    new_obj = calculate_objectives(new_solution)\n\n    # If 2-opt doesn't improve all objectives, try objective-aware swaps\n    if not all(new_obj[i] <= old_obj[i] for i in range(3)):\n        # Find the most critical objective (one that worsened the most)\n        worst_obj_idx = np.argmax([(new_obj[i] - old_obj[i]) for i in range(3)])\n\n        # Try to improve this objective by swapping nodes\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            i, j = random.sample(range(n), 2)\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n            temp_obj = calculate_objectives(temp_sol)\n\n            if temp_obj[worst_obj_idx] < new_obj[worst_obj_idx]:\n                new_solution = temp_sol.copy()\n                new_obj = temp_obj\n                improved = True\n                break\n\n    # If no improvement found, try a different 2-opt segment\n    if not improved:\n        for _ in range(5):\n            i, j = sorted(random.sample(range(n), 2))\n            temp_sol = new_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n            temp_obj = calculate_objectives(temp_sol)\n\n            if all(temp_obj[i] <= new_obj[i] for i in range(3)):\n                new_solution = temp_sol.copy()\n                new_obj = temp_obj\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to avoid extremes\n        base_solution = sorted_solutions[len(sorted_solutions) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt, relocate, and swap operations\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly choose one of three local search operators\n        operator = np.random.choice(['2opt', 'relocate', 'swap'])\n\n        if operator == '2opt':\n            # 2-opt: reverse a segment of the tour\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == 'relocate':\n            # Relocate: move a node to a different position\n            i, j = np.random.choice(n, 2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        elif operator == 'swap':\n            # Swap: exchange two nodes\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7100088513620246,
            1.100592267513275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to avoid extremes\n        base_solution = sorted_solutions[len(sorted_solutions) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt, relocate, and swap operations\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly choose one of three local search operators\n        operator = np.random.choice(['2opt', 'relocate', 'swap'])\n\n        if operator == '2opt':\n            # 2-opt: reverse a segment of the tour\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == 'relocate':\n            # Relocate: move a node to a different position\n            i, j = np.random.choice(n, 2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        elif operator == 'swap':\n            # Swap: exchange two nodes\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 18,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low dominance count\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and random segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt and segment reversal\n    if np.random.random() < 0.5:\n        # 2-opt local search\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random segment reversal with objective-aware selection\n        segment_length = np.random.randint(2, min(10, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Choose which objective to prioritize for reversal\n        obj_weights = np.random.dirichlet(np.ones(3))\n        costs = [\n            distance_matrix_1[new_solution[start-1], new_solution[start]] +\n            distance_matrix_1[new_solution[end], new_solution[end+1 if end+1 < n else 0]],\n            distance_matrix_2[new_solution[start-1], new_solution[start]] +\n            distance_matrix_2[new_solution[end], new_solution[end+1 if end+1 < n else 0]],\n            distance_matrix_3[new_solution[start-1], new_solution[start]] +\n            distance_matrix_3[new_solution[end], new_solution[end+1 if end+1 < n else 0]]\n        ]\n        weighted_cost = sum(w * c for w, c in zip(obj_weights, costs))\n\n        # Only reverse if it improves at least one objective\n        if weighted_cost > 0:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.784107879962727,
            1.2179905295372009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low dominance count\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and random segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt and segment reversal\n    if np.random.random() < 0.5:\n        # 2-opt local search\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random segment reversal with objective-aware selection\n        segment_length = np.random.randint(2, min(10, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Choose which objective to prioritize for reversal\n        obj_weights = np.random.dirichlet(np.ones(3))\n        costs = [\n            distance_matrix_1[new_solution[start-1], new_solution[start]] +\n            distance_matrix_1[new_solution[end], new_solution[end+1 if end+1 < n else 0]],\n            distance_matrix_2[new_solution[start-1], new_solution[start]] +\n            distance_matrix_2[new_solution[end], new_solution[end+1 if end+1 < n else 0]],\n            distance_matrix_3[new_solution[start-1], new_solution[start]] +\n            distance_matrix_3[new_solution[end], new_solution[end+1 if end+1 < n else 0]]\n        ]\n        weighted_cost = sum(w * c for w, c in zip(obj_weights, costs))\n\n        # Only reverse if it improves at least one objective\n        if weighted_cost > 0:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 19,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and potential for improvement\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    objectives = [obj for _, obj in archive]\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve the worst objective\n    obj_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj_values)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform additional swaps based on objective diversity\n    for _ in range(2):\n        a, b = random.sample(range(1, n), 2)\n        if a > b:\n            a, b = b, a\n        # Check if swap improves at least one objective\n        current_cost = (dist_matrix[new_solution[a-1], new_solution[a]] +\n                        dist_matrix[new_solution[b-1], new_solution[b]])\n        swapped_cost = (dist_matrix[new_solution[a-1], new_solution[b]] +\n                        dist_matrix[new_solution[b-1], new_solution[a]])\n        if swapped_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7209654395341785,
            1.060483455657959
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and potential for improvement\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    objectives = [obj for _, obj in archive]\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve the worst objective\n    obj_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj_values)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform additional swaps based on objective diversity\n    for _ in range(2):\n        a, b = random.sample(range(1, n), 2)\n        if a > b:\n            a, b = b, a\n        # Check if swap improves at least one objective\n        current_cost = (dist_matrix[new_solution[a-1], new_solution[a]] +\n                        dist_matrix[new_solution[b-1], new_solution[b]])\n        swapped_cost = (dist_matrix[new_solution[a-1], new_solution[b]] +\n                        dist_matrix[new_solution[b-1], new_solution[a]])\n        if swapped_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with a bias towards those with higher objective diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity) if np.any(diversity) else np.ones(3) / 3\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    scores = np.sum(weights * ranks, axis=1)\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply objective-aware edge swaps\n    for _ in range(2):  # Limit the number of swaps to maintain diversity\n        # Calculate edge costs for all objectives\n        edge_costs = np.zeros((n, 3))\n        for k in range(n):\n            prev = new_solution[(k-1) % n]\n            curr = new_solution[k]\n            next_node = new_solution[(k+1) % n]\n            edge_costs[k, 0] = distance_matrix_1[curr, next_node]\n            edge_costs[k, 1] = distance_matrix_2[curr, next_node]\n            edge_costs[k, 2] = distance_matrix_3[curr, next_node]\n\n        # Identify the worst edges in any objective\n        worst_edges = np.argmax(np.max(edge_costs, axis=1))\n        a, b = worst_edges, (worst_edges + 1) % n\n\n        # Find a better edge to replace it with\n        candidates = []\n        for i in range(n):\n            if i != a and i != b and i != (a-1) % n and i != (b+1) % n:\n                # Calculate the cost of the new edge\n                new_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(b+1)%n]]\n                old_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(b+1)%n]]\n                old_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n                new_cost3 = distance_matrix_3[new_solution[(a-1)%n], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(b+1)%n]]\n                old_cost3 = distance_matrix_3[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n\n                improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2) + (old_cost3 - new_cost3)\n                candidates.append((i, improvement))\n\n        if candidates:\n            best_candidate = max(candidates, key=lambda x: x[1])\n            if best_candidate[1] > 0:\n                i = best_candidate[0]\n                # Perform the edge swap\n                if i < a:\n                    new_solution[i:a] = new_solution[i:a][::-1]\n                else:\n                    new_solution[a:i] = new_solution[a:i][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6993933339502432,
            2.0615348696708677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with a bias towards those with higher objective diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity) if np.any(diversity) else np.ones(3) / 3\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    scores = np.sum(weights * ranks, axis=1)\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply objective-aware edge swaps\n    for _ in range(2):  # Limit the number of swaps to maintain diversity\n        # Calculate edge costs for all objectives\n        edge_costs = np.zeros((n, 3))\n        for k in range(n):\n            prev = new_solution[(k-1) % n]\n            curr = new_solution[k]\n            next_node = new_solution[(k+1) % n]\n            edge_costs[k, 0] = distance_matrix_1[curr, next_node]\n            edge_costs[k, 1] = distance_matrix_2[curr, next_node]\n            edge_costs[k, 2] = distance_matrix_3[curr, next_node]\n\n        # Identify the worst edges in any objective\n        worst_edges = np.argmax(np.max(edge_costs, axis=1))\n        a, b = worst_edges, (worst_edges + 1) % n\n\n        # Find a better edge to replace it with\n        candidates = []\n        for i in range(n):\n            if i != a and i != b and i != (a-1) % n and i != (b+1) % n:\n                # Calculate the cost of the new edge\n                new_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(b+1)%n]]\n                old_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(b+1)%n]]\n                old_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n                new_cost3 = distance_matrix_3[new_solution[(a-1)%n], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(b+1)%n]]\n                old_cost3 = distance_matrix_3[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n\n                improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2) + (old_cost3 - new_cost3)\n                candidates.append((i, improvement))\n\n        if candidates:\n            best_candidate = max(candidates, key=lambda x: x[1])\n            if best_candidate[1] > 0:\n                i = best_candidate[0]\n                # Perform the edge swap\n                if i < a:\n                    new_solution[i:a] = new_solution[i:a][::-1]\n                else:\n                    new_solution[a:i] = new_solution[a:i][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 21,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (simplified metric)\n    def improvement_potential(solution, objectives):\n        # Combine objectives with weights (could be learned or fixed)\n        combined = 0.4 * objectives[0] + 0.3 * objectives[1] + 0.3 * objectives[2]\n        return 1 / (1 + combined)  # Higher for better solutions\n\n    potentials = [improvement_potential(sol, obj) for sol, obj in archive]\n    total = sum(potentials)\n    probabilities = [p/total for p in potentials]\n\n    # Select a solution with probability proportional to its potential\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # 1. 3-objective-aware edge swap\n    # Select two edges to swap with consideration for all three objectives\n    i = np.random.randint(0, n-1)\n    j = np.random.randint(i+1, n)\n\n    # Evaluate the swap in all three objectives\n    def evaluate_swap(i, j):\n        # Current edges: (i, i+1) and (j, j+1)\n        # Proposed edges: (i, j) and (i+1, j+1)\n        old_edges = [\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i], new_solution[j]),\n            (new_solution[(i+1)%n], new_solution[(j+1)%n])\n        ]\n\n        # Calculate change in all three objectives\n        delta1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        delta2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        delta3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        return delta1, delta2, delta3\n\n    delta1, delta2, delta3 = evaluate_swap(i, j)\n\n    # Accept the swap if it improves at least one objective\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        # Perform the swap\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # 2. Additional local search step: 2-opt with objective-aware selection\n    # Select two edges to swap with consideration for all three objectives\n    k = np.random.randint(0, n-1)\n    l = np.random.randint(k+1, n)\n\n    # Evaluate the 2-opt move\n    def evaluate_2opt(k, l):\n        # Current edges: (k, k+1) and (l, l+1)\n        # Proposed edges: (k, l) and (k+1, l+1)\n        old_edges = [\n            (new_solution[k], new_solution[(k+1)%n]),\n            (new_solution[l], new_solution[(l+1)%n])\n        ]\n        new_edges = [\n            (new_solution[k], new_solution[l]),\n            (new_solution[(k+1)%n], new_solution[(l+1)%n])\n        ]\n\n        # Calculate change in all three objectives\n        delta1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        delta2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        delta3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        return delta1, delta2, delta3\n\n    delta1_opt, delta2_opt, delta3_opt = evaluate_2opt(k, l)\n\n    # Accept the 2-opt move if it improves at least one objective\n    if delta1_opt < 0 or delta2_opt < 0 or delta3_opt < 0:\n        # Perform the 2-opt move\n        new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.79090696523424,
            1.317434048652649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (simplified metric)\n    def improvement_potential(solution, objectives):\n        # Combine objectives with weights (could be learned or fixed)\n        combined = 0.4 * objectives[0] + 0.3 * objectives[1] + 0.3 * objectives[2]\n        return 1 / (1 + combined)  # Higher for better solutions\n\n    potentials = [improvement_potential(sol, obj) for sol, obj in archive]\n    total = sum(potentials)\n    probabilities = [p/total for p in potentials]\n\n    # Select a solution with probability proportional to its potential\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # 1. 3-objective-aware edge swap\n    # Select two edges to swap with consideration for all three objectives\n    i = np.random.randint(0, n-1)\n    j = np.random.randint(i+1, n)\n\n    # Evaluate the swap in all three objectives\n    def evaluate_swap(i, j):\n        # Current edges: (i, i+1) and (j, j+1)\n        # Proposed edges: (i, j) and (i+1, j+1)\n        old_edges = [\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i], new_solution[j]),\n            (new_solution[(i+1)%n], new_solution[(j+1)%n])\n        ]\n\n        # Calculate change in all three objectives\n        delta1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        delta2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        delta3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        return delta1, delta2, delta3\n\n    delta1, delta2, delta3 = evaluate_swap(i, j)\n\n    # Accept the swap if it improves at least one objective\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        # Perform the swap\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # 2. Additional local search step: 2-opt with objective-aware selection\n    # Select two edges to swap with consideration for all three objectives\n    k = np.random.randint(0, n-1)\n    l = np.random.randint(k+1, n)\n\n    # Evaluate the 2-opt move\n    def evaluate_2opt(k, l):\n        # Current edges: (k, k+1) and (l, l+1)\n        # Proposed edges: (k, l) and (k+1, l+1)\n        old_edges = [\n            (new_solution[k], new_solution[(k+1)%n]),\n            (new_solution[l], new_solution[(l+1)%n])\n        ]\n        new_edges = [\n            (new_solution[k], new_solution[l]),\n            (new_solution[(k+1)%n], new_solution[(l+1)%n])\n        ]\n\n        # Calculate change in all three objectives\n        delta1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        delta2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        delta3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        return delta1, delta2, delta3\n\n    delta1_opt, delta2_opt, delta3_opt = evaluate_2opt(k, l)\n\n    # Accept the 2-opt move if it improves at least one objective\n    if delta1_opt < 0 or delta2_opt < 0 or delta3_opt < 0:\n        # Perform the 2-opt move\n        new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 22,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Apply a hybrid local search strategy combining 2-opt and 3-opt moves\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose between 2-opt and 3-opt move\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply 3-opt rearrangement (one of the possible 8 variants)\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:] if k+1 < n else np.array([], dtype=int)\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.790429980273377,
            0.9371118903160095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Apply a hybrid local search strategy combining 2-opt and 3-opt moves\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose between 2-opt and 3-opt move\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply 3-opt rearrangement (one of the possible 8 variants)\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:] if k+1 < n else np.array([], dtype=int)\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 50% solutions for further consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n        # Randomly select one solution from the top solutions\n        base_solution, _ = random.choice(top_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n = len(new_solution)\n    if n > 3:\n        # 1. Randomly select a segment of the tour\n        segment_start = random.randint(0, n - 4)\n        segment_length = random.randint(2, min(4, n - segment_start - 1))\n        segment_end = segment_start + segment_length\n\n        # 2. Apply 2-opt on the selected segment\n        i, j = sorted(random.sample(range(segment_start, segment_end), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # 3. Randomly swap two nodes to introduce diversity\n        if random.random() < 0.3:\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # 4. Apply a weighted edge swap based on the three objectives\n        if random.random() < 0.5:\n            # Calculate the current total distance for each objective\n            def calculate_total_distance(sol, dist_matrix):\n                total = 0\n                for i in range(len(sol)):\n                    total += dist_matrix[sol[i-1], sol[i]]\n                return total\n\n            current_dist1 = calculate_total_distance(new_solution, distance_matrix_1)\n            current_dist2 = calculate_total_distance(new_solution, distance_matrix_2)\n            current_dist3 = calculate_total_distance(new_solution, distance_matrix_3)\n\n            # Find the worst objective and try to improve it\n            worst_obj = max((current_dist1, 0), (current_dist2, 1), (current_dist3, 2), key=lambda x: x[0])\n            if worst_obj[1] == 0:\n                target_matrix = distance_matrix_1\n            elif worst_obj[1] == 1:\n                target_matrix = distance_matrix_2\n            else:\n                target_matrix = distance_matrix_3\n\n            # Find the best possible swap to improve the worst objective\n            best_improvement = 0\n            best_swap = None\n            for i in range(n):\n                for j in range(i+1, n):\n                    # Calculate the change in distance\n                    delta = (target_matrix[new_solution[i-1], new_solution[j]] +\n                             target_matrix[new_solution[j], new_solution[(i+1)%n]] +\n                             target_matrix[new_solution[j-1], new_solution[i]] +\n                             target_matrix[new_solution[i], new_solution[(j+1)%n]]) - \\\n                            (target_matrix[new_solution[i-1], new_solution[i]] +\n                             target_matrix[new_solution[i], new_solution[(i+1)%n]] +\n                             target_matrix[new_solution[j-1], new_solution[j]] +\n                             target_matrix[new_solution[j], new_solution[(j+1)%n]])\n\n                    if delta < best_improvement:\n                        best_improvement = delta\n                        best_swap = (i, j)\n\n            if best_swap is not None:\n                i, j = best_swap\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7195924181404117,
            1.7214508175849914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 50% solutions for further consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n        # Randomly select one solution from the top solutions\n        base_solution, _ = random.choice(top_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n = len(new_solution)\n    if n > 3:\n        # 1. Randomly select a segment of the tour\n        segment_start = random.randint(0, n - 4)\n        segment_length = random.randint(2, min(4, n - segment_start - 1))\n        segment_end = segment_start + segment_length\n\n        # 2. Apply 2-opt on the selected segment\n        i, j = sorted(random.sample(range(segment_start, segment_end), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # 3. Randomly swap two nodes to introduce diversity\n        if random.random() < 0.3:\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # 4. Apply a weighted edge swap based on the three objectives\n        if random.random() < 0.5:\n            # Calculate the current total distance for each objective\n            def calculate_total_distance(sol, dist_matrix):\n                total = 0\n                for i in range(len(sol)):\n                    total += dist_matrix[sol[i-1], sol[i]]\n                return total\n\n            current_dist1 = calculate_total_distance(new_solution, distance_matrix_1)\n            current_dist2 = calculate_total_distance(new_solution, distance_matrix_2)\n            current_dist3 = calculate_total_distance(new_solution, distance_matrix_3)\n\n            # Find the worst objective and try to improve it\n            worst_obj = max((current_dist1, 0), (current_dist2, 1), (current_dist3, 2), key=lambda x: x[0])\n            if worst_obj[1] == 0:\n                target_matrix = distance_matrix_1\n            elif worst_obj[1] == 1:\n                target_matrix = distance_matrix_2\n            else:\n                target_matrix = distance_matrix_3\n\n            # Find the best possible swap to improve the worst objective\n            best_improvement = 0\n            best_swap = None\n            for i in range(n):\n                for j in range(i+1, n):\n                    # Calculate the change in distance\n                    delta = (target_matrix[new_solution[i-1], new_solution[j]] +\n                             target_matrix[new_solution[j], new_solution[(i+1)%n]] +\n                             target_matrix[new_solution[j-1], new_solution[i]] +\n                             target_matrix[new_solution[i], new_solution[(j+1)%n]]) - \\\n                            (target_matrix[new_solution[i-1], new_solution[i]] +\n                             target_matrix[new_solution[i], new_solution[(i+1)%n]] +\n                             target_matrix[new_solution[j-1], new_solution[j]] +\n                             target_matrix[new_solution[j], new_solution[(j+1)%n]])\n\n                    if delta < best_improvement:\n                        best_improvement = delta\n                        best_swap = (i, j)\n\n            if best_swap is not None:\n                i, j = best_swap\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 24,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with probability inversely proportional to its objective values\n    # This encourages selecting solutions that are not yet well-optimized\n    objectives = [obj for _, obj in archive]\n    inv_objectives = [1.0 / (obj[0] + obj[1] + obj[2]) for obj in objectives]\n    total = sum(inv_objectives)\n    probabilities = [inv / total for inv in inv_objectives]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-way swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel 3-way swap that considers all three objectives\n    # Select three distinct positions and swap their positions in a way that minimizes the sum of edge changes\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Calculate the cost of the current edges\n    current_cost = (\n        distance_matrix_1[new_solution[a-1], new_solution[a]] +\n        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n        distance_matrix_1[new_solution[c-1], new_solution[c]] +\n        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n        distance_matrix_2[new_solution[c-1], new_solution[c]] +\n        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n        distance_matrix_3[new_solution[b-1], new_solution[b]] +\n        distance_matrix_3[new_solution[c-1], new_solution[c]]\n    )\n\n    # Try all possible permutations of the three nodes\n    permutations = [\n        (a, b, c),\n        (a, c, b),\n        (b, a, c),\n        (b, c, a),\n        (c, a, b),\n        (c, b, a)\n    ]\n\n    best_permutation = (a, b, c)\n    best_cost = current_cost\n\n    for perm in permutations:\n        # Create a temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[perm[0]], temp_solution[perm[1]], temp_solution[perm[2]] = (\n            new_solution[a], new_solution[b], new_solution[c]\n        )\n\n        # Calculate the new cost\n        new_cost = (\n            distance_matrix_1[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_1[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_1[temp_solution[perm[2]-1], temp_solution[perm[2]]] +\n            distance_matrix_2[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_2[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_2[temp_solution[perm[2]-1], temp_solution[perm[2]]] +\n            distance_matrix_3[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_3[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_3[temp_solution[perm[2]-1], temp_solution[perm[2]]]\n        )\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_permutation = perm\n\n    # Apply the best permutation\n    new_solution[best_permutation[0]], new_solution[best_permutation[1]], new_solution[best_permutation[2]] = (\n        new_solution[a], new_solution[b], new_solution[c]\n    )\n\n    return new_solution\n\n",
        "score": [
            -0.8215333520934566,
            1.3360180258750916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with probability inversely proportional to its objective values\n    # This encourages selecting solutions that are not yet well-optimized\n    objectives = [obj for _, obj in archive]\n    inv_objectives = [1.0 / (obj[0] + obj[1] + obj[2]) for obj in objectives]\n    total = sum(inv_objectives)\n    probabilities = [inv / total for inv in inv_objectives]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-way swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel 3-way swap that considers all three objectives\n    # Select three distinct positions and swap their positions in a way that minimizes the sum of edge changes\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Calculate the cost of the current edges\n    current_cost = (\n        distance_matrix_1[new_solution[a-1], new_solution[a]] +\n        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n        distance_matrix_1[new_solution[c-1], new_solution[c]] +\n        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n        distance_matrix_2[new_solution[c-1], new_solution[c]] +\n        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n        distance_matrix_3[new_solution[b-1], new_solution[b]] +\n        distance_matrix_3[new_solution[c-1], new_solution[c]]\n    )\n\n    # Try all possible permutations of the three nodes\n    permutations = [\n        (a, b, c),\n        (a, c, b),\n        (b, a, c),\n        (b, c, a),\n        (c, a, b),\n        (c, b, a)\n    ]\n\n    best_permutation = (a, b, c)\n    best_cost = current_cost\n\n    for perm in permutations:\n        # Create a temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[perm[0]], temp_solution[perm[1]], temp_solution[perm[2]] = (\n            new_solution[a], new_solution[b], new_solution[c]\n        )\n\n        # Calculate the new cost\n        new_cost = (\n            distance_matrix_1[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_1[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_1[temp_solution[perm[2]-1], temp_solution[perm[2]]] +\n            distance_matrix_2[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_2[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_2[temp_solution[perm[2]-1], temp_solution[perm[2]]] +\n            distance_matrix_3[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_3[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_3[temp_solution[perm[2]-1], temp_solution[perm[2]]]\n        )\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_permutation = perm\n\n    # Apply the best permutation\n    new_solution[best_permutation[0]], new_solution[best_permutation[1]], new_solution[best_permutation[2]] = (\n        new_solution[a], new_solution[b], new_solution[c]\n    )\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 24,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with probability inversely proportional to its objective values\n    # This encourages selecting solutions that are not yet well-optimized\n    objectives = [obj for _, obj in archive]\n    inv_objectives = [1.0 / (obj[0] + obj[1] + obj[2]) for obj in objectives]\n    total = sum(inv_objectives)\n    probabilities = [inv / total for inv in inv_objectives]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-way swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel 3-way swap that considers all three objectives\n    # Select three distinct positions and swap their positions in a way that minimizes the sum of edge changes\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Calculate the cost of the current edges\n    current_cost = (\n        distance_matrix_1[new_solution[a-1], new_solution[a]] +\n        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n        distance_matrix_1[new_solution[c-1], new_solution[c]] +\n        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n        distance_matrix_2[new_solution[c-1], new_solution[c]] +\n        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n        distance_matrix_3[new_solution[b-1], new_solution[b]] +\n        distance_matrix_3[new_solution[c-1], new_solution[c]]\n    )\n\n    # Try all possible permutations of the three nodes\n    permutations = [\n        (a, b, c),\n        (a, c, b),\n        (b, a, c),\n        (b, c, a),\n        (c, a, b),\n        (c, b, a)\n    ]\n\n    best_permutation = (a, b, c)\n    best_cost = current_cost\n\n    for perm in permutations:\n        # Create a temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[perm[0]], temp_solution[perm[1]], temp_solution[perm[2]] = (\n            new_solution[a], new_solution[b], new_solution[c]\n        )\n\n        # Calculate the new cost\n        new_cost = (\n            distance_matrix_1[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_1[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_1[temp_solution[perm[2]-1], temp_solution[perm[2]]] +\n            distance_matrix_2[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_2[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_2[temp_solution[perm[2]-1], temp_solution[perm[2]]] +\n            distance_matrix_3[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_3[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_3[temp_solution[perm[2]-1], temp_solution[perm[2]]]\n        )\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_permutation = perm\n\n    # Apply the best permutation\n    new_solution[best_permutation[0]], new_solution[best_permutation[1]], new_solution[best_permutation[2]] = (\n        new_solution[a], new_solution[b], new_solution[c]\n    )\n\n    return new_solution\n\n",
        "score": [
            -0.8215333520934566,
            1.3360180258750916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with probability inversely proportional to its objective values\n    # This encourages selecting solutions that are not yet well-optimized\n    objectives = [obj for _, obj in archive]\n    inv_objectives = [1.0 / (obj[0] + obj[1] + obj[2]) for obj in objectives]\n    total = sum(inv_objectives)\n    probabilities = [inv / total for inv in inv_objectives]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-way swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel 3-way swap that considers all three objectives\n    # Select three distinct positions and swap their positions in a way that minimizes the sum of edge changes\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Calculate the cost of the current edges\n    current_cost = (\n        distance_matrix_1[new_solution[a-1], new_solution[a]] +\n        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n        distance_matrix_1[new_solution[c-1], new_solution[c]] +\n        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n        distance_matrix_2[new_solution[c-1], new_solution[c]] +\n        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n        distance_matrix_3[new_solution[b-1], new_solution[b]] +\n        distance_matrix_3[new_solution[c-1], new_solution[c]]\n    )\n\n    # Try all possible permutations of the three nodes\n    permutations = [\n        (a, b, c),\n        (a, c, b),\n        (b, a, c),\n        (b, c, a),\n        (c, a, b),\n        (c, b, a)\n    ]\n\n    best_permutation = (a, b, c)\n    best_cost = current_cost\n\n    for perm in permutations:\n        # Create a temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[perm[0]], temp_solution[perm[1]], temp_solution[perm[2]] = (\n            new_solution[a], new_solution[b], new_solution[c]\n        )\n\n        # Calculate the new cost\n        new_cost = (\n            distance_matrix_1[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_1[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_1[temp_solution[perm[2]-1], temp_solution[perm[2]]] +\n            distance_matrix_2[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_2[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_2[temp_solution[perm[2]-1], temp_solution[perm[2]]] +\n            distance_matrix_3[temp_solution[perm[0]-1], temp_solution[perm[0]]] +\n            distance_matrix_3[temp_solution[perm[1]-1], temp_solution[perm[1]]] +\n            distance_matrix_3[temp_solution[perm[2]-1], temp_solution[perm[2]]]\n        )\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_permutation = perm\n\n    # Apply the best permutation\n    new_solution[best_permutation[0]], new_solution[best_permutation[1]], new_solution[best_permutation[2]] = (\n        new_solution[a], new_solution[b], new_solution[c]\n    )\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 25,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good in all objectives)\n    selected_solution = None\n    for sol, obj in archive:\n        if selected_solution is None or (obj[0] < selected_solution[1][0] and obj[1] < selected_solution[1][1] and obj[2] < selected_solution[1][2]):\n            selected_solution = (sol, obj)\n\n    if selected_solution is None:\n        selected_solution = archive[0]\n\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply 2-opt on the worst objective\n        worst_obj = np.argmax(selected_solution[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the current solution\n        worst_edge = None\n        max_cost = -1\n        for i in range(n):\n            u = base_solution[i]\n            v = base_solution[(i+1)%n]\n            cost = dist_matrix[u, v]\n            if cost > max_cost:\n                max_cost = cost\n                worst_edge = (i, (i+1)%n)\n\n        if worst_edge:\n            i, j = worst_edge\n            # Perform 2-opt on this edge\n            new_solution = new_solution.copy()\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply node insertion to improve other objectives\n        for _ in range(2):  # Try a few insertions\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7056445908569777,
            1.021832275390625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good in all objectives)\n    selected_solution = None\n    for sol, obj in archive:\n        if selected_solution is None or (obj[0] < selected_solution[1][0] and obj[1] < selected_solution[1][1] and obj[2] < selected_solution[1][2]):\n            selected_solution = (sol, obj)\n\n    if selected_solution is None:\n        selected_solution = archive[0]\n\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply 2-opt on the worst objective\n        worst_obj = np.argmax(selected_solution[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the current solution\n        worst_edge = None\n        max_cost = -1\n        for i in range(n):\n            u = base_solution[i]\n            v = base_solution[(i+1)%n]\n            cost = dist_matrix[u, v]\n            if cost > max_cost:\n                max_cost = cost\n                worst_edge = (i, (i+1)%n)\n\n        if worst_edge:\n            i, j = worst_edge\n            # Perform 2-opt on this edge\n            new_solution = new_solution.copy()\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply node insertion to improve other objectives\n        for _ in range(2):  # Try a few insertions\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 26,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with good diversity or high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-opt-like move\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # First apply a 2-opt move (standard local search)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then apply a novel 3-opt-like move to optimize across multiple objectives\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create three possible 3-opt-like moves and select the best one based on objective improvement\n    moves = [\n        np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[c:b:-1], new_solution[a:b], new_solution[c:]])\n    ]\n\n    # Evaluate each move based on the sum of normalized improvements across all objectives\n    best_move = new_solution\n    best_score = float('inf')\n\n    for move in moves:\n        # Calculate total cost for each objective\n        cost1 = sum(distance_matrix_1[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_1[move[-1], move[0]]\n        cost2 = sum(distance_matrix_2[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_2[move[-1], move[0]]\n        cost3 = sum(distance_matrix_3[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_3[move[-1], move[0]]\n\n        # Normalize and combine scores\n        current_costs = np.array([cost1, cost2, cost3])\n        original_costs = np.array(archive[selected_idx][1])\n        score = np.sum((current_costs - original_costs) / (original_costs + 1e-6))  # Avoid division by zero\n\n        if score < best_score:\n            best_score = score\n            best_move = move\n\n    return best_move\n\n",
        "score": [
            -0.7800699759260509,
            0.9729206681251525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with good diversity or high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-opt-like move\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # First apply a 2-opt move (standard local search)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then apply a novel 3-opt-like move to optimize across multiple objectives\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Create three possible 3-opt-like moves and select the best one based on objective improvement\n    moves = [\n        np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[c:b:-1], new_solution[a:b], new_solution[c:]])\n    ]\n\n    # Evaluate each move based on the sum of normalized improvements across all objectives\n    best_move = new_solution\n    best_score = float('inf')\n\n    for move in moves:\n        # Calculate total cost for each objective\n        cost1 = sum(distance_matrix_1[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_1[move[-1], move[0]]\n        cost2 = sum(distance_matrix_2[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_2[move[-1], move[0]]\n        cost3 = sum(distance_matrix_3[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_3[move[-1], move[0]]\n\n        # Normalize and combine scores\n        current_costs = np.array([cost1, cost2, cost3])\n        original_costs = np.array(archive[selected_idx][1])\n        score = np.sum((current_costs - original_costs) / (original_costs + 1e-6))  # Avoid division by zero\n\n        if score < best_score:\n            best_score = score\n            best_move = move\n\n    return best_move\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 27,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives (promising for improvement)\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Sort solutions by objective diversity (higher diversity first)\n    sorted_indices = sorted(range(len(archive)), key=objective_diversity, reverse=True)\n    selected_idx = sorted_indices[0] if len(sorted_indices) > 0 else 0\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(2):  # Perform multiple iterations\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective aware edge swap\n        if random.random() < 0.3:  # 30% chance for edge swap\n            k = random.randint(0, n-1)\n            if k != i and k != j:\n                # Calculate edge improvements across all objectives\n                delta1 = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                          distance_matrix_1[new_solution[k], new_solution[j]] -\n                          distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                          distance_matrix_2[new_solution[k], new_solution[j]] -\n                          distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                delta3 = (distance_matrix_3[new_solution[i-1], new_solution[k]] +\n                          distance_matrix_3[new_solution[k], new_solution[j]] -\n                          distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                # Accept if improvement in at least two objectives\n                if (delta1 < 0 and delta2 < 0) or (delta2 < 0 and delta3 < 0) or (delta1 < 0 and delta3 < 0):\n                    temp = new_solution[i]\n                    new_solution[i] = new_solution[k]\n                    new_solution[k] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.46698882516632184,
            1.0209179043769836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives (promising for improvement)\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Sort solutions by objective diversity (higher diversity first)\n    sorted_indices = sorted(range(len(archive)), key=objective_diversity, reverse=True)\n    selected_idx = sorted_indices[0] if len(sorted_indices) > 0 else 0\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(2):  # Perform multiple iterations\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective aware edge swap\n        if random.random() < 0.3:  # 30% chance for edge swap\n            k = random.randint(0, n-1)\n            if k != i and k != j:\n                # Calculate edge improvements across all objectives\n                delta1 = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                          distance_matrix_1[new_solution[k], new_solution[j]] -\n                          distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                          distance_matrix_2[new_solution[k], new_solution[j]] -\n                          distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                delta3 = (distance_matrix_3[new_solution[i-1], new_solution[k]] +\n                          distance_matrix_3[new_solution[k], new_solution[j]] -\n                          distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                # Accept if improvement in at least two objectives\n                if (delta1 < 0 and delta2 < 0) or (delta2 < 0 and delta3 < 0) or (delta1 < 0 and delta3 < 0):\n                    temp = new_solution[i]\n                    new_solution[i] = new_solution[k]\n                    new_solution[k] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 28,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    candidate_indices = []\n    for i, (sol, obj) in enumerate(archive):\n        # Check if the solution is not optimal in all objectives (can be improved)\n        if not all(obj[j] <= min(archive[k][1][j] for k in range(len(archive))) for j in range(3)):\n            candidate_indices.append(i)\n\n    if not candidate_indices:\n        # If all solutions are optimal in at least one objective, select the most diverse one\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and objective-aware swaps\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly choose a segment to modify\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Objective-aware segment reversal (for multi-objective optimization)\n        # Calculate the improvement in each objective for the reversed segment\n        original_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n        reversed_segment = segment[::-1]\n        reversed_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Objective-aware swap based on the most critical objective\n        # Identify the most critical objective (the one with the highest improvement potential)\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        critical_obj = np.argmax([obj1, obj2, obj3])\n        distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][critical_obj]\n\n        # Perform a swap that improves the critical objective\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in cost for the critical objective\n        delta = (distance_matrix[new_solution[i-1], new_solution[j]] +\n                 distance_matrix[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix[new_solution[i-1], new_solution[i]] +\n                 distance_matrix[new_solution[j], new_solution[(j+1)%n]]) - \\\n                (distance_matrix[new_solution[i-1], new_solution[i]] +\n                 distance_matrix[new_solution[i], new_solution[(i+1)%n]] +\n                 distance_matrix[new_solution[j-1], new_solution[j]] +\n                 distance_matrix[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta < 0:\n            # Perform the swap if it improves the critical objective\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7034707826403123,
            2.9912221908569334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    candidate_indices = []\n    for i, (sol, obj) in enumerate(archive):\n        # Check if the solution is not optimal in all objectives (can be improved)\n        if not all(obj[j] <= min(archive[k][1][j] for k in range(len(archive))) for j in range(3)):\n            candidate_indices.append(i)\n\n    if not candidate_indices:\n        # If all solutions are optimal in at least one objective, select the most diverse one\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and objective-aware swaps\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly choose a segment to modify\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Objective-aware segment reversal (for multi-objective optimization)\n        # Calculate the improvement in each objective for the reversed segment\n        original_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n        reversed_segment = segment[::-1]\n        reversed_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n        # Objective-aware swap based on the most critical objective\n        # Identify the most critical objective (the one with the highest improvement potential)\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        critical_obj = np.argmax([obj1, obj2, obj3])\n        distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][critical_obj]\n\n        # Perform a swap that improves the critical objective\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in cost for the critical objective\n        delta = (distance_matrix[new_solution[i-1], new_solution[j]] +\n                 distance_matrix[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix[new_solution[i-1], new_solution[i]] +\n                 distance_matrix[new_solution[j], new_solution[(j+1)%n]]) - \\\n                (distance_matrix[new_solution[i-1], new_solution[i]] +\n                 distance_matrix[new_solution[i], new_solution[(i+1)%n]] +\n                 distance_matrix[new_solution[j-1], new_solution[j]] +\n                 distance_matrix[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta < 0:\n            # Perform the swap if it improves the critical objective\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability for those with better diversity or lower objectives\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive],\n        k=1\n    )[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n\n    # Reverse the segment (2-opt)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # With some probability, apply a 3-opt move to further improve\n    if random.random() < 0.3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7503650695197907,
            0.9274476408958435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability for those with better diversity or lower objectives\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive],\n        k=1\n    )[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n\n    # Reverse the segment (2-opt)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # With some probability, apply a 3-opt move to further improve\n    if random.random() < 0.3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 30,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability proportional to its potential for improvement\n    total_potential = sum(1 / (obj[0] + obj[1] + obj[2] + 1e-10) for _, obj in archive)\n    selection_probabilities = [(1 / (obj[0] + obj[1] + obj[2] + 1e-10)) / total_potential for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=selection_probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform node insertion\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7863215009422622,
            1.5174029350280762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability proportional to its potential for improvement\n    total_potential = sum(1 / (obj[0] + obj[1] + obj[2] + 1e-10) for _, obj in archive)\n    selection_probabilities = [(1 / (obj[0] + obj[1] + obj[2] + 1e-10)) / total_potential for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=selection_probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform node insertion\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 31,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt move if it improves the total cost in any objective\n    def calculate_total_cost(solution):\n        total_cost = 0\n        for m in range(n):\n            total_cost += distance_matrix_1[solution[m], solution[(m+1)%n]] + \\\n                          distance_matrix_2[solution[m], solution[(m+1)%n]] + \\\n                          distance_matrix_3[solution[m], solution[(m+1)%n]]\n        return total_cost\n\n    original_cost = calculate_total_cost(new_solution)\n\n    # Try swapping edges\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n    temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n\n    new_cost = calculate_total_cost(temp_solution)\n\n    if new_cost < original_cost:\n        new_solution = temp_solution\n    else:\n        # If no improvement, try a different operator: reverse a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.6122787801266099,
            1.293172287940979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt move if it improves the total cost in any objective\n    def calculate_total_cost(solution):\n        total_cost = 0\n        for m in range(n):\n            total_cost += distance_matrix_1[solution[m], solution[(m+1)%n]] + \\\n                          distance_matrix_2[solution[m], solution[(m+1)%n]] + \\\n                          distance_matrix_3[solution[m], solution[(m+1)%n]]\n        return total_cost\n\n    original_cost = calculate_total_cost(new_solution)\n\n    # Try swapping edges\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n    temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n\n    new_cost = calculate_total_cost(temp_solution)\n\n    if new_cost < original_cost:\n        new_solution = temp_solution\n    else:\n        # If no improvement, try a different operator: reverse a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives for better exploration\n    objectives = [obj for _, obj in archive]\n    objective_variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(objective_variance)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and insertion\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation steps\n        # Select two distinct random positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # 2-opt swap with probability 0.7, otherwise insertion\n        if np.random.random() < 0.7:\n            # 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Insertion move\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure solution remains valid (no duplicates and all nodes present)\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to base solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6310565085181918,
            1.8574020862579346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives for better exploration\n    objectives = [obj for _, obj in archive]\n    objective_variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(objective_variance)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and insertion\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation steps\n        # Select two distinct random positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # 2-opt swap with probability 0.7, otherwise insertion\n        if np.random.random() < 0.7:\n            # 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Insertion move\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure solution remains valid (no duplicates and all nodes present)\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to base solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 33,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the variance of objectives for each solution\n        objectives = np.array([obj for (sol, obj) in archive])\n        variances = np.var(objectives, axis=0)\n        total_variances = np.sum(variances, axis=0)\n\n        # Select solutions with high variance (promising for improvement)\n        candidate_indices = [i for i, (sol, obj) in enumerate(archive) if np.sum((obj - np.mean(objectives, axis=0)) ** 2) > total_variances / 2]\n        if candidate_indices:\n            selected_idx = random.choice(candidate_indices)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # 2-opt local search (standard for TSP)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that are far apart in at least one objective space\n    if n > 2:\n        k, l = sorted(random.sample(range(n), 2))\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate distances in all three objective spaces\n        dist1 = distance_matrix_1[node_k, node_l]\n        dist2 = distance_matrix_2[node_k, node_l]\n        dist3 = distance_matrix_3[node_k, node_l]\n\n        # Swap if the nodes are far apart in at least one objective space\n        if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2) or dist3 > np.mean(distance_matrix_3):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7711228973437378,
            3.922969567775726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the variance of objectives for each solution\n        objectives = np.array([obj for (sol, obj) in archive])\n        variances = np.var(objectives, axis=0)\n        total_variances = np.sum(variances, axis=0)\n\n        # Select solutions with high variance (promising for improvement)\n        candidate_indices = [i for i, (sol, obj) in enumerate(archive) if np.sum((obj - np.mean(objectives, axis=0)) ** 2) > total_variances / 2]\n        if candidate_indices:\n            selected_idx = random.choice(candidate_indices)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # 2-opt local search (standard for TSP)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that are far apart in at least one objective space\n    if n > 2:\n        k, l = sorted(random.sample(range(n), 2))\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate distances in all three objective spaces\n        dist1 = distance_matrix_1[node_k, node_l]\n        dist2 = distance_matrix_2[node_k, node_l]\n        dist3 = distance_matrix_3[node_k, node_l]\n\n        # Swap if the nodes are far apart in at least one objective space\n        if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2) or dist3 > np.mean(distance_matrix_3):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 34,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and low objective values\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, selected_objectives = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Choose between 2-opt or random segment reversal based on a probability\n    if np.random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Random segment reversal\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by restoring the original segment\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8180723899853419,
            0.8483848810195923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and low objective values\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, selected_objectives = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Choose between 2-opt or random segment reversal based on a probability\n    if np.random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Random segment reversal\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by restoring the original segment\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 35,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with higher variance in objectives, indicating room for trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weights = objective_variance / np.sum(objective_variance)  # Normalize to sum to 1\n\n    # Calculate a score for each solution based on its potential for improvement\n    scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Score is a weighted sum of the objectives (higher is worse for minimization)\n        score = np.dot(obj, weights)\n        scores.append(score)\n\n    # Select the solution with the highest score (most potential for improvement)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to modify\n    segment_length = np.random.randint(2, min(5, n//2 + 1))\n    start = np.random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start:start+segment_length]\n\n    # Choose a different segment to swap with\n    swap_start = np.random.randint(0, n - segment_length)\n    while swap_start == start:  # Ensure different segments\n        swap_start = np.random.randint(0, n - segment_length)\n\n    # Swap the segments\n    new_solution[start:start+segment_length] = new_solution[swap_start:swap_start+segment_length]\n    new_solution[swap_start:swap_start+segment_length] = segment\n\n    # Verify the solution is still valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    # Apply a 2-opt move for one of the objectives\n    if np.random.random() < 0.5:  # 50% chance to apply 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6858712401882702,
            1.0554973006248474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with higher variance in objectives, indicating room for trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weights = objective_variance / np.sum(objective_variance)  # Normalize to sum to 1\n\n    # Calculate a score for each solution based on its potential for improvement\n    scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Score is a weighted sum of the objectives (higher is worse for minimization)\n        score = np.dot(obj, weights)\n        scores.append(score)\n\n    # Select the solution with the highest score (most potential for improvement)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to modify\n    segment_length = np.random.randint(2, min(5, n//2 + 1))\n    start = np.random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start:start+segment_length]\n\n    # Choose a different segment to swap with\n    swap_start = np.random.randint(0, n - segment_length)\n    while swap_start == start:  # Ensure different segments\n        swap_start = np.random.randint(0, n - segment_length)\n\n    # Swap the segments\n    new_solution[start:start+segment_length] = new_solution[swap_start:swap_start+segment_length]\n    new_solution[swap_start:swap_start+segment_length] = segment\n\n    # Verify the solution is still valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    # Apply a 2-opt move for one of the objectives\n    if np.random.random() < 0.5:  # 50% chance to apply 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 36,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Select a solution that is not the best or worst in any objective\n        objectives = [obj for _, obj in archive]\n        avg_objectives = np.mean(objectives, axis=0)\n        candidate_scores = []\n        for i, obj in enumerate(objectives):\n            # Score is the sum of normalized deviations from average objectives\n            score = sum((o - avg) / (avg + 1e-6) for o, avg in zip(obj, avg_objectives))\n            candidate_scores.append(score)\n        # Select the candidate with the highest score (most potential for improvement)\n        selected_idx = np.argmax(candidate_scores)\n        base_solution = candidates[selected_idx].copy()\n    else:\n        base_solution = candidates[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly choose between 2-opt or segment inversion\n    if np.random.rand() < 0.5:\n        # 2-opt: Select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion: Reverse a random segment of the tour\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    # Optional: Apply a small perturbation to escape local optima\n    if np.random.rand() < 0.2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6825210798674675,
            1.5299288153648376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Select a solution that is not the best or worst in any objective\n        objectives = [obj for _, obj in archive]\n        avg_objectives = np.mean(objectives, axis=0)\n        candidate_scores = []\n        for i, obj in enumerate(objectives):\n            # Score is the sum of normalized deviations from average objectives\n            score = sum((o - avg) / (avg + 1e-6) for o, avg in zip(obj, avg_objectives))\n            candidate_scores.append(score)\n        # Select the candidate with the highest score (most potential for improvement)\n        selected_idx = np.argmax(candidate_scores)\n        base_solution = candidates[selected_idx].copy()\n    else:\n        base_solution = candidates[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly choose between 2-opt or segment inversion\n    if np.random.rand() < 0.5:\n        # 2-opt: Select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion: Reverse a random segment of the tour\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    # Optional: Apply a small perturbation to escape local optima\n    if np.random.rand() < 0.2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 37,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variances, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate the current objective values\n    def calculate_objective(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Find the worst objective and try to improve it\n    worst_obj_idx = np.argmax(current_obj)\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best possible swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for a in range(n):\n        for b in range(a+1, n):\n            # Calculate the change in distance for the worst objective\n            old_dist = (distance_matrix[new_solution[a], new_solution[(a+1)%n]] +\n                        distance_matrix[new_solution[b], new_solution[(b+1)%n]])\n            new_dist = (distance_matrix[new_solution[a], new_solution[b]] +\n                        distance_matrix[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n            improvement = old_dist - new_dist\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6331752981438139,
            2.3005893349647524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variances, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate the current objective values\n    def calculate_objective(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Find the worst objective and try to improve it\n    worst_obj_idx = np.argmax(current_obj)\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best possible swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for a in range(n):\n        for b in range(a+1, n):\n            # Calculate the change in distance for the worst objective\n            old_dist = (distance_matrix[new_solution[a], new_solution[(a+1)%n]] +\n                        distance_matrix[new_solution[b], new_solution[(b+1)%n]])\n            new_dist = (distance_matrix[new_solution[a], new_solution[b]] +\n                        distance_matrix[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n            improvement = old_dist - new_dist\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 38,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap if it improves at least one objective\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Calculate new objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n            return (cost1, cost2, cost3)\n\n        original_obj = calculate_objective(new_solution)\n        temp_obj = calculate_objective(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(temp < orig for temp, orig in zip(temp_obj, original_obj)):\n            new_solution = temp_solution\n\n        # Objective-aware edge swap\n        if i != k and j != l:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n            temp_solution[j], temp_solution[l] = temp_solution[l], temp_solution[j]\n\n            temp_obj = calculate_objective(temp_solution)\n            if any(temp < orig for temp, orig in zip(temp_obj, original_obj)):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7874761179069371,
            4.147060358524323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap if it improves at least one objective\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Calculate new objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n            return (cost1, cost2, cost3)\n\n        original_obj = calculate_objective(new_solution)\n        temp_obj = calculate_objective(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(temp < orig for temp, orig in zip(temp_obj, original_obj)):\n            new_solution = temp_solution\n\n        # Objective-aware edge swap\n        if i != k and j != l:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n            temp_solution[j], temp_solution[l] = temp_solution[l], temp_solution[j]\n\n            temp_obj = calculate_objective(temp_solution)\n            if any(temp < orig for temp, orig in zip(temp_obj, original_obj)):\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 39,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for improvement\n        obj_values = archive[selected_idx][1]\n        obj_weights = [1.0 / (val + 1e-6) for val in obj_values]  # Inverse of objective values\n        total_weight = sum(obj_weights)\n        probabilities = [w / total_weight for w in obj_weights]\n\n        # Choose the objective space to focus on\n        chosen_obj = random.choices([0, 1, 2], weights=probabilities, k=1)[0]\n\n        # Perform objective-aware local search\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # Select two edges to reverse\n            i, j = sorted(random.sample(range(n), 2))\n            # Check if reversing this segment improves the chosen objective\n            current_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] +\n                           distance_matrix_3[base_solution[(i+j)//2-1], base_solution[(i+j)//2]])\n            new_cost = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                        distance_matrix_2[base_solution[j-1], base_solution[i]] +\n                        distance_matrix_3[base_solution[(i+j)//2-1], base_solution[(i+j)//2]])\n\n            if new_cost < current_cost * 1.1:  # Allow slight degradation for diversity\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:  # 3-opt for more complex improvements\n            # Select three edges to reconnect\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Check if this 3-opt improves any objective\n            current_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] +\n                           distance_matrix_3[base_solution[k-1], base_solution[k]])\n            # There are 8 possible ways to reconnect the three segments\n            # We'll try the one that most improves the chosen objective\n            best_new_solution = new_solution.copy()\n            best_improvement = 0\n\n            for reconnect in range(8):\n                temp_solution = new_solution.copy()\n                if reconnect == 0:\n                    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                elif reconnect == 1:\n                    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n                elif reconnect == 2:\n                    temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n                elif reconnect == 3:\n                    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n                elif reconnect == 4:\n                    temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n                    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                elif reconnect == 5:\n                    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n                    temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n                elif reconnect == 6:\n                    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                    temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n                elif reconnect == 7:\n                    temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n                    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n\n                new_cost = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                           distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                           distance_matrix_3[temp_solution[k-1], temp_solution[k]])\n\n                improvement = current_cost - new_cost\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_new_solution = temp_solution.copy()\n\n            new_solution = best_new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7338098287421775,
            0.9748579025268554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for improvement\n        obj_values = archive[selected_idx][1]\n        obj_weights = [1.0 / (val + 1e-6) for val in obj_values]  # Inverse of objective values\n        total_weight = sum(obj_weights)\n        probabilities = [w / total_weight for w in obj_weights]\n\n        # Choose the objective space to focus on\n        chosen_obj = random.choices([0, 1, 2], weights=probabilities, k=1)[0]\n\n        # Perform objective-aware local search\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # Select two edges to reverse\n            i, j = sorted(random.sample(range(n), 2))\n            # Check if reversing this segment improves the chosen objective\n            current_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] +\n                           distance_matrix_3[base_solution[(i+j)//2-1], base_solution[(i+j)//2]])\n            new_cost = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                        distance_matrix_2[base_solution[j-1], base_solution[i]] +\n                        distance_matrix_3[base_solution[(i+j)//2-1], base_solution[(i+j)//2]])\n\n            if new_cost < current_cost * 1.1:  # Allow slight degradation for diversity\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:  # 3-opt for more complex improvements\n            # Select three edges to reconnect\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Check if this 3-opt improves any objective\n            current_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] +\n                           distance_matrix_3[base_solution[k-1], base_solution[k]])\n            # There are 8 possible ways to reconnect the three segments\n            # We'll try the one that most improves the chosen objective\n            best_new_solution = new_solution.copy()\n            best_improvement = 0\n\n            for reconnect in range(8):\n                temp_solution = new_solution.copy()\n                if reconnect == 0:\n                    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                elif reconnect == 1:\n                    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n                elif reconnect == 2:\n                    temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n                elif reconnect == 3:\n                    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n                elif reconnect == 4:\n                    temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n                    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                elif reconnect == 5:\n                    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n                    temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n                elif reconnect == 6:\n                    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                    temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n                elif reconnect == 7:\n                    temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n                    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n\n                new_cost = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                           distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                           distance_matrix_3[temp_solution[k-1], temp_solution[k]])\n\n                improvement = current_cost - new_cost\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_new_solution = temp_solution.copy()\n\n            new_solution = best_new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 40,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt move)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Apply 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware refinement: check if the move improves at least one objective\n    old_costs = (\n        sum(distance_matrix_1[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n    )\n\n    new_costs = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    # If the move doesn't improve any objective, try a different approach\n    if all(new_cost >= old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n        # Try a 3-opt move (more disruptive but potentially better)\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5682780706158541,
            0.8886906266212463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt move)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Apply 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware refinement: check if the move improves at least one objective\n    old_costs = (\n        sum(distance_matrix_1[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n    )\n\n    new_costs = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    # If the move doesn't improve any objective, try a different approach\n    if all(new_cost >= old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n        # Try a 3-opt move (more disruptive but potentially better)\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 41,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct edges to swap (2-opt)\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform the swap if it improves at least one objective\n        old_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = (\n            new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n        )\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        if all(new_cost <= old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n            break  # Accept if strictly better in all objectives\n        else:\n            # Revert if not better\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = (\n                new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n            )\n\n    # If no improvement, try a different operator: objective-aware 2-opt\n    if new_solution.tolist() == base_solution.tolist():\n        # Select the objective with the highest cost\n        worst_obj = np.argmax(base_objective)\n        distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj]\n\n        # Find the worst edge in the selected objective\n        max_cost = -1\n        worst_edge = (0, 1)\n        for i in range(n):\n            cost = distance_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if cost > max_cost:\n                max_cost = cost\n                worst_edge = (i, (i+1)%n)\n\n        # Try to improve by reversing the path between worst edges\n        a, b = worst_edge\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7330596368870262,
            0.7474211692810059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct edges to swap (2-opt)\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform the swap if it improves at least one objective\n        old_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = (\n            new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n        )\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        if all(new_cost <= old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n            break  # Accept if strictly better in all objectives\n        else:\n            # Revert if not better\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = (\n                new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n            )\n\n    # If no improvement, try a different operator: objective-aware 2-opt\n    if new_solution.tolist() == base_solution.tolist():\n        # Select the objective with the highest cost\n        worst_obj = np.argmax(base_objective)\n        distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj]\n\n        # Find the worst edge in the selected objective\n        max_cost = -1\n        worst_edge = (0, 1)\n        for i in range(n):\n            cost = distance_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if cost > max_cost:\n                max_cost = cost\n                worst_edge = (i, (i+1)%n)\n\n        # Try to improve by reversing the path between worst edges\n        a, b = worst_edge\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 42,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and node insertion\n    N = len(base_solution)\n    i, j = np.random.randint(0, N, size=2)\n    k = np.random.randint(0, N)\n\n    # Apply 2-opt move (swap edges)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Apply node insertion (move a node to another position)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != N or len(new_solution) != N:\n        # Fallback to 2-opt if insertion causes issues\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7029760226965734,
            0.8572953224182129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and node insertion\n    N = len(base_solution)\n    i, j = np.random.randint(0, N, size=2)\n    k = np.random.randint(0, N)\n\n    # Apply 2-opt move (swap edges)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Apply node insertion (move a node to another position)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != N or len(new_solution) != N:\n        # Fallback to 2-opt if insertion causes issues\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 43,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt, edge insertion, and objective-aware swaps\n    n = len(new_solution)\n\n    # 1. 2-opt local search (for one objective)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Edge insertion (for another objective)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # 3. Objective-aware swap (for the third objective)\n    # Identify the objective with the highest improvement potential\n    obj1 = archive[selected_idx][1][0]\n    obj2 = archive[selected_idx][1][1]\n    obj3 = archive[selected_idx][1][2]\n\n    # Calculate potential improvement for each objective\n    def calculate_improvement(sol):\n        total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (total1, total2, total3)\n\n    current_obj = calculate_improvement(base_solution)\n    new_obj = calculate_improvement(new_solution)\n\n    # Perform swap if it improves at least one objective\n    if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n        # Additional swap to further improve the worst objective\n        worst_obj_idx = np.argmax(new_obj)\n        if worst_obj_idx == 0:\n            mat = distance_matrix_1\n        elif worst_obj_idx == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find the worst edge in the current solution\n        worst_edge = None\n        worst_cost = -np.inf\n        for i in range(n):\n            cost = mat[new_solution[i], new_solution[(i+1)%n]]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = i\n\n        # Try to replace the worst edge with a better one\n        if worst_edge is not None:\n            i = worst_edge\n            j = (i + 1) % n\n            # Find the best possible replacement\n            best_replacement = None\n            best_improvement = 0\n            for k in range(n):\n                if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                    continue\n                # Calculate potential improvement\n                old_cost1 = mat[new_solution[i], new_solution[j]]\n                new_cost1 = mat[new_solution[i], new_solution[k]] + mat[new_solution[k], new_solution[j]]\n                improvement = old_cost1 - new_cost1\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_replacement = k\n\n            if best_replacement is not None:\n                # Perform the replacement\n                temp = new_solution[j]\n                new_solution[j] = new_solution[best_replacement]\n                new_solution[best_replacement] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8365766462931239,
            1.380811905860901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt, edge insertion, and objective-aware swaps\n    n = len(new_solution)\n\n    # 1. 2-opt local search (for one objective)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Edge insertion (for another objective)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # 3. Objective-aware swap (for the third objective)\n    # Identify the objective with the highest improvement potential\n    obj1 = archive[selected_idx][1][0]\n    obj2 = archive[selected_idx][1][1]\n    obj3 = archive[selected_idx][1][2]\n\n    # Calculate potential improvement for each objective\n    def calculate_improvement(sol):\n        total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (total1, total2, total3)\n\n    current_obj = calculate_improvement(base_solution)\n    new_obj = calculate_improvement(new_solution)\n\n    # Perform swap if it improves at least one objective\n    if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n        # Additional swap to further improve the worst objective\n        worst_obj_idx = np.argmax(new_obj)\n        if worst_obj_idx == 0:\n            mat = distance_matrix_1\n        elif worst_obj_idx == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find the worst edge in the current solution\n        worst_edge = None\n        worst_cost = -np.inf\n        for i in range(n):\n            cost = mat[new_solution[i], new_solution[(i+1)%n]]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = i\n\n        # Try to replace the worst edge with a better one\n        if worst_edge is not None:\n            i = worst_edge\n            j = (i + 1) % n\n            # Find the best possible replacement\n            best_replacement = None\n            best_improvement = 0\n            for k in range(n):\n                if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                    continue\n                # Calculate potential improvement\n                old_cost1 = mat[new_solution[i], new_solution[j]]\n                new_cost1 = mat[new_solution[i], new_solution[k]] + mat[new_solution[k], new_solution[j]]\n                improvement = old_cost1 - new_cost1\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_replacement = k\n\n            if best_replacement is not None:\n                # Perform the replacement\n                temp = new_solution[j]\n                new_solution[j] = new_solution[best_replacement]\n                new_solution[best_replacement] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 43,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt, edge insertion, and objective-aware swaps\n    n = len(new_solution)\n\n    # 1. 2-opt local search (for one objective)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Edge insertion (for another objective)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # 3. Objective-aware swap (for the third objective)\n    # Identify the objective with the highest improvement potential\n    obj1 = archive[selected_idx][1][0]\n    obj2 = archive[selected_idx][1][1]\n    obj3 = archive[selected_idx][1][2]\n\n    # Calculate potential improvement for each objective\n    def calculate_improvement(sol):\n        total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (total1, total2, total3)\n\n    current_obj = calculate_improvement(base_solution)\n    new_obj = calculate_improvement(new_solution)\n\n    # Perform swap if it improves at least one objective\n    if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n        # Additional swap to further improve the worst objective\n        worst_obj_idx = np.argmax(new_obj)\n        if worst_obj_idx == 0:\n            mat = distance_matrix_1\n        elif worst_obj_idx == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find the worst edge in the current solution\n        worst_edge = None\n        worst_cost = -np.inf\n        for i in range(n):\n            cost = mat[new_solution[i], new_solution[(i+1)%n]]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = i\n\n        # Try to replace the worst edge with a better one\n        if worst_edge is not None:\n            i = worst_edge\n            j = (i + 1) % n\n            # Find the best possible replacement\n            best_replacement = None\n            best_improvement = 0\n            for k in range(n):\n                if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                    continue\n                # Calculate potential improvement\n                old_cost1 = mat[new_solution[i], new_solution[j]]\n                new_cost1 = mat[new_solution[i], new_solution[k]] + mat[new_solution[k], new_solution[j]]\n                improvement = old_cost1 - new_cost1\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_replacement = k\n\n            if best_replacement is not None:\n                # Perform the replacement\n                temp = new_solution[j]\n                new_solution[j] = new_solution[best_replacement]\n                new_solution[best_replacement] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8365766462931239,
            1.380811905860901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt, edge insertion, and objective-aware swaps\n    n = len(new_solution)\n\n    # 1. 2-opt local search (for one objective)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Edge insertion (for another objective)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # 3. Objective-aware swap (for the third objective)\n    # Identify the objective with the highest improvement potential\n    obj1 = archive[selected_idx][1][0]\n    obj2 = archive[selected_idx][1][1]\n    obj3 = archive[selected_idx][1][2]\n\n    # Calculate potential improvement for each objective\n    def calculate_improvement(sol):\n        total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (total1, total2, total3)\n\n    current_obj = calculate_improvement(base_solution)\n    new_obj = calculate_improvement(new_solution)\n\n    # Perform swap if it improves at least one objective\n    if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n        # Additional swap to further improve the worst objective\n        worst_obj_idx = np.argmax(new_obj)\n        if worst_obj_idx == 0:\n            mat = distance_matrix_1\n        elif worst_obj_idx == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find the worst edge in the current solution\n        worst_edge = None\n        worst_cost = -np.inf\n        for i in range(n):\n            cost = mat[new_solution[i], new_solution[(i+1)%n]]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = i\n\n        # Try to replace the worst edge with a better one\n        if worst_edge is not None:\n            i = worst_edge\n            j = (i + 1) % n\n            # Find the best possible replacement\n            best_replacement = None\n            best_improvement = 0\n            for k in range(n):\n                if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                    continue\n                # Calculate potential improvement\n                old_cost1 = mat[new_solution[i], new_solution[j]]\n                new_cost1 = mat[new_solution[i], new_solution[k]] + mat[new_solution[k], new_solution[j]]\n                improvement = old_cost1 - new_cost1\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_replacement = k\n\n            if best_replacement is not None:\n                # Perform the replacement\n                temp = new_solution[j]\n                new_solution[j] = new_solution[best_replacement]\n                new_solution[best_replacement] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 44,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already converged)\n    # Here we select a solution that is not already at a local optimum in all three objectives\n    # This is a simplified heuristic - in practice, you might use more sophisticated criteria\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Limit the number of attempts to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Try 2-opt move\n        candidate_solution = new_solution.copy()\n        candidate_solution[i:j+1] = candidate_solution[i:j+1][::-1]\n\n        # Evaluate the candidate in all three objectives\n        cost1 = sum(distance_matrix_1[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n\n        # Accept the move if it improves at least one objective\n        if (cost1 <= archive[selected_idx][1][0] or\n            cost2 <= archive[selected_idx][1][1] or\n            cost3 <= archive[selected_idx][1][2]):\n            new_solution = candidate_solution\n\n        # Try objective-aware swap (swap nodes that are \"bad\" in at least one objective)\n        if np.random.rand() < 0.3:  # 30% chance to try this\n            # Find nodes with high cost in any objective\n            costs = np.zeros(n)\n            for k in range(n):\n                prev = new_solution[(k-1)%n]\n                curr = new_solution[k]\n                next_ = new_solution[(k+1)%n]\n                costs[k] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_] +\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_] +\n                           distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_])\n\n            # Select nodes to swap (top 20% worst nodes)\n            worst_nodes = np.argsort(costs)[-max(2, n//5):]\n            if len(worst_nodes) >= 2:\n                a, b = np.random.choice(worst_nodes, 2, replace=False)\n                candidate_solution = new_solution.copy()\n                candidate_solution[a], candidate_solution[b] = candidate_solution[b], candidate_solution[a]\n\n                # Evaluate the candidate\n                cost1 = sum(distance_matrix_1[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n                cost3 = sum(distance_matrix_3[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n\n                # Accept if it improves at least one objective\n                if (cost1 <= archive[selected_idx][1][0] or\n                    cost2 <= archive[selected_idx][1][1] or\n                    cost3 <= archive[selected_idx][1][2]):\n                    new_solution = candidate_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7463657322194633,
            3.060896873474121
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already converged)\n    # Here we select a solution that is not already at a local optimum in all three objectives\n    # This is a simplified heuristic - in practice, you might use more sophisticated criteria\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Limit the number of attempts to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Try 2-opt move\n        candidate_solution = new_solution.copy()\n        candidate_solution[i:j+1] = candidate_solution[i:j+1][::-1]\n\n        # Evaluate the candidate in all three objectives\n        cost1 = sum(distance_matrix_1[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n\n        # Accept the move if it improves at least one objective\n        if (cost1 <= archive[selected_idx][1][0] or\n            cost2 <= archive[selected_idx][1][1] or\n            cost3 <= archive[selected_idx][1][2]):\n            new_solution = candidate_solution\n\n        # Try objective-aware swap (swap nodes that are \"bad\" in at least one objective)\n        if np.random.rand() < 0.3:  # 30% chance to try this\n            # Find nodes with high cost in any objective\n            costs = np.zeros(n)\n            for k in range(n):\n                prev = new_solution[(k-1)%n]\n                curr = new_solution[k]\n                next_ = new_solution[(k+1)%n]\n                costs[k] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_] +\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_] +\n                           distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_])\n\n            # Select nodes to swap (top 20% worst nodes)\n            worst_nodes = np.argsort(costs)[-max(2, n//5):]\n            if len(worst_nodes) >= 2:\n                a, b = np.random.choice(worst_nodes, 2, replace=False)\n                candidate_solution = new_solution.copy()\n                candidate_solution[a], candidate_solution[b] = candidate_solution[b], candidate_solution[a]\n\n                # Evaluate the candidate\n                cost1 = sum(distance_matrix_1[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n                cost3 = sum(distance_matrix_3[candidate_solution[k], candidate_solution[(k+1)%n]] for k in range(n))\n\n                # Accept if it improves at least one objective\n                if (cost1 <= archive[selected_idx][1][0] or\n                    cost2 <= archive[selected_idx][1][1] or\n                    cost3 <= archive[selected_idx][1][2]):\n                    new_solution = candidate_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 45,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good or too bad)\n    archive_solutions = [sol for sol, _ in archive]\n    solution_indices = np.random.choice(len(archive_solutions), size=min(5, len(archive_solutions)), replace=False)\n    selected_solution = archive_solutions[np.random.choice(solution_indices)]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt local search\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for multi-objective edge swap\n        # Select two random edges and swap their endpoints if it improves at least one objective\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        k = np.random.randint(1, n-1)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate objective changes\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        original_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or (new_cost3 < original_cost3):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7647400209180754,
            1.0522814393043518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good or too bad)\n    archive_solutions = [sol for sol, _ in archive]\n    solution_indices = np.random.choice(len(archive_solutions), size=min(5, len(archive_solutions)), replace=False)\n    selected_solution = archive_solutions[np.random.choice(solution_indices)]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt local search\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for multi-objective edge swap\n        # Select two random edges and swap their endpoints if it improves at least one objective\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        k = np.random.randint(1, n-1)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate objective changes\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        original_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or (new_cost3 < original_cost3):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 46,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple local search steps\n        # Randomly select two segments to swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[l]]\n                  - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[k-1], new_solution[k]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[l]]\n                  - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[k-1], new_solution[k]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[k-1], new_solution[l]]\n                  - distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n        # Apply the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7099187822303745,
            1.4082688689231873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple local search steps\n        # Randomly select two segments to swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[l]]\n                  - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[k-1], new_solution[k]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[l]]\n                  - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[k-1], new_solution[k]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[k-1], new_solution[l]]\n                  - distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n        # Apply the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 47,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to find potentially non-optimal solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the middle to avoid both extremes\n        candidate_indices = [len(archive_sorted) // 3, len(archive_sorted) // 2, 2 * len(archive_sorted) // 3]\n        selected_idx = np.random.choice(candidate_indices)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Perform a 2-opt swap\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: identify nodes that are critical in any objective space\n    if n > 2:\n        # Calculate the contribution of each node to the total cost in each objective\n        total_costs = [0.0, 0.0, 0.0]\n        for k in range(n-1):\n            total_costs[0] += distance_matrix_1[new_solution[k], new_solution[k+1]]\n            total_costs[1] += distance_matrix_2[new_solution[k], new_solution[k+1]]\n            total_costs[2] += distance_matrix_3[new_solution[k], new_solution[k+1]]\n        total_costs[0] += distance_matrix_1[new_solution[-1], new_solution[0]]\n        total_costs[1] += distance_matrix_2[new_solution[-1], new_solution[0]]\n        total_costs[2] += distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Find nodes with the highest marginal contribution in any objective\n        marginal_costs = []\n        for k in range(n):\n            prev = new_solution[k-1] if k > 0 else new_solution[-1]\n            next_node = new_solution[k+1] if k < n-1 else new_solution[0]\n            cost1 = distance_matrix_1[prev, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n            cost2 = distance_matrix_2[prev, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n            cost3 = distance_matrix_3[prev, new_solution[k]] + distance_matrix_3[new_solution[k], next_node]\n            marginal_costs.append((cost1 + cost2 + cost3, k))\n\n        # Sort by marginal cost and select top candidates\n        marginal_costs.sort(reverse=True)\n        top_candidates = [idx for (cost, idx) in marginal_costs[:max(2, n//10)]]\n\n        # Perform a swap between a random top candidate and a random other node\n        if len(top_candidates) > 1:\n            c1 = np.random.choice(top_candidates)\n            c2 = np.random.choice([i for i in range(n) if i not in top_candidates])\n            new_solution[c1], new_solution[c2] = new_solution[c2], new_solution[c1]\n\n    return new_solution\n\n",
        "score": [
            -0.7333933258777712,
            0.7794495940208435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to find potentially non-optimal solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the middle to avoid both extremes\n        candidate_indices = [len(archive_sorted) // 3, len(archive_sorted) // 2, 2 * len(archive_sorted) // 3]\n        selected_idx = np.random.choice(candidate_indices)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Perform a 2-opt swap\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: identify nodes that are critical in any objective space\n    if n > 2:\n        # Calculate the contribution of each node to the total cost in each objective\n        total_costs = [0.0, 0.0, 0.0]\n        for k in range(n-1):\n            total_costs[0] += distance_matrix_1[new_solution[k], new_solution[k+1]]\n            total_costs[1] += distance_matrix_2[new_solution[k], new_solution[k+1]]\n            total_costs[2] += distance_matrix_3[new_solution[k], new_solution[k+1]]\n        total_costs[0] += distance_matrix_1[new_solution[-1], new_solution[0]]\n        total_costs[1] += distance_matrix_2[new_solution[-1], new_solution[0]]\n        total_costs[2] += distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Find nodes with the highest marginal contribution in any objective\n        marginal_costs = []\n        for k in range(n):\n            prev = new_solution[k-1] if k > 0 else new_solution[-1]\n            next_node = new_solution[k+1] if k < n-1 else new_solution[0]\n            cost1 = distance_matrix_1[prev, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n            cost2 = distance_matrix_2[prev, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n            cost3 = distance_matrix_3[prev, new_solution[k]] + distance_matrix_3[new_solution[k], next_node]\n            marginal_costs.append((cost1 + cost2 + cost3, k))\n\n        # Sort by marginal cost and select top candidates\n        marginal_costs.sort(reverse=True)\n        top_candidates = [idx for (cost, idx) in marginal_costs[:max(2, n//10)]]\n\n        # Perform a swap between a random top candidate and a random other node\n        if len(top_candidates) > 1:\n            c1 = np.random.choice(top_candidates)\n            c2 = np.random.choice([i for i in range(n) if i not in top_candidates])\n            new_solution[c1], new_solution[c2] = new_solution[c2], new_solution[c1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 48,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (promising for further improvement)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: identify the worst edge in terms of all three objectives\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n\n    for k in range(n):\n        node1 = new_solution[k]\n        node2 = new_solution[(k + 1) % n]\n        total_cost = (distance_matrix_1[node1, node2] +\n                      distance_matrix_2[node1, node2] +\n                      distance_matrix_3[node1, node2])\n\n        if total_cost > worst_edge_cost:\n            worst_edge_cost = total_cost\n            worst_edge_idx = k\n\n    if worst_edge_idx != -1:\n        # Swap nodes to improve all objectives\n        m = (worst_edge_idx + 1) % n\n        new_solution[worst_edge_idx], new_solution[m] = new_solution[m], new_solution[worst_edge_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8258109782602159,
            0.9451960325241089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (promising for further improvement)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: identify the worst edge in terms of all three objectives\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n\n    for k in range(n):\n        node1 = new_solution[k]\n        node2 = new_solution[(k + 1) % n]\n        total_cost = (distance_matrix_1[node1, node2] +\n                      distance_matrix_2[node1, node2] +\n                      distance_matrix_3[node1, node2])\n\n        if total_cost > worst_edge_cost:\n            worst_edge_cost = total_cost\n            worst_edge_idx = k\n\n    if worst_edge_idx != -1:\n        # Swap nodes to improve all objectives\n        m = (worst_edge_idx + 1) % n\n        new_solution[worst_edge_idx], new_solution[m] = new_solution[m], new_solution[worst_edge_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 49,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score for each solution (sum of normalized objectives)\n    max_obj1 = max(obj[0] for obj in archive_objectives)\n    max_obj2 = max(obj[1] for obj in archive_objectives)\n    max_obj3 = max(obj[2] for obj in archive_objectives)\n\n    scores = []\n    for obj in archive_objectives:\n        # Normalize objectives and combine them\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0\n        norm_obj3 = obj[2] / max_obj3 if max_obj3 > 0 else 0\n        scores.append(norm_obj1 + norm_obj2 + norm_obj3)\n\n    # Select the solution with the highest score (most potential for improvement)\n    selected_idx = np.argmax(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, perform a combination of 2-opt and relocate moves\n        # First, perform 2-opt on a randomly selected segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Then, perform a relocate move on another randomly selected segment\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution is still a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(new_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7379993819861693,
            0.8581452608108521
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score for each solution (sum of normalized objectives)\n    max_obj1 = max(obj[0] for obj in archive_objectives)\n    max_obj2 = max(obj[1] for obj in archive_objectives)\n    max_obj3 = max(obj[2] for obj in archive_objectives)\n\n    scores = []\n    for obj in archive_objectives:\n        # Normalize objectives and combine them\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0\n        norm_obj3 = obj[2] / max_obj3 if max_obj3 > 0 else 0\n        scores.append(norm_obj1 + norm_obj2 + norm_obj3)\n\n    # Select the solution with the highest score (most potential for improvement)\n    selected_idx = np.argmax(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, perform a combination of 2-opt and relocate moves\n        # First, perform 2-opt on a randomly selected segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Then, perform a relocate move on another randomly selected segment\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution is still a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(new_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 50,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    worst_objectives = [max(obj) for obj in objectives]\n    selected_index = np.argmax(worst_objectives)\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node insertion\n    if np.random.rand() < 0.5:\n        # 2-opt move: reverse a random segment\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion: move a random node to a new position\n        i = np.random.randint(n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution is valid (no duplicates and all nodes are present)\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.441616358896095,
            0.9244720101356506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    worst_objectives = [max(obj) for obj in objectives]\n    selected_index = np.argmax(worst_objectives)\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node insertion\n    if np.random.rand() < 0.5:\n        # 2-opt move: reverse a random segment\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion: move a random node to a new position\n        i = np.random.randint(n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution is valid (no duplicates and all nodes are present)\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 51,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential (not just the first one)\n    selected_idx = random.randint(0, min(4, len(archive)-1))  # Select from first few to maintain diversity\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (swap segment between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: find the best possible swap that improves at least one objective\n    for _ in range(3):  # Try a few swaps to improve multiple objectives\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Current and new edges in all three objectives\n        current_edges = [\n            (new_solution[a-1], new_solution[a]),\n            (new_solution[b-1], new_solution[b])\n        ]\n        new_edges = [\n            (new_solution[a-1], new_solution[b]),\n            (new_solution[b-1], new_solution[a])\n        ]\n\n        # Calculate cost differences for all three objectives\n        cost_diff_1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]]) - \\\n                      (distance_matrix_1[current_edges[0]] + distance_matrix_1[current_edges[1]])\n        cost_diff_2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]]) - \\\n                      (distance_matrix_2[current_edges[0]] + distance_matrix_2[current_edges[1]])\n        cost_diff_3 = (distance_matrix_3[new_edges[0]] + distance_matrix_3[new_edges[1]]) - \\\n                      (distance_matrix_3[current_edges[0]] + distance_matrix_3[current_edges[1]])\n\n        # Accept if at least one objective improves\n        if cost_diff_1 < 0 or cost_diff_2 < 0 or cost_diff_3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7518555848041284,
            0.6637248516082763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential (not just the first one)\n    selected_idx = random.randint(0, min(4, len(archive)-1))  # Select from first few to maintain diversity\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (swap segment between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: find the best possible swap that improves at least one objective\n    for _ in range(3):  # Try a few swaps to improve multiple objectives\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Current and new edges in all three objectives\n        current_edges = [\n            (new_solution[a-1], new_solution[a]),\n            (new_solution[b-1], new_solution[b])\n        ]\n        new_edges = [\n            (new_solution[a-1], new_solution[b]),\n            (new_solution[b-1], new_solution[a])\n        ]\n\n        # Calculate cost differences for all three objectives\n        cost_diff_1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]]) - \\\n                      (distance_matrix_1[current_edges[0]] + distance_matrix_1[current_edges[1]])\n        cost_diff_2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]]) - \\\n                      (distance_matrix_2[current_edges[0]] + distance_matrix_2[current_edges[1]])\n        cost_diff_3 = (distance_matrix_3[new_edges[0]] + distance_matrix_3[new_edges[1]]) - \\\n                      (distance_matrix_3[current_edges[0]] + distance_matrix_3[current_edges[1]])\n\n        # Accept if at least one objective improves\n        if cost_diff_1 < 0 or cost_diff_2 < 0 or cost_diff_3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 52,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Objective-aware 2-opt: select edges that are problematic in any objective\n    for _ in range(10):  # Limit the number of attempts\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[base_solution[i-1], base_solution[i]] +\n            distance_matrix_1[base_solution[j], base_solution[(j+1)%n]],\n            distance_matrix_2[base_solution[i-1], base_solution[i]] +\n            distance_matrix_2[base_solution[j], base_solution[(j+1)%n]],\n            distance_matrix_3[base_solution[i-1], base_solution[i]] +\n            distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[base_solution[i-1], base_solution[j]] +\n            distance_matrix_1[base_solution[i], base_solution[(j+1)%n]],\n            distance_matrix_2[base_solution[i-1], base_solution[j]] +\n            distance_matrix_2[base_solution[i], base_solution[(j+1)%n]],\n            distance_matrix_3[base_solution[i-1], base_solution[j]] +\n            distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n        ]\n\n        # If the new solution improves at least one objective\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            # Apply the 2-opt move\n            new_solution[i:j+1] = base_solution[i:j+1][::-1]\n            break\n\n    # Objective-aware node insertion: try to improve the worst-performing objective\n    if random.random() < 0.5:  # 50% chance to apply this operator\n        # Find the objective with the highest current cost\n        obj_costs = [\n            sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        ]\n        worst_obj = np.argmax(obj_costs)\n\n        # Select a random node and try to reinsert it to improve the worst objective\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        best_insert_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n - 1):\n            # Try inserting at position pos\n            temp_solution = np.insert(new_solution, pos, node)\n\n            if worst_obj == 0:\n                cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n            elif worst_obj == 1:\n                cost = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n            else:\n                cost = sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_insert_pos = pos\n\n        if best_insert_pos != -1:\n            new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7628031533805004,
            1.243230438232422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Objective-aware 2-opt: select edges that are problematic in any objective\n    for _ in range(10):  # Limit the number of attempts\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[base_solution[i-1], base_solution[i]] +\n            distance_matrix_1[base_solution[j], base_solution[(j+1)%n]],\n            distance_matrix_2[base_solution[i-1], base_solution[i]] +\n            distance_matrix_2[base_solution[j], base_solution[(j+1)%n]],\n            distance_matrix_3[base_solution[i-1], base_solution[i]] +\n            distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[base_solution[i-1], base_solution[j]] +\n            distance_matrix_1[base_solution[i], base_solution[(j+1)%n]],\n            distance_matrix_2[base_solution[i-1], base_solution[j]] +\n            distance_matrix_2[base_solution[i], base_solution[(j+1)%n]],\n            distance_matrix_3[base_solution[i-1], base_solution[j]] +\n            distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n        ]\n\n        # If the new solution improves at least one objective\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            # Apply the 2-opt move\n            new_solution[i:j+1] = base_solution[i:j+1][::-1]\n            break\n\n    # Objective-aware node insertion: try to improve the worst-performing objective\n    if random.random() < 0.5:  # 50% chance to apply this operator\n        # Find the objective with the highest current cost\n        obj_costs = [\n            sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        ]\n        worst_obj = np.argmax(obj_costs)\n\n        # Select a random node and try to reinsert it to improve the worst objective\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        best_insert_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n - 1):\n            # Try inserting at position pos\n            temp_solution = np.insert(new_solution, pos, node)\n\n            if worst_obj == 0:\n                cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n            elif worst_obj == 1:\n                cost = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n            else:\n                cost = sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_insert_pos = pos\n\n        if best_insert_pos != -1:\n            new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 53,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by the sum of objectives (lower is better)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]  # Top 20% or at least 1 solution\n    base_solution, _ = random.choice(selection_pool)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly choose between 2-opt or edge exchange\n    if random.random() < 0.5:\n        # 2-opt local search: select two non-adjacent edges and reverse the subsequence\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange: move a segment between two edges\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original (this should rarely happen with proper selection)\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6828190766324419,
            0.7047632575035095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by the sum of objectives (lower is better)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]  # Top 20% or at least 1 solution\n    base_solution, _ = random.choice(selection_pool)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly choose between 2-opt or edge exchange\n    if random.random() < 0.5:\n        # 2-opt local search: select two non-adjacent edges and reverse the subsequence\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange: move a segment between two edges\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original (this should rarely happen with proper selection)\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 54,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: prioritize swaps that improve at least one objective\n    for _ in range(3):  # Try a few times to find an improving swap\n        k, l = np.random.choice(n, 2, replace=False)\n        if k == l:\n            continue\n\n        # Calculate current and new objective values\n        current_obj = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        )\n\n        new_obj = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]] +\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]] +\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        )\n\n        if new_obj < current_obj:  # If at least one objective improves\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n            break\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8052042996647245,
            1.347369134426117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: prioritize swaps that improve at least one objective\n    for _ in range(3):  # Try a few times to find an improving swap\n        k, l = np.random.choice(n, 2, replace=False)\n        if k == l:\n            continue\n\n        # Calculate current and new objective values\n        current_obj = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        )\n\n        new_obj = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]] +\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]] +\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        )\n\n        if new_obj < current_obj:  # If at least one objective improves\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n            break\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 55,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to identify those with high potential\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% or top 5, whichever is larger\n        selection_pool = sorted_solutions[:max(5, len(archive) // 3)]\n        # Randomly select a solution from the pool\n        selected = random.choice(selection_pool)\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(new_solution)\n    if n > 3:\n        # Randomly choose between 2-opt and edge exchange\n        if random.random() < 0.5:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Edge exchange move: swap two edges to create a new cycle\n            i, j = sorted(random.sample(range(n), 2))\n            # Ensure the exchange creates a valid tour\n            if j - i > 1:\n                new_solution[i:j] = np.concatenate([new_solution[i+1:j], new_solution[i:i+1]])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid solution: duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.6746847068902339,
            1.1374500274658204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to identify those with high potential\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% or top 5, whichever is larger\n        selection_pool = sorted_solutions[:max(5, len(archive) // 3)]\n        # Randomly select a solution from the pool\n        selected = random.choice(selection_pool)\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(new_solution)\n    if n > 3:\n        # Randomly choose between 2-opt and edge exchange\n        if random.random() < 0.5:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Edge exchange move: swap two edges to create a new cycle\n            i, j = sorted(random.sample(range(n), 2))\n            # Ensure the exchange creates a valid tour\n            if j - i > 1:\n                new_solution[i:j] = np.concatenate([new_solution[i+1:j], new_solution[i:i+1]])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid solution: duplicate nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 56,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    selected_idx = np.argmax([np.std(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify nodes with high potential for improvement\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                dist_matrix = distance_matrix_1\n            elif obj_idx == 1:\n                dist_matrix = distance_matrix_2\n            else:\n                dist_matrix = distance_matrix_3\n\n            # Find nodes with high potential for improvement in this objective\n            improvements = []\n            for k in range(n):\n                prev_node = new_solution[k-1]\n                curr_node = new_solution[k]\n                next_node = new_solution[(k+1)%n]\n\n                # Calculate potential improvement if we swap curr_node with next_node\n                original_cost = dist_matrix[prev_node, curr_node] + dist_matrix[curr_node, next_node]\n                swapped_cost = dist_matrix[prev_node, next_node] + dist_matrix[next_node, curr_node]\n                improvement = original_cost - swapped_cost\n                improvements.append((improvement, k))\n\n            # Sort by improvement and select top candidates\n            improvements.sort(reverse=True, key=lambda x: x[0])\n            top_candidates = [k for _, k in improvements[:3]]\n\n            # Perform the best swap\n            for k in top_candidates:\n                new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7277548214137006,
            4.189933133125305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    selected_idx = np.argmax([np.std(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify nodes with high potential for improvement\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                dist_matrix = distance_matrix_1\n            elif obj_idx == 1:\n                dist_matrix = distance_matrix_2\n            else:\n                dist_matrix = distance_matrix_3\n\n            # Find nodes with high potential for improvement in this objective\n            improvements = []\n            for k in range(n):\n                prev_node = new_solution[k-1]\n                curr_node = new_solution[k]\n                next_node = new_solution[(k+1)%n]\n\n                # Calculate potential improvement if we swap curr_node with next_node\n                original_cost = dist_matrix[prev_node, curr_node] + dist_matrix[curr_node, next_node]\n                swapped_cost = dist_matrix[prev_node, next_node] + dist_matrix[next_node, curr_node]\n                improvement = original_cost - swapped_cost\n                improvements.append((improvement, k))\n\n            # Sort by improvement and select top candidates\n            improvements.sort(reverse=True, key=lambda x: x[0])\n            top_candidates = [k for _, k in improvements[:3]]\n\n            # Perform the best swap\n            for k in top_candidates:\n                new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 57,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + i) for i in range(len(archive))],\n        k=1\n    )[0]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    # Calculate current objectives\n    def calculate_objective(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Identify the worst objective\n    worst_obj_index = np.argmax(current_obj)\n\n    # Perform swaps to improve the worst objective while keeping others stable\n    for _ in range(min(3, n//2)):\n        # Select two random nodes to swap\n        a, b = random.sample(range(n), 2)\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[a], candidate[b] = candidate[b], candidate[a]\n\n        candidate_obj = calculate_objective(candidate)\n\n        # Accept if the worst objective improves or if other objectives don't worsen too much\n        if (candidate_obj[worst_obj_index] < current_obj[worst_obj_index] or\n            (all(candidate_obj[i] <= current_obj[i] for i in range(3)) and\n             any(candidate_obj[i] < current_obj[i] for i in range(3)))):\n            new_solution = candidate\n            current_obj = candidate_obj\n\n    return new_solution\n\n",
        "score": [
            -0.7324264169649441,
            1.1669488668441772
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + i) for i in range(len(archive))],\n        k=1\n    )[0]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    # Calculate current objectives\n    def calculate_objective(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Identify the worst objective\n    worst_obj_index = np.argmax(current_obj)\n\n    # Perform swaps to improve the worst objective while keeping others stable\n    for _ in range(min(3, n//2)):\n        # Select two random nodes to swap\n        a, b = random.sample(range(n), 2)\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[a], candidate[b] = candidate[b], candidate[a]\n\n        candidate_obj = calculate_objective(candidate)\n\n        # Accept if the worst objective improves or if other objectives don't worsen too much\n        if (candidate_obj[worst_obj_index] < current_obj[worst_obj_index] or\n            (all(candidate_obj[i] <= current_obj[i] for i in range(3)) and\n             any(candidate_obj[i] < current_obj[i] for i in range(3)))):\n            new_solution = candidate\n            current_obj = candidate_obj\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 58,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or low objective values\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and random swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt for the first two objectives\n    if np.random.rand() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random swap for the third objective\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7893292764526562,
            1.1082113146781922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or low objective values\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and random swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt for the first two objectives\n    if np.random.rand() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random swap for the third objective\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 59,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Sort by a combined objective value (sum of all three objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions\n        selected_index = random.randint(0, max(0, int(0.3 * len(sorted_solutions)) - 1))\n        base_solution = sorted_solutions[selected_index][0].copy()\n    else:\n        base_solution = candidates[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Choose between 2-opt or edge insertion based on a weighted probability\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            # 2-opt: reverse a segment to potentially reduce tour length\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge insertion: remove a node and reinsert it in a better position\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            # Evaluate insertion points based on all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(len(new_solution)):\n                # Try inserting node after position i\n                temp_solution = np.insert(new_solution, i, node)\n                # Calculate total cost across all three objectives\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost3 = sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5796025875538677,
            2.4232778549194336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Sort by a combined objective value (sum of all three objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions\n        selected_index = random.randint(0, max(0, int(0.3 * len(sorted_solutions)) - 1))\n        base_solution = sorted_solutions[selected_index][0].copy()\n    else:\n        base_solution = candidates[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Choose between 2-opt or edge insertion based on a weighted probability\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            # 2-opt: reverse a segment to potentially reduce tour length\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge insertion: remove a node and reinsert it in a better position\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            # Evaluate insertion points based on all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(len(new_solution)):\n                # Try inserting node after position i\n                temp_solution = np.insert(new_solution, i, node)\n                # Calculate total cost across all three objectives\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost3 = sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2 + cost3\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 60,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that have the worst objective values in any space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    max_obj3 = max(obj[2] for obj in objectives)\n\n    # Find solutions with the worst objectives in any space\n    candidate_indices = [\n        i for i, obj in enumerate(objectives)\n        if obj[0] == max_obj1 or obj[1] == max_obj2 or obj[2] == max_obj3\n    ]\n\n    if not candidate_indices:\n        # If no such solutions, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Select from candidates with probability based on their worst objective\n        selected_idx = random.choice(candidate_indices)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard for TSP)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform a 3-opt move (more disruptive)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Finally, perform a random swap between objectives to balance the solution\n    if random.random() < 0.5:\n        # Swap two random nodes to explore different neighborhoods\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7471356269123441,
            0.9761826872825623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that have the worst objective values in any space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    max_obj3 = max(obj[2] for obj in objectives)\n\n    # Find solutions with the worst objectives in any space\n    candidate_indices = [\n        i for i, obj in enumerate(objectives)\n        if obj[0] == max_obj1 or obj[1] == max_obj2 or obj[2] == max_obj3\n    ]\n\n    if not candidate_indices:\n        # If no such solutions, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Select from candidates with probability based on their worst objective\n        selected_idx = random.choice(candidate_indices)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard for TSP)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform a 3-opt move (more disruptive)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Finally, perform a random swap between objectives to balance the solution\n    if random.random() < 0.5:\n        # Swap two random nodes to explore different neighborhoods\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 61,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (indicating potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variances, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Select three edges with high potential for improvement across objectives\n    potential_edges = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[a, b]\n        cost2 = distance_matrix_2[a, b]\n        cost3 = distance_matrix_3[a, b]\n        potential_edges.append((i, cost1 + cost2 + cost3))\n\n    potential_edges.sort(key=lambda x: x[1], reverse=True)\n    selected_edges = [edge[0] for edge in potential_edges[:3]]\n\n    # Perform 3-opt operation on selected edges\n    if len(selected_edges) == 3:\n        i, j, k = sorted(selected_edges)\n        # Reverse the middle segment\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6989949114866046,
            1.229782497882843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (indicating potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variances, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Select three edges with high potential for improvement across objectives\n    potential_edges = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[a, b]\n        cost2 = distance_matrix_2[a, b]\n        cost3 = distance_matrix_3[a, b]\n        potential_edges.append((i, cost1 + cost2 + cost3))\n\n    potential_edges.sort(key=lambda x: x[1], reverse=True)\n    selected_edges = [edge[0] for edge in potential_edges[:3]]\n\n    # Perform 3-opt operation on selected edges\n    if len(selected_edges) == 3:\n        i, j, k = sorted(selected_edges)\n        # Reverse the middle segment\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 62,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and objective-aware swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware swap: identify the edge with highest sum of distances across objectives\n        max_sum = -1\n        best_i, best_j = 0, 0\n\n        for i in range(n):\n            j = (i + 1) % n\n            node_i, node_j = new_solution[i], new_solution[j]\n            dist_sum = distance_matrix_1[node_i, node_j] + distance_matrix_2[node_i, node_j] + distance_matrix_3[node_i, node_j]\n\n            if dist_sum > max_sum:\n                max_sum = dist_sum\n                best_i, best_j = i, j\n\n        # Perform a swap that improves the worst objective\n        if best_i != best_j:\n            # Find the node that would improve the worst objective when swapped\n            worst_obj = np.argmax([distance_matrix_1[new_solution[best_i], new_solution[best_j]],\n                                  distance_matrix_2[new_solution[best_i], new_solution[best_j]],\n                                  distance_matrix_3[new_solution[best_i], new_solution[best_j]]])\n\n            # Find a candidate node to swap with\n            candidates = list(range(n))\n            random.shuffle(candidates)\n\n            for candidate in candidates:\n                if candidate != best_i and candidate != best_j:\n                    # Calculate the improvement potential\n                    original_dist = (distance_matrix_1[new_solution[best_i], new_solution[best_j]] +\n                                    distance_matrix_2[new_solution[best_i], new_solution[best_j]] +\n                                    distance_matrix_3[new_solution[best_i], new_solution[best_j]])\n\n                    new_dist = (distance_matrix_1[new_solution[best_i], new_solution[candidate]] +\n                               distance_matrix_2[new_solution[best_i], new_solution[candidate]] +\n                               distance_matrix_3[new_solution[best_i], new_solution[candidate]])\n\n                    if new_dist < original_dist:\n                        # Perform the swap\n                        new_solution[best_j], new_solution[candidate] = new_solution[candidate], new_solution[best_j]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7455701249274213,
            1.1831235766410828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and objective-aware swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware swap: identify the edge with highest sum of distances across objectives\n        max_sum = -1\n        best_i, best_j = 0, 0\n\n        for i in range(n):\n            j = (i + 1) % n\n            node_i, node_j = new_solution[i], new_solution[j]\n            dist_sum = distance_matrix_1[node_i, node_j] + distance_matrix_2[node_i, node_j] + distance_matrix_3[node_i, node_j]\n\n            if dist_sum > max_sum:\n                max_sum = dist_sum\n                best_i, best_j = i, j\n\n        # Perform a swap that improves the worst objective\n        if best_i != best_j:\n            # Find the node that would improve the worst objective when swapped\n            worst_obj = np.argmax([distance_matrix_1[new_solution[best_i], new_solution[best_j]],\n                                  distance_matrix_2[new_solution[best_i], new_solution[best_j]],\n                                  distance_matrix_3[new_solution[best_i], new_solution[best_j]]])\n\n            # Find a candidate node to swap with\n            candidates = list(range(n))\n            random.shuffle(candidates)\n\n            for candidate in candidates:\n                if candidate != best_i and candidate != best_j:\n                    # Calculate the improvement potential\n                    original_dist = (distance_matrix_1[new_solution[best_i], new_solution[best_j]] +\n                                    distance_matrix_2[new_solution[best_i], new_solution[best_j]] +\n                                    distance_matrix_3[new_solution[best_i], new_solution[best_j]])\n\n                    new_dist = (distance_matrix_1[new_solution[best_i], new_solution[candidate]] +\n                               distance_matrix_2[new_solution[best_i], new_solution[candidate]] +\n                               distance_matrix_3[new_solution[best_i], new_solution[candidate]])\n\n                    if new_dist < original_dist:\n                        # Perform the swap\n                        new_solution[best_j], new_solution[candidate] = new_solution[candidate], new_solution[best_j]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 63,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value (sum of objectives)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply 2-opt and swap based on worst-performing objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst-performing objective\n    objectives = archive[0][1]\n    worst_obj_index = np.argmax(objectives)\n\n    # Apply 2-opt on the worst-performing objective\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply swap based on the worst-performing objective\n    if worst_obj_index == 0:\n        # Swap nodes with highest distance in space 1\n        max_dist_idx = np.argmax(distance_matrix_1[new_solution, :][:, new_solution])\n        i, j = np.unravel_index(max_dist_idx, (n, n))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif worst_obj_index == 1:\n        # Swap nodes with highest distance in space 2\n        max_dist_idx = np.argmax(distance_matrix_2[new_solution, :][:, new_solution])\n        i, j = np.unravel_index(max_dist_idx, (n, n))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Swap nodes with highest distance in space 3\n        max_dist_idx = np.argmax(distance_matrix_3[new_solution, :][:, new_solution])\n        i, j = np.unravel_index(max_dist_idx, (n, n))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5780787130156921,
            0.7594653010368347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value (sum of objectives)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply 2-opt and swap based on worst-performing objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst-performing objective\n    objectives = archive[0][1]\n    worst_obj_index = np.argmax(objectives)\n\n    # Apply 2-opt on the worst-performing objective\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply swap based on the worst-performing objective\n    if worst_obj_index == 0:\n        # Swap nodes with highest distance in space 1\n        max_dist_idx = np.argmax(distance_matrix_1[new_solution, :][:, new_solution])\n        i, j = np.unravel_index(max_dist_idx, (n, n))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif worst_obj_index == 1:\n        # Swap nodes with highest distance in space 2\n        max_dist_idx = np.argmax(distance_matrix_2[new_solution, :][:, new_solution])\n        i, j = np.unravel_index(max_dist_idx, (n, n))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Swap nodes with highest distance in space 3\n        max_dist_idx = np.argmax(distance_matrix_3[new_solution, :][:, new_solution])\n        i, j = np.unravel_index(max_dist_idx, (n, n))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 64,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (descending) to prioritize those with higher costs\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select the top 20% of solutions\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top solutions\n        selected_idx = np.random.randint(0, len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and random swap\n    if len(new_solution) > 3:\n        # Apply 2-opt to the first objective space\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Apply random swap to the second objective space\n        k, l = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Ensure the solution remains feasible (no duplicates, all nodes visited)\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != len(new_solution):\n            # If duplicates are found, revert to the original solution\n            new_solution = base_solution.copy()\n    else:\n        # For small tours, just swap two nodes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6306349008701739,
            0.9099870204925538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (descending) to prioritize those with higher costs\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select the top 20% of solutions\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top solutions\n        selected_idx = np.random.randint(0, len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and random swap\n    if len(new_solution) > 3:\n        # Apply 2-opt to the first objective space\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Apply random swap to the second objective space\n        k, l = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Ensure the solution remains feasible (no duplicates, all nodes visited)\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != len(new_solution):\n            # If duplicates are found, revert to the original solution\n            new_solution = base_solution.copy()\n    else:\n        # For small tours, just swap two nodes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 65,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined objective)\n    objectives = np.array([obj for _, obj in archive])\n    combined_objectives = objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate the potential move in all three objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        # Calculate edge differences in all three objectives\n        diff1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        diff2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        diff3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        # Accept if at least one objective improves or if no deterioration\n        if diff1 <= 0 or diff2 <= 0 or diff3 <= 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8035688485307981,
            1.3052685856819153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined objective)\n    objectives = np.array([obj for _, obj in archive])\n    combined_objectives = objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate the potential move in all three objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        # Calculate edge differences in all three objectives\n        diff1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        diff2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        diff3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                 distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                 distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        # Accept if at least one objective improves or if no deterioration\n        if diff1 <= 0 or diff2 <= 0 or diff3 <= 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 66,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 20%)\n    top_k = max(1, len(archive) // 5)\n    candidates = sorted(archive, key=lambda x: sum(x[1]))[:top_k]\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combination of 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move based on the most promising objective\n    obj_values = selected[1]\n    worst_obj = np.argmax(obj_values)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        d = dist_matrix[u, v]\n        if d > max_dist:\n            max_dist = d\n            worst_edge = i\n\n    if worst_edge is not None:\n        # Try to improve by reversing a segment\n        for i in range(worst_edge + 2, n):\n            u = new_solution[worst_edge]\n            v = new_solution[(worst_edge + 1) % n]\n            x = new_solution[i]\n            y = new_solution[(i + 1) % n]\n\n            # Calculate potential improvement\n            old_dist = dist_matrix[u, v] + dist_matrix[x, y]\n            new_dist = dist_matrix[u, x] + dist_matrix[v, y]\n\n            if new_dist < old_dist:\n                # Apply 2-opt move\n                new_solution[worst_edge + 1:i + 1] = new_solution[worst_edge + 1:i + 1][::-1]\n                break\n\n    # Perform 3-opt move to further improve\n    for _ in range(3):  # Limit to 3 attempts for efficiency\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Try different 3-opt configurations\n        for config in [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i)\n        ]:\n            a, b, c = config\n            # Calculate total distance before and after\n            old_dist = (dist_matrix[new_solution[a], new_solution[(a+1)%n]] +\n                        dist_matrix[new_solution[b], new_solution[(b+1)%n]] +\n                        dist_matrix[new_solution[c], new_solution[(c+1)%n]])\n\n            new_dist = (dist_matrix[new_solution[a], new_solution[(b+1)%n]] +\n                        dist_matrix[new_solution[b], new_solution[(c+1)%n]] +\n                        dist_matrix[new_solution[c], new_solution[(a+1)%n]])\n\n            if new_dist < old_dist:\n                # Apply 3-opt move\n                new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n                new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7753308414343068,
            1.2531621694564818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 20%)\n    top_k = max(1, len(archive) // 5)\n    candidates = sorted(archive, key=lambda x: sum(x[1]))[:top_k]\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combination of 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move based on the most promising objective\n    obj_values = selected[1]\n    worst_obj = np.argmax(obj_values)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        d = dist_matrix[u, v]\n        if d > max_dist:\n            max_dist = d\n            worst_edge = i\n\n    if worst_edge is not None:\n        # Try to improve by reversing a segment\n        for i in range(worst_edge + 2, n):\n            u = new_solution[worst_edge]\n            v = new_solution[(worst_edge + 1) % n]\n            x = new_solution[i]\n            y = new_solution[(i + 1) % n]\n\n            # Calculate potential improvement\n            old_dist = dist_matrix[u, v] + dist_matrix[x, y]\n            new_dist = dist_matrix[u, x] + dist_matrix[v, y]\n\n            if new_dist < old_dist:\n                # Apply 2-opt move\n                new_solution[worst_edge + 1:i + 1] = new_solution[worst_edge + 1:i + 1][::-1]\n                break\n\n    # Perform 3-opt move to further improve\n    for _ in range(3):  # Limit to 3 attempts for efficiency\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Try different 3-opt configurations\n        for config in [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i)\n        ]:\n            a, b, c = config\n            # Calculate total distance before and after\n            old_dist = (dist_matrix[new_solution[a], new_solution[(a+1)%n]] +\n                        dist_matrix[new_solution[b], new_solution[(b+1)%n]] +\n                        dist_matrix[new_solution[c], new_solution[(c+1)%n]])\n\n            new_dist = (dist_matrix[new_solution[a], new_solution[(b+1)%n]] +\n                        dist_matrix[new_solution[b], new_solution[(c+1)%n]] +\n                        dist_matrix[new_solution[c], new_solution[(a+1)%n]])\n\n            if new_dist < old_dist:\n                # Apply 3-opt move\n                new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n                new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 67,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of all objectives)\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and random perturbation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move (if it improves any objective)\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    original_cost = calculate_cost(new_solution)\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]  # Reverse segment\n    new_cost = calculate_cost(temp_solution)\n\n    if any(new_cost[k] < original_cost[k] for k in range(3)):\n        new_solution = temp_solution\n    else:\n        # If 2-opt doesn't help, apply random perturbation\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6288739715202017,
            0.9975533723831177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of all objectives)\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and random perturbation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move (if it improves any objective)\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    original_cost = calculate_cost(new_solution)\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]  # Reverse segment\n    new_cost = calculate_cost(temp_solution)\n\n    if any(new_cost[k] < original_cost[k] for k in range(3)):\n        new_solution = temp_solution\n    else:\n        # If 2-opt doesn't help, apply random perturbation\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 68,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_k = max(1, len(archive) // 3)\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Choose one of three local search operators with equal probability\n    operator_choice = random.randint(0, 2)\n\n    if operator_choice == 0:\n        # 2-opt local search\n        n = len(base_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator_choice == 1:\n        # 3-opt local search (more disruptive)\n        n = len(base_solution)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution = base_solution.copy()\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    else:\n        # Multi-objective path relinking (combines features from two solutions)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n\n            # Create a new solution by combining segments from both solutions\n            n = len(base_solution)\n            split_point = random.randint(1, n-1)\n            new_solution = np.concatenate([\n                base_solution[:split_point],\n                other_solution[split_point:]\n            ])\n\n            # Remove duplicates and fill missing nodes\n            unique_nodes = np.unique(new_solution)\n            missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n            if len(missing_nodes) > 0:\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, missing_nodes)\n        else:\n            # Fallback to 2-opt if archive has only one solution\n            new_solution = base_solution.copy()\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.708953446698595,
            0.7813758492469788
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_k = max(1, len(archive) // 3)\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Choose one of three local search operators with equal probability\n    operator_choice = random.randint(0, 2)\n\n    if operator_choice == 0:\n        # 2-opt local search\n        n = len(base_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator_choice == 1:\n        # 3-opt local search (more disruptive)\n        n = len(base_solution)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution = base_solution.copy()\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    else:\n        # Multi-objective path relinking (combines features from two solutions)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n\n            # Create a new solution by combining segments from both solutions\n            n = len(base_solution)\n            split_point = random.randint(1, n-1)\n            new_solution = np.concatenate([\n                base_solution[:split_point],\n                other_solution[split_point:]\n            ])\n\n            # Remove duplicates and fill missing nodes\n            unique_nodes = np.unique(new_solution)\n            missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n            if len(missing_nodes) > 0:\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, missing_nodes)\n        else:\n            # Fallback to 2-opt if archive has only one solution\n            new_solution = base_solution.copy()\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 69,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 70% 2-opt, 20% 3-opt, 10% random swap\n    operator_choice = random.random()\n\n    if operator_choice < 0.7:\n        # 2-opt: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator_choice < 0.9:\n        # 3-opt: select three edges and perform a 3-opt swap\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n    else:\n        # Random swap: swap two nodes\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.80028543231751,
            0.7878460884094238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 70% 2-opt, 20% 3-opt, 10% random swap\n    operator_choice = random.random()\n\n    if operator_choice < 0.7:\n        # 2-opt: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator_choice < 0.9:\n        # 3-opt: select three edges and perform a 3-opt swap\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n    else:\n        # Random swap: swap two nodes\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 70,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a combined score for each solution based on its objectives\n    scores = []\n    for sol, obj in archive:\n        combined_score = sum(obj)  # Simple sum of objectives as a proxy for potential improvement\n        scores.append(combined_score)\n\n    # Select the solution with the lowest combined score (best current solution)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Choose a random segment of the tour to modify\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n\n    # Apply a 2-opt move (standard local search)\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply a 3-opt move (more disruptive) to escape local optima\n    if random.random() < 0.3:  # 30% chance to apply 3-opt\n        c = random.randint(0, n-1)\n        if a < b < c:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n        elif a < c < b:\n            new_solution[a:c] = new_solution[a:c][::-1]\n            new_solution[c:b] = new_solution[c:b][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6825708483153674,
            1.5476383328437806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a combined score for each solution based on its objectives\n    scores = []\n    for sol, obj in archive:\n        combined_score = sum(obj)  # Simple sum of objectives as a proxy for potential improvement\n        scores.append(combined_score)\n\n    # Select the solution with the lowest combined score (best current solution)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Choose a random segment of the tour to modify\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n\n    # Apply a 2-opt move (standard local search)\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply a 3-opt move (more disruptive) to escape local optima\n    if random.random() < 0.3:  # 30% chance to apply 3-opt\n        c = random.randint(0, n-1)\n        if a < b < c:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n        elif a < c < b:\n            new_solution[a:c] = new_solution[a:c][::-1]\n            new_solution[c:b] = new_solution[c:b][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 71,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply 2-opt move (swap edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt move (reconnect three edges)\n    if j + 1 < n and k > j + 1:\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    # Objective-aware selection: if the new solution is dominated, revert\n    def calculate_objective(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1))\n        cost3 += distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    new_obj = calculate_objective(new_solution)\n    original_obj = archive[0][1]\n\n    if (new_obj[0] > original_obj[0] and new_obj[1] > original_obj[1] and new_obj[2] > original_obj[2]):\n        return selected_solution  # Revert if new solution is dominated\n    else:\n        return new_solution\n\n",
        "score": [
            -0.5160481542209318,
            2.514010453224182
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply 2-opt move (swap edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt move (reconnect three edges)\n    if j + 1 < n and k > j + 1:\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    # Objective-aware selection: if the new solution is dominated, revert\n    def calculate_objective(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1))\n        cost3 += distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    new_obj = calculate_objective(new_solution)\n    original_obj = archive[0][1]\n\n    if (new_obj[0] > original_obj[0] and new_obj[1] > original_obj[1] and new_obj[2] > original_obj[2]):\n        return selected_solution  # Revert if new solution is dominated\n    else:\n        return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 72,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt moves\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt move (swap edges)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply 3-opt move (shuffle a segment)\n    if k < l:\n        new_solution[k:l] = np.roll(new_solution[k:l], shift=1)\n\n    # Ensure the tour remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7802920943931891,
            0.8014334082603455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt moves\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt move (swap edges)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply 3-opt move (shuffle a segment)\n    if k < l:\n        new_solution[k:l] = np.roll(new_solution[k:l], shift=1)\n\n    # Ensure the tour remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 73,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move (local improvement)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a multi-objective aware perturbation\n    # Calculate the objective differences for the current and new solutions\n    current_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    # If the new solution is worse in all objectives, revert to the original\n    if all(new_obj[o] >= current_obj[o] for o in range(3)):\n        new_solution = base_solution.copy()\n\n    # Further perturbation: swap segments based on objective weights\n    if np.random.rand() < 0.3:  # 30% chance of additional perturbation\n        # Calculate objective weights based on relative improvement potential\n        weights = [abs(new_obj[o] - current_obj[o]) for o in range(3)]\n        if sum(weights) > 0:\n            weights = [w/sum(weights) for w in weights]\n        else:\n            weights = [1/3, 1/3, 1/3]\n\n        # Select an objective to focus on\n        selected_obj = np.random.choice(3, p=weights)\n\n        # Find the worst segment in the selected objective\n        segment_lengths = [distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]\n        if selected_obj == 1:\n            segment_lengths = [distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]\n        elif selected_obj == 2:\n            segment_lengths = [distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]\n\n        worst_segment = np.argmax(segment_lengths)\n        k = worst_segment\n\n        # Find a better segment to replace it with\n        candidates = [i for i in range(n) if i != k]\n        if candidates:\n            l = np.random.choice(candidates)\n            # Swap the segments\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7582229185546454,
            0.7759588360786438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move (local improvement)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a multi-objective aware perturbation\n    # Calculate the objective differences for the current and new solutions\n    current_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    )\n\n    # If the new solution is worse in all objectives, revert to the original\n    if all(new_obj[o] >= current_obj[o] for o in range(3)):\n        new_solution = base_solution.copy()\n\n    # Further perturbation: swap segments based on objective weights\n    if np.random.rand() < 0.3:  # 30% chance of additional perturbation\n        # Calculate objective weights based on relative improvement potential\n        weights = [abs(new_obj[o] - current_obj[o]) for o in range(3)]\n        if sum(weights) > 0:\n            weights = [w/sum(weights) for w in weights]\n        else:\n            weights = [1/3, 1/3, 1/3]\n\n        # Select an objective to focus on\n        selected_obj = np.random.choice(3, p=weights)\n\n        # Find the worst segment in the selected objective\n        segment_lengths = [distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]\n        if selected_obj == 1:\n            segment_lengths = [distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]\n        elif selected_obj == 2:\n            segment_lengths = [distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]\n\n        worst_segment = np.argmax(segment_lengths)\n        k = worst_segment\n\n        # Find a better segment to replace it with\n        candidates = [i for i in range(n) if i != k]\n        if candidates:\n            l = np.random.choice(candidates)\n            # Swap the segments\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 74,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and low crowding distance (promising for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the most critical objective (randomly selected)\n    obj_idx = np.random.randint(0, 3)\n    if obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective\n    worst_edge = -1\n    max_gain = -float('inf')\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        gain = distance_matrix[u, v] - (distance_matrix[u, new_solution[(i-1)%n]] + distance_matrix[new_solution[(i+2)%n], v])\n        if gain > max_gain:\n            max_gain = gain\n            worst_edge = i\n\n    if worst_edge != -1:\n        # Perform 2-opt\n        i, j = worst_edge, (worst_edge + 1) % n\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Multi-objective aware perturbation: swap nodes that are critical in any objective\n    for _ in range(2):  # Limit perturbation to prevent excessive changes\n        # Find nodes with high marginal contribution in any objective\n        critical_nodes = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            marginal_contribution = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n            if marginal_contribution > np.mean(distance_matrix_1) * 0.7:  # Threshold\n                critical_nodes.append(i)\n\n        if critical_nodes:\n            i = np.random.choice(critical_nodes)\n            j = np.random.choice([x for x in range(n) if x != i and x != (i+1)%n and x != (i-1)%n])\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7921269795113222,
            1.8196560621261597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and low crowding distance (promising for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the most critical objective (randomly selected)\n    obj_idx = np.random.randint(0, 3)\n    if obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective\n    worst_edge = -1\n    max_gain = -float('inf')\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        gain = distance_matrix[u, v] - (distance_matrix[u, new_solution[(i-1)%n]] + distance_matrix[new_solution[(i+2)%n], v])\n        if gain > max_gain:\n            max_gain = gain\n            worst_edge = i\n\n    if worst_edge != -1:\n        # Perform 2-opt\n        i, j = worst_edge, (worst_edge + 1) % n\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Multi-objective aware perturbation: swap nodes that are critical in any objective\n    for _ in range(2):  # Limit perturbation to prevent excessive changes\n        # Find nodes with high marginal contribution in any objective\n        critical_nodes = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            marginal_contribution = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n            if marginal_contribution > np.mean(distance_matrix_1) * 0.7:  # Threshold\n                critical_nodes.append(i)\n\n        if critical_nodes:\n            i = np.random.choice(critical_nodes)\n            j = np.random.choice([x for x in range(n) if x != i and x != (i+1)%n and x != (i-1)%n])\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 75,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive with higher probability for solutions with better trade-offs\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for (_, obj) in archive]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=normalized_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and segment inversion\n    if random.random() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion: randomly select a segment and invert it\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        # Find all positions with this duplicate\n        dup_indices = np.where(new_solution == dup)[0]\n        # Find a node that is missing in the tour\n        all_nodes = np.arange(n)\n        missing_nodes = np.setdiff1d(all_nodes, new_solution)\n        if len(missing_nodes) > 0:\n            # Replace one occurrence of the duplicate with a missing node\n            replace_idx = dup_indices[0]\n            new_solution[replace_idx] = missing_nodes[0]\n\n    return new_solution\n\n",
        "score": [
            -0.6868121108547575,
            0.8930953621864319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive with higher probability for solutions with better trade-offs\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for (_, obj) in archive]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=normalized_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and segment inversion\n    if random.random() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion: randomly select a segment and invert it\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        # Find all positions with this duplicate\n        dup_indices = np.where(new_solution == dup)[0]\n        # Find a node that is missing in the tour\n        all_nodes = np.arange(n)\n        missing_nodes = np.setdiff1d(all_nodes, new_solution)\n        if len(missing_nodes) > 0:\n            # Replace one occurrence of the duplicate with a missing node\n            replace_idx = dup_indices[0]\n            new_solution[replace_idx] = missing_nodes[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 76,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential_score(solution, objectives):\n        # Calculate the average improvement potential across all objectives\n        avg_improvement = sum(objectives) / 3\n        return avg_improvement\n\n    # Sort solutions by potential score (ascending)\n    archive_sorted = sorted(archive, key=lambda x: potential_score(x[0], x[1]))\n\n    # Select top 30% of solutions with the highest potential\n    top_percent = max(1, int(0.3 * len(archive_sorted)))\n    candidates = archive_sorted[:top_percent]\n\n    # Randomly select one from top candidates\n    selected = random.choice(candidates)[0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected.copy()\n\n    # 1. Randomly select two distinct edges to break\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2. Perform a 2-opt move with probability 0.7, otherwise perform a 3-opt move\n    if random.random() < 0.7:\n        # 2-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move (more complex but can help escape local optima)\n        k = random.randint(j, n-1)\n        # Apply 3-opt: reverse segments and reorder\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simple 2-opt move\n        new_solution = selected.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7124989273800899,
            1.1110722184181214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential_score(solution, objectives):\n        # Calculate the average improvement potential across all objectives\n        avg_improvement = sum(objectives) / 3\n        return avg_improvement\n\n    # Sort solutions by potential score (ascending)\n    archive_sorted = sorted(archive, key=lambda x: potential_score(x[0], x[1]))\n\n    # Select top 30% of solutions with the highest potential\n    top_percent = max(1, int(0.3 * len(archive_sorted)))\n    candidates = archive_sorted[:top_percent]\n\n    # Randomly select one from top candidates\n    selected = random.choice(candidates)[0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected.copy()\n\n    # 1. Randomly select two distinct edges to break\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2. Perform a 2-opt move with probability 0.7, otherwise perform a 3-opt move\n    if random.random() < 0.7:\n        # 2-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move (more complex but can help escape local optima)\n        k = random.randint(j, n-1)\n        # Apply 3-opt: reverse segments and reorder\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simple 2-opt move\n        new_solution = selected.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 77,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = []\n    for solution, objectives in archive:\n        # Calculate the \"improvement potential\" based on the distance to the Pareto front\n        # Here we use a simple heuristic: solutions with higher total cost have more potential\n        total_cost = sum(objectives)\n        candidates.append((solution, total_cost))\n\n    # Sort candidates by total cost in descending order to prioritize high-cost solutions\n    candidates.sort(key=lambda x: -x[1])\n    base_solution = candidates[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and edge exchange\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge exchange (swap two edges)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            # Perform edge exchange\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7324350290754381,
            0.9234941720962524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = []\n    for solution, objectives in archive:\n        # Calculate the \"improvement potential\" based on the distance to the Pareto front\n        # Here we use a simple heuristic: solutions with higher total cost have more potential\n        total_cost = sum(objectives)\n        candidates.append((solution, total_cost))\n\n    # Sort candidates by total cost in descending order to prioritize high-cost solutions\n    candidates.sort(key=lambda x: -x[1])\n    base_solution = candidates[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and edge exchange\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge exchange (swap two edges)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            # Perform edge exchange\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 78,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to other solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # 2-opt move (standard local search)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: choose a swap that improves at least one objective\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        original_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n        swapped_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        if swapped_cost < original_cost:  # At least one objective improves\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7571702601833467,
            0.9487640380859375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to other solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # 2-opt move (standard local search)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: choose a swap that improves at least one objective\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        original_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n        swapped_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        if swapped_cost < original_cost:  # At least one objective improves\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 79,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good, not too bad)\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) == 1:\n        base_solution = archive_solutions[0].copy()\n    else:\n        # Randomly select a solution with some bias towards the middle of the archive\n        middle = len(archive_solutions) // 2\n        base_solution = archive_solutions[max(0, middle - 1 + np.random.randint(-1, 2))].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_total_cost(new_solution)\n\n    # Try 2-opt swaps\n    for _ in range(10):  # Limit the number of attempts\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Perform 2-opt swap\n        candidate_solution = new_solution.copy()\n        candidate_solution[i:j+1] = candidate_solution[i:j+1][::-1]\n\n        # Check if the swap improves any objective\n        candidate_cost = calculate_total_cost(candidate_solution)\n        if any(candidate_cost[k] < current_cost[k] for k in range(3)):\n            new_solution = candidate_solution\n            current_cost = candidate_cost\n            break\n\n    # If no improvement with 2-opt, try objective-aware swaps\n    if new_solution is base_solution:\n        # Select the worst objective to improve\n        worst_obj = np.argmax(current_cost)\n\n        # Find the most problematic edge in this objective\n        worst_edge = -1\n        worst_value = -1\n        for i in range(n):\n            edge_value = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] if worst_obj == 0 else \\\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] if worst_obj == 1 else \\\n                         distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            if edge_value > worst_value:\n                worst_value = edge_value\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Try to replace the worst edge with a better one\n            candidate_solution = new_solution.copy()\n            # Find the best possible replacement\n            best_replacement = worst_edge\n            best_improvement = 0\n\n            for j in range(n):\n                if j == worst_edge or j == (worst_edge + 1) % n:\n                    continue\n\n                # Try inserting node j after worst_edge\n                temp_solution = new_solution.copy()\n                temp_solution = np.roll(temp_solution, -worst_edge)\n                temp_solution[1] = temp_solution[j]\n                temp_solution = np.roll(temp_solution, worst_edge)\n\n                temp_cost = calculate_total_cost(temp_solution)\n                improvement = current_cost[worst_obj] - temp_cost[worst_obj]\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    candidate_solution = temp_solution\n\n            if best_improvement > 0:\n                new_solution = candidate_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7237276577314564,
            0.9191846370697021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good, not too bad)\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) == 1:\n        base_solution = archive_solutions[0].copy()\n    else:\n        # Randomly select a solution with some bias towards the middle of the archive\n        middle = len(archive_solutions) // 2\n        base_solution = archive_solutions[max(0, middle - 1 + np.random.randint(-1, 2))].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_total_cost(new_solution)\n\n    # Try 2-opt swaps\n    for _ in range(10):  # Limit the number of attempts\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Perform 2-opt swap\n        candidate_solution = new_solution.copy()\n        candidate_solution[i:j+1] = candidate_solution[i:j+1][::-1]\n\n        # Check if the swap improves any objective\n        candidate_cost = calculate_total_cost(candidate_solution)\n        if any(candidate_cost[k] < current_cost[k] for k in range(3)):\n            new_solution = candidate_solution\n            current_cost = candidate_cost\n            break\n\n    # If no improvement with 2-opt, try objective-aware swaps\n    if new_solution is base_solution:\n        # Select the worst objective to improve\n        worst_obj = np.argmax(current_cost)\n\n        # Find the most problematic edge in this objective\n        worst_edge = -1\n        worst_value = -1\n        for i in range(n):\n            edge_value = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] if worst_obj == 0 else \\\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] if worst_obj == 1 else \\\n                         distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            if edge_value > worst_value:\n                worst_value = edge_value\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Try to replace the worst edge with a better one\n            candidate_solution = new_solution.copy()\n            # Find the best possible replacement\n            best_replacement = worst_edge\n            best_improvement = 0\n\n            for j in range(n):\n                if j == worst_edge or j == (worst_edge + 1) % n:\n                    continue\n\n                # Try inserting node j after worst_edge\n                temp_solution = new_solution.copy()\n                temp_solution = np.roll(temp_solution, -worst_edge)\n                temp_solution[1] = temp_solution[j]\n                temp_solution = np.roll(temp_solution, worst_edge)\n\n                temp_cost = calculate_total_cost(temp_solution)\n                improvement = current_cost[worst_obj] - temp_cost[worst_obj]\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    candidate_solution = temp_solution\n\n            if best_improvement > 0:\n                new_solution = candidate_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 80,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array([(obj[0], obj[1], obj[2]) for obj in objectives])\n    if len(normalized_objectives) > 0:\n        normalized_objectives = (normalized_objectives - normalized_objectives.min(axis=0)) / (normalized_objectives.max(axis=0) - normalized_objectives.min(axis=0) + 1e-6)\n    combined_scores = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search strategy\n    # Step 1: 2-opt move (edge-based optimization)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion (diversification)\n    if n > 3:\n        node_to_move = new_solution[np.random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        insert_pos = np.random.randint(1, n)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Step 3: Tri-objective aware perturbation (novel component)\n    # Select a segment and reverse it based on the objective with highest variance\n    obj_variance = np.var(normalized_objectives, axis=0)\n    dominant_obj = np.argmax(obj_variance)\n\n    if dominant_obj == 0:\n        # Perturb based on first objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif dominant_obj == 1:\n        # Perturb based on second objective\n        node_to_move = new_solution[np.random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        insert_pos = np.random.randint(1, n)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n    else:\n        # Perturb based on third objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        node_to_move = new_solution[np.random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        insert_pos = np.random.randint(1, n)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple 2-opt if perturbation breaks validity\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.73972991064168,
            1.6675137400627136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array([(obj[0], obj[1], obj[2]) for obj in objectives])\n    if len(normalized_objectives) > 0:\n        normalized_objectives = (normalized_objectives - normalized_objectives.min(axis=0)) / (normalized_objectives.max(axis=0) - normalized_objectives.min(axis=0) + 1e-6)\n    combined_scores = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search strategy\n    # Step 1: 2-opt move (edge-based optimization)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion (diversification)\n    if n > 3:\n        node_to_move = new_solution[np.random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        insert_pos = np.random.randint(1, n)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Step 3: Tri-objective aware perturbation (novel component)\n    # Select a segment and reverse it based on the objective with highest variance\n    obj_variance = np.var(normalized_objectives, axis=0)\n    dominant_obj = np.argmax(obj_variance)\n\n    if dominant_obj == 0:\n        # Perturb based on first objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif dominant_obj == 1:\n        # Perturb based on second objective\n        node_to_move = new_solution[np.random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        insert_pos = np.random.randint(1, n)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n    else:\n        # Perturb based on third objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        node_to_move = new_solution[np.random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        insert_pos = np.random.randint(1, n)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple 2-opt if perturbation breaks validity\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 81,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Choose a segment to swap based on the worst objective\n    if worst_obj == 0:\n        # For the first objective, swap edges with high distance\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        # For the second objective, swap edges with high distance\n        dist_matrix = distance_matrix_2\n    else:\n        # For the third objective, swap edges with high distance\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    worst_edge = None\n    max_dist = -1\n    for k in range(n):\n        node1 = new_solution[k]\n        node2 = new_solution[(k+1) % n]\n        current_dist = dist_matrix[node1, node2]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            worst_edge = k\n\n    if worst_edge is not None:\n        # Swap the worst edge with another random edge\n        l = np.random.randint(n)\n        if l != worst_edge and l != (worst_edge + 1) % n:\n            new_solution[worst_edge], new_solution[l] = new_solution[l], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.8014972279922166,
            0.8757592439651489
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Choose a segment to swap based on the worst objective\n    if worst_obj == 0:\n        # For the first objective, swap edges with high distance\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        # For the second objective, swap edges with high distance\n        dist_matrix = distance_matrix_2\n    else:\n        # For the third objective, swap edges with high distance\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    worst_edge = None\n    max_dist = -1\n    for k in range(n):\n        node1 = new_solution[k]\n        node2 = new_solution[(k+1) % n]\n        current_dist = dist_matrix[node1, node2]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            worst_edge = k\n\n    if worst_edge is not None:\n        # Swap the worst edge with another random edge\n        l = np.random.randint(n)\n        if l != worst_edge and l != (worst_edge + 1) % n:\n            new_solution[worst_edge], new_solution[l] = new_solution[l], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 82,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are not dominated and have the highest variance in objectives\n    solution_scores = []\n    for sol, obj in archive:\n        # Calculate variance of objectives to identify diverse solutions\n        obj_variance = np.var(obj)\n        # Prefer solutions with higher variance as they might have room for improvement\n        score = obj_variance\n        solution_scores.append((score, sol))\n\n    # Sort solutions by score in descending order\n    solution_scores.sort(key=lambda x: -x[0])\n    selected_sol = solution_scores[0][1].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_sol.copy()\n\n    # 1. Randomly select a segment to reverse (2-opt like operation)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Randomly swap two nodes (3-opt like operation)\n    if n > 2:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Apply a 2.5-opt operation (insert a node in a different position)\n    if n > 3:\n        m = random.randint(0, n-1)\n        node = new_solution[m]\n        new_solution = np.delete(new_solution, m)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_sol.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4797230974581236,
            3.256457495689392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are not dominated and have the highest variance in objectives\n    solution_scores = []\n    for sol, obj in archive:\n        # Calculate variance of objectives to identify diverse solutions\n        obj_variance = np.var(obj)\n        # Prefer solutions with higher variance as they might have room for improvement\n        score = obj_variance\n        solution_scores.append((score, sol))\n\n    # Sort solutions by score in descending order\n    solution_scores.sort(key=lambda x: -x[0])\n    selected_sol = solution_scores[0][1].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_sol.copy()\n\n    # 1. Randomly select a segment to reverse (2-opt like operation)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Randomly swap two nodes (3-opt like operation)\n    if n > 2:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Apply a 2.5-opt operation (insert a node in a different position)\n    if n > 3:\n        m = random.randint(0, n-1)\n        node = new_solution[m]\n        new_solution = np.delete(new_solution, m)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_sol.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 83,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the highest sum of objectives (potential for improvement)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # 1. Randomly select a segment of the tour to reverse (2-opt local search)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a 3-opt move to further refine the solution\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        segment3 = new_solution[c+1:] if c+1 < n else np.array([])\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.5728775518222915,
            0.5169724225997925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the highest sum of objectives (potential for improvement)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # 1. Randomly select a segment of the tour to reverse (2-opt local search)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a 3-opt move to further refine the solution\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        segment3 = new_solution[c+1:] if c+1 < n else np.array([])\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 83,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the highest sum of objectives (potential for improvement)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # 1. Randomly select a segment of the tour to reverse (2-opt local search)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a 3-opt move to further refine the solution\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        segment3 = new_solution[c+1:] if c+1 < n else np.array([])\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.5728775518222915,
            0.5169724225997925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the highest sum of objectives (potential for improvement)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # 1. Randomly select a segment of the tour to reverse (2-opt local search)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a 3-opt move to further refine the solution\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        segment3 = new_solution[c+1:] if c+1 < n else np.array([])\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 84,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate edge costs in all three objective spaces\n    def calculate_edge_cost(solution, i, j):\n        cost1 = distance_matrix_1[solution[i], solution[j]]\n        cost2 = distance_matrix_2[solution[i], solution[j]]\n        cost3 = distance_matrix_3[solution[i], solution[j]]\n        return (cost1, cost2, cost3)\n\n    # Find edges with high potential for improvement in any objective\n    for _ in range(3):  # Try multiple swaps\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Current edges\n        current_cost1 = calculate_edge_cost(new_solution, i-1, i) + calculate_edge_cost(new_solution, j, (j+1)%n)\n        current_cost2 = calculate_edge_cost(new_solution, i-1, j) + calculate_edge_cost(new_solution, i, (j+1)%n)\n\n        # Check if swap would improve any objective\n        if (current_cost2[0] < current_cost1[0] or\n            current_cost2[1] < current_cost1[1] or\n            current_cost2[2] < current_cost1[2]):\n            # Perform swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, complete tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7929669566821032,
            0.7450231194496155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate edge costs in all three objective spaces\n    def calculate_edge_cost(solution, i, j):\n        cost1 = distance_matrix_1[solution[i], solution[j]]\n        cost2 = distance_matrix_2[solution[i], solution[j]]\n        cost3 = distance_matrix_3[solution[i], solution[j]]\n        return (cost1, cost2, cost3)\n\n    # Find edges with high potential for improvement in any objective\n    for _ in range(3):  # Try multiple swaps\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Current edges\n        current_cost1 = calculate_edge_cost(new_solution, i-1, i) + calculate_edge_cost(new_solution, j, (j+1)%n)\n        current_cost2 = calculate_edge_cost(new_solution, i-1, j) + calculate_edge_cost(new_solution, i, (j+1)%n)\n\n        # Check if swap would improve any objective\n        if (current_cost2[0] < current_cost1[0] or\n            current_cost2[1] < current_cost1[1] or\n            current_cost2[2] < current_cost1[2]):\n            # Perform swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, complete tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 85,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objective_variance * objectives, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for local search\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt swap for the first segment\n    if i != j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware swap for the second segment\n    if k != l:\n        # Evaluate the impact on all three objectives\n        current_obj = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n        )\n\n        new_obj = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[k], new_solution[(l+1)%n]],\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k], new_solution[(l+1)%n]],\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]\n        )\n\n        # If the swap improves at least one objective, perform it\n        if any(new < current for new, current in zip(new_obj, current_obj)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt swap\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.4768891953418179,
            1.2366759657859803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objective_variance * objectives, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for local search\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt swap for the first segment\n    if i != j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware swap for the second segment\n    if k != l:\n        # Evaluate the impact on all three objectives\n        current_obj = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n        )\n\n        new_obj = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[k], new_solution[(l+1)%n]],\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k], new_solution[(l+1)%n]],\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]\n        )\n\n        # If the swap improves at least one objective, perform it\n        if any(new < current for new, current in zip(new_obj, current_obj)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt swap\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 86,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by diversity)\n    weights = np.array([1.0 / (1 + obj[0] + obj[1] + obj[2]) for sol, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two segments to swap\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Create candidate solutions\n        candidate1 = new_solution.copy()\n        candidate1[i:j+1] = np.flip(candidate1[i:j+1])\n\n        candidate2 = new_solution.copy()\n        candidate2[k:l+1] = np.flip(candidate2[k:l+1])\n\n        # Evaluate candidates based on all three objectives\n        def evaluate(sol):\n            total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (total1, total2, total3)\n\n        current_obj = evaluate(new_solution)\n        obj1 = evaluate(candidate1)\n        obj2 = evaluate(candidate2)\n\n        # Accept if any objective improves\n        if (obj1[0] < current_obj[0] or obj1[1] < current_obj[1] or obj1[2] < current_obj[2]):\n            new_solution = candidate1\n            current_obj = obj1\n        elif (obj2[0] < current_obj[0] or obj2[1] < current_obj[1] or obj2[2] < current_obj[2]):\n            new_solution = candidate2\n            current_obj = obj2\n\n    return new_solution\n\n",
        "score": [
            -0.8022825144722703,
            3.0020206928253175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by diversity)\n    weights = np.array([1.0 / (1 + obj[0] + obj[1] + obj[2]) for sol, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two segments to swap\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Create candidate solutions\n        candidate1 = new_solution.copy()\n        candidate1[i:j+1] = np.flip(candidate1[i:j+1])\n\n        candidate2 = new_solution.copy()\n        candidate2[k:l+1] = np.flip(candidate2[k:l+1])\n\n        # Evaluate candidates based on all three objectives\n        def evaluate(sol):\n            total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            total3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (total1, total2, total3)\n\n        current_obj = evaluate(new_solution)\n        obj1 = evaluate(candidate1)\n        obj2 = evaluate(candidate2)\n\n        # Accept if any objective improves\n        if (obj1[0] < current_obj[0] or obj1[1] < current_obj[1] or obj1[2] < current_obj[2]):\n            new_solution = candidate1\n            current_obj = obj1\n        elif (obj2[0] < current_obj[0] or obj2[1] < current_obj[1] or obj2[2] < current_obj[2]):\n            new_solution = candidate2\n            current_obj = obj2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 87,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (promising candidates have higher potential)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select among the top 30% solutions to maintain diversity\n        top_candidates = sorted_solutions[:max(1, len(sorted_solutions) // 3)]\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    for _ in range(10):  # Number of attempts to improve the solution\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional improvement: try to move a node to a better position based on multiple objectives\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Calculate the change in all three objectives\n        if i < j:\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        else:\n            # Handle the case where i > j (node insertion)\n            delta1 = (distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                      distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] +\n                      distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            if i < j:\n                # Insert node i after position j\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n            else:\n                # Insert node j after position i\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6963037485201757,
            1.1109697103500367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (promising candidates have higher potential)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select among the top 30% solutions to maintain diversity\n        top_candidates = sorted_solutions[:max(1, len(sorted_solutions) // 3)]\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    for _ in range(10):  # Number of attempts to improve the solution\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional improvement: try to move a node to a better position based on multiple objectives\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Calculate the change in all three objectives\n        if i < j:\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        else:\n            # Handle the case where i > j (node insertion)\n            delta1 = (distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                      distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] +\n                      distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j-1], new_solution[j]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            if i < j:\n                # Insert node i after position j\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n            else:\n                # Insert node j after position i\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 88,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their sum of objectives (higher sum indicates more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% solutions with highest potential\n        top_candidates = archive_sorted[:max(1, int(len(archive_sorted) * 0.3))]\n        # Randomly select one from the top candidates\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly choose between 2-opt, 3-opt, or a custom objective-aware swap\n    search_type = random.choice(['2-opt', '3-opt', 'objective-aware'])\n\n    if search_type == '2-opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif search_type == '3-opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # Objective-aware swap\n        # Calculate the current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution))),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution))),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n        )\n\n        # Find the most improved swap by considering all objectives\n        best_improvement = 0\n        best_swap = None\n\n        for _ in range(10):  # Limit the number of random swaps to try\n            i, j = random.sample(range(len(new_solution)), 2)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            # Calculate new objective values\n            new_obj = (\n                sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution))),\n                sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution))),\n                sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            )\n\n            # Calculate total improvement (sum of improvements in all objectives)\n            improvement = sum(current_obj[k] - new_obj[k] for k in range(3))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7223618632711853,
            1.492023777961731
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their sum of objectives (higher sum indicates more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% solutions with highest potential\n        top_candidates = archive_sorted[:max(1, int(len(archive_sorted) * 0.3))]\n        # Randomly select one from the top candidates\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly choose between 2-opt, 3-opt, or a custom objective-aware swap\n    search_type = random.choice(['2-opt', '3-opt', 'objective-aware'])\n\n    if search_type == '2-opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif search_type == '3-opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # Objective-aware swap\n        # Calculate the current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution))),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution))),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n        )\n\n        # Find the most improved swap by considering all objectives\n        best_improvement = 0\n        best_swap = None\n\n        for _ in range(10):  # Limit the number of random swaps to try\n            i, j = random.sample(range(len(new_solution)), 2)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            # Calculate new objective values\n            new_obj = (\n                sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution))),\n                sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution))),\n                sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            )\n\n            # Calculate total improvement (sum of improvements in all objectives)\n            improvement = sum(current_obj[k] - new_obj[k] for k in range(3))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 89,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the normalized objective values to identify solutions with potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Select solutions with the lowest sum of normalized objectives (promising for improvement)\n    # or highest diversity (to avoid local optima)\n    potential_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(potential_scores)  # Prioritize solutions with the lowest objective values\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion for multi-objective optimization\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and edge insertion\n    if np.random.rand() < 0.5:\n        # 2-opt local search: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion: randomly select a node and insert it in a new position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution), \"Invalid solution generated\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.6543475737060099,
            1.2440595746040344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the normalized objective values to identify solutions with potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Select solutions with the lowest sum of normalized objectives (promising for improvement)\n    # or highest diversity (to avoid local optima)\n    potential_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(potential_scores)  # Prioritize solutions with the lowest objective values\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion for multi-objective optimization\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and edge insertion\n    if np.random.rand() < 0.5:\n        # 2-opt local search: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion: randomly select a node and insert it in a new position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution), \"Invalid solution generated\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 90,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already explored)\n    # Here, we select the solution with the highest total objective value (sum of all three objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt local search (more disruptive)\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply 3-opt move (reverse segments and reorder)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Objective-aware perturbation: select the best between original and perturbed\n    original_cost = (\n        sum(distance_matrix_1[selected_solution[i], selected_solution[i-1]] for i in range(n)) +\n        sum(distance_matrix_2[selected_solution[i], selected_solution[i-1]] for i in range(n)) +\n        sum(distance_matrix_3[selected_solution[i], selected_solution[i-1]] for i in range(n))\n    )\n\n    new_cost = (\n        sum(distance_matrix_1[new_solution[i], new_solution[i-1]] for i in range(n)) +\n        sum(distance_matrix_2[new_solution[i], new_solution[i-1]] for i in range(n)) +\n        sum(distance_matrix_3[new_solution[i], new_solution[i-1]] for i in range(n))\n    )\n\n    # If the new solution is worse, revert to original with a small probability\n    if new_cost > original_cost and np.random.rand() < 0.3:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7142397354864741,
            0.9317030787467957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already explored)\n    # Here, we select the solution with the highest total objective value (sum of all three objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt local search (more disruptive)\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply 3-opt move (reverse segments and reorder)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Objective-aware perturbation: select the best between original and perturbed\n    original_cost = (\n        sum(distance_matrix_1[selected_solution[i], selected_solution[i-1]] for i in range(n)) +\n        sum(distance_matrix_2[selected_solution[i], selected_solution[i-1]] for i in range(n)) +\n        sum(distance_matrix_3[selected_solution[i], selected_solution[i-1]] for i in range(n))\n    )\n\n    new_cost = (\n        sum(distance_matrix_1[new_solution[i], new_solution[i-1]] for i in range(n)) +\n        sum(distance_matrix_2[new_solution[i], new_solution[i-1]] for i in range(n)) +\n        sum(distance_matrix_3[new_solution[i], new_solution[i-1]] for i in range(n))\n    )\n\n    # If the new solution is worse, revert to original with a small probability\n    if new_cost > original_cost and np.random.rand() < 0.3:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 91,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_variance = -1\n\n    for sol, obj in archive:\n        variance = np.var(obj)\n        if variance > max_variance:\n            max_variance = variance\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform 2-opt swap between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge exchange between k and l\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (valid TSP tour)\n    if not np.all(np.unique(new_solution) == np.arange(n)):\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4754399864612212,
            3.5689215064048767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_variance = -1\n\n    for sol, obj in archive:\n        variance = np.var(obj)\n        if variance > max_variance:\n            max_variance = variance\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform 2-opt swap between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge exchange between k and l\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (valid TSP tour)\n    if not np.all(np.unique(new_solution) == np.arange(n)):\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 92,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too dominated)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with multi-objective aware edge selection\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Evaluate edges in all three objectives\n    def edge_cost(i, j):\n        return (distance_matrix_1[i, j], distance_matrix_2[i, j], distance_matrix_3[i, j])\n\n    # Select a segment to modify based on multi-objective criteria\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Apply 2-opt with multi-objective consideration\n    if b - a > 1:\n        # Reverse the segment between a+1 and b\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n        # Check if this improves at least one objective\n        old_costs = [edge_cost(base_solution[i-1], base_solution[i]) for i in range(1, n)] + [edge_cost(base_solution[-1], base_solution[0])]\n        new_costs = [edge_cost(new_solution[i-1], new_solution[i]) for i in range(1, n)] + [edge_cost(new_solution[-1], new_solution[0])]\n\n        # Only keep if at least one objective improves\n        improved = any(\n            (new_costs[i][0] < old_costs[i][0] or new_costs[i][1] < old_costs[i][1] or new_costs[i][2] < old_costs[i][2])\n            for i in range(n)\n        )\n\n        if not improved:\n            new_solution = base_solution.copy()\n\n    # Additional local search: try to swap edges that improve multiple objectives\n    for _ in range(2):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate current and potential new edges\n        old_edges = [\n            edge_cost(base_solution[i-1], base_solution[i]),\n            edge_cost(base_solution[j-1], base_solution[j])\n        ]\n        new_edges = [\n            edge_cost(base_solution[i-1], base_solution[j]),\n            edge_cost(base_solution[j-1], base_solution[i])\n        ]\n\n        # Count how many objectives would improve\n        improvements = sum(\n            (new_edges[0][k] < old_edges[0][k] and new_edges[1][k] < old_edges[1][k])\n            for k in range(3)\n        )\n\n        if improvements >= 2:  # Require improvement in at least two objectives\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7524600459401215,
            1.6919952392578126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too dominated)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with multi-objective aware edge selection\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Evaluate edges in all three objectives\n    def edge_cost(i, j):\n        return (distance_matrix_1[i, j], distance_matrix_2[i, j], distance_matrix_3[i, j])\n\n    # Select a segment to modify based on multi-objective criteria\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Apply 2-opt with multi-objective consideration\n    if b - a > 1:\n        # Reverse the segment between a+1 and b\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n        # Check if this improves at least one objective\n        old_costs = [edge_cost(base_solution[i-1], base_solution[i]) for i in range(1, n)] + [edge_cost(base_solution[-1], base_solution[0])]\n        new_costs = [edge_cost(new_solution[i-1], new_solution[i]) for i in range(1, n)] + [edge_cost(new_solution[-1], new_solution[0])]\n\n        # Only keep if at least one objective improves\n        improved = any(\n            (new_costs[i][0] < old_costs[i][0] or new_costs[i][1] < old_costs[i][1] or new_costs[i][2] < old_costs[i][2])\n            for i in range(n)\n        )\n\n        if not improved:\n            new_solution = base_solution.copy()\n\n    # Additional local search: try to swap edges that improve multiple objectives\n    for _ in range(2):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate current and potential new edges\n        old_edges = [\n            edge_cost(base_solution[i-1], base_solution[i]),\n            edge_cost(base_solution[j-1], base_solution[j])\n        ]\n        new_edges = [\n            edge_cost(base_solution[i-1], base_solution[j]),\n            edge_cost(base_solution[j-1], base_solution[i])\n        ]\n\n        # Count how many objectives would improve\n        improvements = sum(\n            (new_edges[0][k] < old_edges[0][k] and new_edges[1][k] < old_edges[1][k])\n            for k in range(3)\n        )\n\n        if improvements >= 2:  # Require improvement in at least two objectives\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 93,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with adaptive step size\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine step size based on solution quality (more steps for worse solutions)\n    step_size = max(2, int(np.log(n) * (1 - weighted_scores[selected_idx] / np.max(weighted_scores))))\n\n    # Perform 2-opt with the adaptive step size\n    for i in range(0, n, step_size):\n        j = (i + step_size) % n\n        if i < j:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "score": [
            -0.7124365492957145,
            1.1323474287986754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with adaptive step size\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine step size based on solution quality (more steps for worse solutions)\n    step_size = max(2, int(np.log(n) * (1 - weighted_scores[selected_idx] / np.max(weighted_scores))))\n\n    # Perform 2-opt with the adaptive step size\n    for i in range(0, n, step_size):\n        j = (i + step_size) % n\n        if i < j:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 94,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    improved = False\n\n    # First try 2-opt for each objective\n    for obj in range(3):\n        if obj == 0:\n            dist_matrix = distance_matrix_1\n        elif obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        for i in range(n):\n            for j in range(i + 2, n):\n                # Calculate current and potential new distances\n                current_dist = (dist_matrix[base_solution[i], base_solution[i+1]] +\n                              dist_matrix[base_solution[j], base_solution[(j+1)%n]])\n                new_dist = (dist_matrix[base_solution[i], base_solution[j]] +\n                           dist_matrix[base_solution[i+1], base_solution[(j+1)%n]])\n\n                if new_dist < current_dist:\n                    # Reverse the segment between i+1 and j\n                    new_solution = base_solution.copy()\n                    new_solution[i+1:j+1] = np.flip(base_solution[i+1:j+1])\n                    improved = True\n                    break\n            if improved:\n                break\n        if improved:\n            break\n\n    # If no improvement with 2-opt, try objective-aware swaps\n    if not improved:\n        # Select a random segment to consider swapping\n        segment_size = min(5, n // 2)\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Evaluate all possible swaps in the segment\n        best_swap = None\n        best_improvement = 0\n\n        for i in range(start, end):\n            for j in range(i + 1, end):\n                # Try swapping nodes i and j\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                # Calculate the improvement across all objectives\n                improvement = 0\n                for obj in range(3):\n                    if obj == 0:\n                        dist_matrix = distance_matrix_1\n                    elif obj == 1:\n                        dist_matrix = distance_matrix_2\n                    else:\n                        dist_matrix = distance_matrix_3\n\n                    # Calculate change in total distance\n                    old_dist = (dist_matrix[new_solution[(i-1)%n], new_solution[i]] +\n                               dist_matrix[new_solution[i], new_solution[(i+1)%n]] +\n                               dist_matrix[new_solution[(j-1)%n], new_solution[j]] +\n                               dist_matrix[new_solution[j], new_solution[(j+1)%n]])\n\n                    new_dist = (dist_matrix[temp_solution[(i-1)%n], temp_solution[i]] +\n                               dist_matrix[temp_solution[i], temp_solution[(i+1)%n]] +\n                               dist_matrix[temp_solution[(j-1)%n], temp_solution[j]] +\n                               dist_matrix[temp_solution[j], temp_solution[(j+1)%n]])\n\n                    improvement += (old_dist - new_dist)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.672825260012694,
            1.8372611045837401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    improved = False\n\n    # First try 2-opt for each objective\n    for obj in range(3):\n        if obj == 0:\n            dist_matrix = distance_matrix_1\n        elif obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        for i in range(n):\n            for j in range(i + 2, n):\n                # Calculate current and potential new distances\n                current_dist = (dist_matrix[base_solution[i], base_solution[i+1]] +\n                              dist_matrix[base_solution[j], base_solution[(j+1)%n]])\n                new_dist = (dist_matrix[base_solution[i], base_solution[j]] +\n                           dist_matrix[base_solution[i+1], base_solution[(j+1)%n]])\n\n                if new_dist < current_dist:\n                    # Reverse the segment between i+1 and j\n                    new_solution = base_solution.copy()\n                    new_solution[i+1:j+1] = np.flip(base_solution[i+1:j+1])\n                    improved = True\n                    break\n            if improved:\n                break\n        if improved:\n            break\n\n    # If no improvement with 2-opt, try objective-aware swaps\n    if not improved:\n        # Select a random segment to consider swapping\n        segment_size = min(5, n // 2)\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Evaluate all possible swaps in the segment\n        best_swap = None\n        best_improvement = 0\n\n        for i in range(start, end):\n            for j in range(i + 1, end):\n                # Try swapping nodes i and j\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                # Calculate the improvement across all objectives\n                improvement = 0\n                for obj in range(3):\n                    if obj == 0:\n                        dist_matrix = distance_matrix_1\n                    elif obj == 1:\n                        dist_matrix = distance_matrix_2\n                    else:\n                        dist_matrix = distance_matrix_3\n\n                    # Calculate change in total distance\n                    old_dist = (dist_matrix[new_solution[(i-1)%n], new_solution[i]] +\n                               dist_matrix[new_solution[i], new_solution[(i+1)%n]] +\n                               dist_matrix[new_solution[(j-1)%n], new_solution[j]] +\n                               dist_matrix[new_solution[j], new_solution[(j+1)%n]])\n\n                    new_dist = (dist_matrix[temp_solution[(i-1)%n], temp_solution[i]] +\n                               dist_matrix[temp_solution[i], temp_solution[(i+1)%n]] +\n                               dist_matrix[temp_solution[(j-1)%n], temp_solution[j]] +\n                               dist_matrix[temp_solution[j], temp_solution[(j+1)%n]])\n\n                    improvement += (old_dist - new_dist)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 95,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    n = len(base_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware edge swap\n    # Calculate the current objective values\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(base_solution)\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, try an alternative move\n    if all(new_o >= curr_o for new_o, curr_o in zip(new_obj, current_obj)):\n        # Try a different 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # If still worse, try a node insertion\n        if all(new_o >= curr_o for new_o, curr_o in zip(calculate_objective(new_solution), current_obj)):\n            k = np.random.randint(n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8275577498742848,
            0.9668006658554077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    n = len(base_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware edge swap\n    # Calculate the current objective values\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(base_solution)\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, try an alternative move\n    if all(new_o >= curr_o for new_o, curr_o in zip(new_obj, current_obj)):\n        # Try a different 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # If still worse, try a node insertion\n        if all(new_o >= curr_o for new_o, curr_o in zip(calculate_objective(new_solution), current_obj)):\n            k = np.random.randint(n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 96,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, min(start + 5, n - 1))  # Limit segment size for efficiency\n\n    # Apply a mix of 2-opt and 3-opt moves\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        # 2-opt move (swap two edges)\n        i, j = start, end\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move (more complex rearrangement)\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid TSP tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6636390515604405,
            0.7736024856567383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, min(start + 5, n - 1))  # Limit segment size for efficiency\n\n    # Apply a mix of 2-opt and 3-opt moves\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        # 2-opt move (swap two edges)\n        i, j = start, end\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move (more complex rearrangement)\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid TSP tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 97,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle 60% of the archive to balance exploration and exploitation\n        selection_pool = archive_sorted[int(len(archive) * 0.2):int(len(archive) * 0.8)]\n        selected_solution = random.choice(selection_pool)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Decide between 2-opt or node insertion based on a random choice\n        if random.random() < 0.5:\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion: remove a node and reinsert it elsewhere\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7921059164920077,
            0.8368338942527771
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle 60% of the archive to balance exploration and exploitation\n        selection_pool = archive_sorted[int(len(archive) * 0.2):int(len(archive) * 0.8)]\n        selected_solution = random.choice(selection_pool)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Decide between 2-opt or node insertion based on a random choice\n        if random.random() < 0.5:\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion: remove a node and reinsert it elsewhere\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 98,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective values\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the \"improvement potential\" as the sum of normalized objective values\n    normalized_objectives = np.array(archive_objectives)\n    if normalized_objectives.shape[0] > 1:\n        normalized_objectives = (normalized_objectives - np.min(normalized_objectives, axis=0)) / (np.max(normalized_objectives, axis=0) - np.min(normalized_objectives, axis=0) + 1e-10)\n    improvement_potential = np.sum(normalized_objectives, axis=1)\n\n    # Select the solution with highest improvement potential\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Try objective-aware swaps\n        if random.random() < 0.3:  # 30% chance to try objective-aware swap\n            # Find the node that would most improve the worst objective\n            worst_obj = np.argmax([delta_obj1, delta_obj2, delta_obj3])\n            if worst_obj == 0:\n                # Find node to swap with to improve objective 1\n                best_improvement = 0\n                best_k = -1\n                for k in range(i+1, j):\n                    improvement = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                                 distance_matrix_1[new_solution[k], new_solution[i]]) - \\\n                                (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                 distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n                    if improvement < best_improvement:\n                        best_improvement = improvement\n                        best_k = k\n                if best_k != -1:\n                    new_solution[i], new_solution[best_k] = new_solution[best_k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6755716207019652,
            1.1221715807914734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective values\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the \"improvement potential\" as the sum of normalized objective values\n    normalized_objectives = np.array(archive_objectives)\n    if normalized_objectives.shape[0] > 1:\n        normalized_objectives = (normalized_objectives - np.min(normalized_objectives, axis=0)) / (np.max(normalized_objectives, axis=0) - np.min(normalized_objectives, axis=0) + 1e-10)\n    improvement_potential = np.sum(normalized_objectives, axis=1)\n\n    # Select the solution with highest improvement potential\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Try objective-aware swaps\n        if random.random() < 0.3:  # 30% chance to try objective-aware swap\n            # Find the node that would most improve the worst objective\n            worst_obj = np.argmax([delta_obj1, delta_obj2, delta_obj3])\n            if worst_obj == 0:\n                # Find node to swap with to improve objective 1\n                best_improvement = 0\n                best_k = -1\n                for k in range(i+1, j):\n                    improvement = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                                 distance_matrix_1[new_solution[k], new_solution[i]]) - \\\n                                (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                 distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n                    if improvement < best_improvement:\n                        best_improvement = improvement\n                        best_k = k\n                if best_k != -1:\n                    new_solution[i], new_solution[best_k] = new_solution[best_k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 99,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_solution = None\n    for sol, obj in archive:\n        # Check if the solution is non-dominated and has room for improvement\n        if obj[0] > 0 or obj[1] > 0 or obj[2] > 0:  # Assuming 0 is not optimal\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt on the selected edges\n        temp = new_solution.copy()\n        temp[i:j+1] = temp[i:j+1][::-1]\n        temp[k:l+1] = temp[k:l+1][::-1]\n\n        # Calculate objective values for the new solution\n        obj1 = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[temp[i], temp[(i+1)%n]] for i in range(n))\n\n        # Accept the move if it improves at least one objective\n        if obj1 < sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) or \\\n           obj2 < sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) or \\\n           obj3 < sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)):\n            new_solution = temp\n\n    # Additional local search: try to improve by swapping nodes that are \"dominated\" in all objectives\n    for i in range(n):\n        for j in range(i+1, n):\n            a, b = new_solution[i], new_solution[j]\n            # Check if swapping a and b improves all objectives\n            if (distance_matrix_1[a, new_solution[(i-1)%n]] + distance_matrix_1[b, new_solution[(i+1)%n]] <\n                distance_matrix_1[a, new_solution[(i-1)%n]] + distance_matrix_1[a, new_solution[(i+1)%n]]) and \\\n               (distance_matrix_2[a, new_solution[(i-1)%n]] + distance_matrix_2[b, new_solution[(i+1)%n]] <\n                distance_matrix_2[a, new_solution[(i-1)%n]] + distance_matrix_2[a, new_solution[(i+1)%n]]) and \\\n               (distance_matrix_3[a, new_solution[(i-1)%n]] + distance_matrix_3[b, new_solution[(i+1)%n]] <\n                distance_matrix_3[a, new_solution[(i-1)%n]] + distance_matrix_3[a, new_solution[(i+1)%n]]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.68715235822793,
            3.026619243621826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_solution = None\n    for sol, obj in archive:\n        # Check if the solution is non-dominated and has room for improvement\n        if obj[0] > 0 or obj[1] > 0 or obj[2] > 0:  # Assuming 0 is not optimal\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt on the selected edges\n        temp = new_solution.copy()\n        temp[i:j+1] = temp[i:j+1][::-1]\n        temp[k:l+1] = temp[k:l+1][::-1]\n\n        # Calculate objective values for the new solution\n        obj1 = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[temp[i], temp[(i+1)%n]] for i in range(n))\n\n        # Accept the move if it improves at least one objective\n        if obj1 < sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) or \\\n           obj2 < sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) or \\\n           obj3 < sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)):\n            new_solution = temp\n\n    # Additional local search: try to improve by swapping nodes that are \"dominated\" in all objectives\n    for i in range(n):\n        for j in range(i+1, n):\n            a, b = new_solution[i], new_solution[j]\n            # Check if swapping a and b improves all objectives\n            if (distance_matrix_1[a, new_solution[(i-1)%n]] + distance_matrix_1[b, new_solution[(i+1)%n]] <\n                distance_matrix_1[a, new_solution[(i-1)%n]] + distance_matrix_1[a, new_solution[(i+1)%n]]) and \\\n               (distance_matrix_2[a, new_solution[(i-1)%n]] + distance_matrix_2[b, new_solution[(i+1)%n]] <\n                distance_matrix_2[a, new_solution[(i-1)%n]] + distance_matrix_2[a, new_solution[(i+1)%n]]) and \\\n               (distance_matrix_3[a, new_solution[(i-1)%n]] + distance_matrix_3[b, new_solution[(i+1)%n]] <\n                distance_matrix_3[a, new_solution[(i-1)%n]] + distance_matrix_3[a, new_solution[(i+1)%n]]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 100,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_objective = archive[selected_idx][1]\n\n    # Calculate the total distance for each objective\n    total_dist_1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n    total_dist_2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n    total_dist_3 = sum(distance_matrix_3[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n\n    # Identify the worst objective (highest distance)\n    worst_obj = np.argmax([total_dist_1, total_dist_2, total_dist_3])\n\n    # Apply a hybrid local search operator tailored to the worst objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random positions to modify\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Apply a 2-opt move if it improves the worst objective\n    if worst_obj == 0:\n        current_dist = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_dist = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        if new_dist < current_dist:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    elif worst_obj == 1:\n        current_dist = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_dist = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n        if new_dist < current_dist:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        current_dist = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_dist = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n        if new_dist < current_dist:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Also consider a swap move for additional improvement\n    k, l = np.random.choice(n, size=2, replace=False)\n    if worst_obj == 0:\n        current_dist = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_dist = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        if new_dist < current_dist:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    elif worst_obj == 1:\n        current_dist = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_dist = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n        if new_dist < current_dist:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    else:\n        current_dist = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n        new_dist = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n        if new_dist < current_dist:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7017678589613263,
            1.311839485168457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_objective = archive[selected_idx][1]\n\n    # Calculate the total distance for each objective\n    total_dist_1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n    total_dist_2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n    total_dist_3 = sum(distance_matrix_3[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n\n    # Identify the worst objective (highest distance)\n    worst_obj = np.argmax([total_dist_1, total_dist_2, total_dist_3])\n\n    # Apply a hybrid local search operator tailored to the worst objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random positions to modify\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Apply a 2-opt move if it improves the worst objective\n    if worst_obj == 0:\n        current_dist = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_dist = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        if new_dist < current_dist:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    elif worst_obj == 1:\n        current_dist = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_dist = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n        if new_dist < current_dist:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        current_dist = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_dist = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n        if new_dist < current_dist:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Also consider a swap move for additional improvement\n    k, l = np.random.choice(n, size=2, replace=False)\n    if worst_obj == 0:\n        current_dist = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_dist = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        if new_dist < current_dist:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    elif worst_obj == 1:\n        current_dist = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_dist = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n        if new_dist < current_dist:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    else:\n        current_dist = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n        new_dist = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n        if new_dist < current_dist:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 101,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Sort by the sum of objectives to prioritize solutions with higher total cost (more room for improvement)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly select from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the most critical edge (highest sum of distances across objectives)\n    max_cost = -1\n    best_i, best_j = 0, 0\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the sum of distances in all three objectives for the current edge\n            cost = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                    distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                    distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # Also consider the potential new edges\n            cost -= (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]])\n\n            if cost > max_cost:\n                max_cost = cost\n                best_i, best_j = i, j\n\n    # Apply the 2-opt move if it improves the sum of objectives\n    if max_cost > 0:\n        new_solution[best_i+1:best_j+1] = np.flip(new_solution[best_i+1:best_j+1])\n\n    # Additional multi-objective perturbation: swap nodes that are diverse in their objectives\n    if np.random.random() < 0.3:  # 30% chance to apply this perturbation\n        # Find nodes with highest diversity in their objective contributions\n        diversity_scores = []\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate the diversity as the sum of absolute differences in edge costs\n            diversity = (abs(distance_matrix_1[prev_node, node] - distance_matrix_2[prev_node, node]) +\n                         abs(distance_matrix_1[node, next_node] - distance_matrix_2[node, next_node]) +\n                         abs(distance_matrix_3[prev_node, node] - distance_matrix_3[node, next_node]))\n            diversity_scores.append(diversity)\n\n        # Select nodes with highest diversity and swap them\n        if n > 1:\n            sorted_indices = np.argsort(diversity_scores)[::-1]\n            swap_a = sorted_indices[0]\n            swap_b = sorted_indices[1]\n            new_solution[swap_a], new_solution[swap_b] = new_solution[swap_b], new_solution[swap_a]\n\n    return new_solution\n\n",
        "score": [
            -0.6771411236956777,
            2.8273690581321715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Sort by the sum of objectives to prioritize solutions with higher total cost (more room for improvement)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly select from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the most critical edge (highest sum of distances across objectives)\n    max_cost = -1\n    best_i, best_j = 0, 0\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the sum of distances in all three objectives for the current edge\n            cost = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                    distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                    distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # Also consider the potential new edges\n            cost -= (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]])\n\n            if cost > max_cost:\n                max_cost = cost\n                best_i, best_j = i, j\n\n    # Apply the 2-opt move if it improves the sum of objectives\n    if max_cost > 0:\n        new_solution[best_i+1:best_j+1] = np.flip(new_solution[best_i+1:best_j+1])\n\n    # Additional multi-objective perturbation: swap nodes that are diverse in their objectives\n    if np.random.random() < 0.3:  # 30% chance to apply this perturbation\n        # Find nodes with highest diversity in their objective contributions\n        diversity_scores = []\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate the diversity as the sum of absolute differences in edge costs\n            diversity = (abs(distance_matrix_1[prev_node, node] - distance_matrix_2[prev_node, node]) +\n                         abs(distance_matrix_1[node, next_node] - distance_matrix_2[node, next_node]) +\n                         abs(distance_matrix_3[prev_node, node] - distance_matrix_3[node, next_node]))\n            diversity_scores.append(diversity)\n\n        # Select nodes with highest diversity and swap them\n        if n > 1:\n            sorted_indices = np.argsort(diversity_scores)[::-1]\n            swap_a = sorted_indices[0]\n            swap_b = sorted_indices[1]\n            new_solution[swap_a], new_solution[swap_b] = new_solution[swap_b], new_solution[swap_a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 102,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    objectives = archive_sorted[0][1]\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        # If first objective is worst, swap nodes that improve it most\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                improvement = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                              distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]) - \\\n                             (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                              distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # Similar for second objective\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                improvement = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                              distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]) - \\\n                             (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                              distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Similar for third objective\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                improvement = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                              distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]) - \\\n                             (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                              distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.66202391904294,
            2.44307701587677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    objectives = archive_sorted[0][1]\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        # If first objective is worst, swap nodes that improve it most\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                improvement = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                              distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]) - \\\n                             (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                              distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # Similar for second objective\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                improvement = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                              distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]) - \\\n                             (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                              distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Similar for third objective\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                improvement = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                              distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]) - \\\n                             (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                              distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 103,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or poor objectives to encourage improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, apply standard 2-opt to improve the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    max_edge = -1\n    max_edge_idx = -1\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        if dist_matrix[u, v] > max_edge:\n            max_edge = dist_matrix[u, v]\n            max_edge_idx = i\n\n    # Perform 2-opt on the worst edge\n    if max_edge_idx != -1:\n        i = max_edge_idx\n        j = (i + 1) % n\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Then apply a novel multi-objective edge swap\n    # Select two random edges and swap their nodes if it improves all objectives\n    a, b = np.random.choice(n, 2, replace=False)\n    c, d = (a + 1) % n, (b + 1) % n\n\n    # Current edges: (a,b) and (c,d)\n    current_cost = (\n        distance_matrix_1[new_solution[a], new_solution[b]] +\n        distance_matrix_2[new_solution[a], new_solution[b]] +\n        distance_matrix_3[new_solution[a], new_solution[b]] +\n        distance_matrix_1[new_solution[c], new_solution[d]] +\n        distance_matrix_2[new_solution[c], new_solution[d]] +\n        distance_matrix_3[new_solution[c], new_solution[d]]\n    )\n\n    # Proposed edges: (a,d) and (b,c)\n    proposed_cost = (\n        distance_matrix_1[new_solution[a], new_solution[d]] +\n        distance_matrix_2[new_solution[a], new_solution[d]] +\n        distance_matrix_3[new_solution[a], new_solution[d]] +\n        distance_matrix_1[new_solution[b], new_solution[c]] +\n        distance_matrix_2[new_solution[b], new_solution[c]] +\n        distance_matrix_3[new_solution[b], new_solution[c]]\n    )\n\n    if proposed_cost < current_cost:\n        # Perform the swap\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.7306784586230626,
            1.251533830165863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or poor objectives to encourage improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, apply standard 2-opt to improve the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    max_edge = -1\n    max_edge_idx = -1\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        if dist_matrix[u, v] > max_edge:\n            max_edge = dist_matrix[u, v]\n            max_edge_idx = i\n\n    # Perform 2-opt on the worst edge\n    if max_edge_idx != -1:\n        i = max_edge_idx\n        j = (i + 1) % n\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Then apply a novel multi-objective edge swap\n    # Select two random edges and swap their nodes if it improves all objectives\n    a, b = np.random.choice(n, 2, replace=False)\n    c, d = (a + 1) % n, (b + 1) % n\n\n    # Current edges: (a,b) and (c,d)\n    current_cost = (\n        distance_matrix_1[new_solution[a], new_solution[b]] +\n        distance_matrix_2[new_solution[a], new_solution[b]] +\n        distance_matrix_3[new_solution[a], new_solution[b]] +\n        distance_matrix_1[new_solution[c], new_solution[d]] +\n        distance_matrix_2[new_solution[c], new_solution[d]] +\n        distance_matrix_3[new_solution[c], new_solution[d]]\n    )\n\n    # Proposed edges: (a,d) and (b,c)\n    proposed_cost = (\n        distance_matrix_1[new_solution[a], new_solution[d]] +\n        distance_matrix_2[new_solution[a], new_solution[d]] +\n        distance_matrix_3[new_solution[a], new_solution[d]] +\n        distance_matrix_1[new_solution[b], new_solution[c]] +\n        distance_matrix_2[new_solution[b], new_solution[c]] +\n        distance_matrix_3[new_solution[b], new_solution[c]]\n    )\n\n    if proposed_cost < current_cost:\n        # Perform the swap\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 104,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are not too good (not the best in all objectives)\n    # but have room for improvement in at least one objective\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives)\n\n    # Calculate the \"improvement potential\" score for each solution\n    # This is based on how far each solution is from the best in each objective\n    best_objectives = np.min(normalized_objectives, axis=0)\n    improvement_potential = np.sum(normalized_objectives - best_objectives, axis=1)\n\n    # Select the solution with the highest improvement potential\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First try a 2-opt move on the objective with the highest improvement potential\n    obj_idx = np.argmax(normalized_objectives[selected_idx] - best_objectives)\n    if obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for this objective\n    best_delta = 0\n    best_i, best_j = 0, 0\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the delta for this 2-opt move\n            delta = (distance_matrix[new_solution[i], new_solution[j]] +\n                     distance_matrix[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix[new_solution[i], new_solution[i+1]] +\n                     distance_matrix[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_delta < 0:  # If improvement found\n        # Apply the 2-opt move\n        new_solution[best_i+1:best_j+1] = np.flip(new_solution[best_i+1:best_j+1])\n    else:\n        # If no improvement from 2-opt, try a 3-opt move\n        best_delta = 0\n        best_a, best_b, best_c = 0, 0, 0\n        for a in range(n - 2):\n            for b in range(a + 2, n - 1):\n                for c in range(b + 2, n):\n                    # Calculate the delta for this 3-opt move\n                    # There are 8 possible configurations for 3-opt, we try the most common one\n                    delta = (distance_matrix[new_solution[a], new_solution[b]] +\n                             distance_matrix[new_solution[c], new_solution[(a+1)%n]]) - \\\n                            (distance_matrix[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix[new_solution[c], new_solution[b]])\n\n                    if delta < best_delta:\n                        best_delta = delta\n                        best_a, best_b, best_c = a, b, c\n\n        if best_delta < 0:  # If improvement found\n            # Apply the 3-opt move (one of the possible configurations)\n            # This is a simplified version - a full implementation would need to handle all 8 cases\n            segment1 = new_solution[best_a+1:best_b+1]\n            segment2 = new_solution[best_b+1:best_c+1]\n            new_solution[best_a+1:best_c+1] = np.concatenate([np.flip(segment2), np.flip(segment1)])\n\n    return new_solution\n\n",
        "score": [
            -0.6795412206810598,
            1.847210955619812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are not too good (not the best in all objectives)\n    # but have room for improvement in at least one objective\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives)\n\n    # Calculate the \"improvement potential\" score for each solution\n    # This is based on how far each solution is from the best in each objective\n    best_objectives = np.min(normalized_objectives, axis=0)\n    improvement_potential = np.sum(normalized_objectives - best_objectives, axis=1)\n\n    # Select the solution with the highest improvement potential\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First try a 2-opt move on the objective with the highest improvement potential\n    obj_idx = np.argmax(normalized_objectives[selected_idx] - best_objectives)\n    if obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for this objective\n    best_delta = 0\n    best_i, best_j = 0, 0\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the delta for this 2-opt move\n            delta = (distance_matrix[new_solution[i], new_solution[j]] +\n                     distance_matrix[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix[new_solution[i], new_solution[i+1]] +\n                     distance_matrix[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_delta < 0:  # If improvement found\n        # Apply the 2-opt move\n        new_solution[best_i+1:best_j+1] = np.flip(new_solution[best_i+1:best_j+1])\n    else:\n        # If no improvement from 2-opt, try a 3-opt move\n        best_delta = 0\n        best_a, best_b, best_c = 0, 0, 0\n        for a in range(n - 2):\n            for b in range(a + 2, n - 1):\n                for c in range(b + 2, n):\n                    # Calculate the delta for this 3-opt move\n                    # There are 8 possible configurations for 3-opt, we try the most common one\n                    delta = (distance_matrix[new_solution[a], new_solution[b]] +\n                             distance_matrix[new_solution[c], new_solution[(a+1)%n]]) - \\\n                            (distance_matrix[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix[new_solution[c], new_solution[b]])\n\n                    if delta < best_delta:\n                        best_delta = delta\n                        best_a, best_b, best_c = a, b, c\n\n        if best_delta < 0:  # If improvement found\n            # Apply the 3-opt move (one of the possible configurations)\n            # This is a simplified version - a full implementation would need to handle all 8 cases\n            segment1 = new_solution[best_a+1:best_b+1]\n            segment2 = new_solution[best_b+1:best_c+1]\n            new_solution[best_a+1:best_c+1] = np.concatenate([np.flip(segment2), np.flip(segment1)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 105,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    weights = [v / sum(variances) for v in variances] if sum(variances) > 0 else [1/len(archive)] * len(archive)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt local search with objective-aware perturbation\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        # Apply 2-opt swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware perturbation: randomly select one objective and bias the swap\n        obj_idx = random.randint(0, 2)\n        if obj_idx == 0:\n            # Perturb based on first objective\n            if distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] > \\\n               distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]:\n                new_solution[i:j] = new_solution[i:j][::-1]\n        elif obj_idx == 1:\n            # Perturb based on second objective\n            if distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] > \\\n               distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]:\n                new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Perturb based on third objective\n            if distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] > \\\n               distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7125094838585844,
            3.466031086444855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    weights = [v / sum(variances) for v in variances] if sum(variances) > 0 else [1/len(archive)] * len(archive)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt local search with objective-aware perturbation\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        # Apply 2-opt swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware perturbation: randomly select one objective and bias the swap\n        obj_idx = random.randint(0, 2)\n        if obj_idx == 0:\n            # Perturb based on first objective\n            if distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] > \\\n               distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]:\n                new_solution[i:j] = new_solution[i:j][::-1]\n        elif obj_idx == 1:\n            # Perturb based on second objective\n            if distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] > \\\n               distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]:\n                new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Perturb based on third objective\n            if distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] > \\\n               distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 106,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here we randomly select among the top 30% of solutions in the archive\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:max(1, int(0.3 * len(archive)))]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a custom operator that considers all three objectives\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a custom operator that considers all three objectives\n    # This operator tries to improve the solution by considering the trade-offs between objectives\n    for _ in range(2):  # Apply the custom operator a few times\n        # Select a random segment of the tour\n        k = np.random.randint(1, n-2)\n        l = np.random.randint(k+1, n)\n\n        # Calculate the current cost of the segment in all three objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(k, l))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(k, l))\n        current_cost3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(k, l))\n\n        # Try reversing the segment\n        reversed_segment = new_solution[k:l+1][::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost3 = sum(distance_matrix_3[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept the reversal if it improves at least one objective without worsening the others too much\n        if (reversed_cost1 <= current_cost1 and reversed_cost2 <= current_cost2 and reversed_cost3 <= current_cost3) or \\\n           (np.random.rand() < 0.3):  # Small probability to accept non-dominated solutions\n            new_solution[k:l+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7526385494209669,
            1.245957851409912
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here we randomly select among the top 30% of solutions in the archive\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:max(1, int(0.3 * len(archive)))]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a custom operator that considers all three objectives\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a custom operator that considers all three objectives\n    # This operator tries to improve the solution by considering the trade-offs between objectives\n    for _ in range(2):  # Apply the custom operator a few times\n        # Select a random segment of the tour\n        k = np.random.randint(1, n-2)\n        l = np.random.randint(k+1, n)\n\n        # Calculate the current cost of the segment in all three objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(k, l))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(k, l))\n        current_cost3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(k, l))\n\n        # Try reversing the segment\n        reversed_segment = new_solution[k:l+1][::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost3 = sum(distance_matrix_3[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept the reversal if it improves at least one objective without worsening the others too much\n        if (reversed_cost1 <= current_cost1 and reversed_cost2 <= current_cost2 and reversed_cost3 <= current_cost3) or \\\n           (np.random.rand() < 0.3):  # Small probability to accept non-dominated solutions\n            new_solution[k:l+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 107,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select a solution from the top 20% to encourage diversity\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt or 3-opt based on current solution's performance\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for 3-opt\n        # 3-opt: select three edges and perform a complex rearrangement\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5532117747528723,
            1.0977363348007203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select a solution from the top 20% to encourage diversity\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt or 3-opt based on current solution's performance\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for 3-opt\n        # 3-opt: select three edges and perform a complex rearrangement\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 108,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives (using hypervolume contribution as a proxy)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate edge costs in all three objectives\n    edge_costs = [\n        distance_matrix_1[base_solution[i-1], base_solution[i]] +\n        distance_matrix_1[base_solution[j-1], base_solution[j]],\n        distance_matrix_2[base_solution[i-1], base_solution[i]] +\n        distance_matrix_2[base_solution[j-1], base_solution[j]],\n        distance_matrix_3[base_solution[i-1], base_solution[i]] +\n        distance_matrix_3[base_solution[j-1], base_solution[j]]\n    ]\n\n    # Objective-aware selection: prefer edges that are better in at least one objective\n    if np.random.rand() < 0.7:  # 70% chance to do 2-opt\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    else:  # 30% chance to do a more sophisticated move\n        # Find the most promising segment to reverse based on objective improvement\n        best_improvement = -np.inf\n        best_segment = None\n\n        for k in range(1, n-1):\n            for l in range(k+1, n):\n                # Calculate potential improvement\n                current_cost = (distance_matrix_1[base_solution[k-1], base_solution[k]] +\n                               distance_matrix_1[base_solution[l-1], base_solution[l]])\n                new_cost = (distance_matrix_1[base_solution[k-1], base_solution[l]] +\n                           distance_matrix_1[base_solution[k], base_solution[l-1]])\n\n                improvement = current_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_segment = (k, l)\n\n        if best_segment:\n            k, l = best_segment\n            new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.760977603458432,
            1.206004226207733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives (using hypervolume contribution as a proxy)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate edge costs in all three objectives\n    edge_costs = [\n        distance_matrix_1[base_solution[i-1], base_solution[i]] +\n        distance_matrix_1[base_solution[j-1], base_solution[j]],\n        distance_matrix_2[base_solution[i-1], base_solution[i]] +\n        distance_matrix_2[base_solution[j-1], base_solution[j]],\n        distance_matrix_3[base_solution[i-1], base_solution[i]] +\n        distance_matrix_3[base_solution[j-1], base_solution[j]]\n    ]\n\n    # Objective-aware selection: prefer edges that are better in at least one objective\n    if np.random.rand() < 0.7:  # 70% chance to do 2-opt\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    else:  # 30% chance to do a more sophisticated move\n        # Find the most promising segment to reverse based on objective improvement\n        best_improvement = -np.inf\n        best_segment = None\n\n        for k in range(1, n-1):\n            for l in range(k+1, n):\n                # Calculate potential improvement\n                current_cost = (distance_matrix_1[base_solution[k-1], base_solution[k]] +\n                               distance_matrix_1[base_solution[l-1], base_solution[l]])\n                new_cost = (distance_matrix_1[base_solution[k-1], base_solution[l]] +\n                           distance_matrix_1[base_solution[k], base_solution[l-1]])\n\n                improvement = current_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_segment = (k, l)\n\n        if best_segment:\n            k, l = best_segment\n            new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 109,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already highly optimized)\n    # Here we select a solution with the highest sum of objectives (assuming worse solutions are more promising)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Evaluate the new solution's objectives\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # If the new solution is better in at least one objective, keep it\n        if (obj1 <= archive[selected_idx][1][0] or obj2 <= archive[selected_idx][1][1] or obj3 <= archive[selected_idx][1][2]):\n            break\n        else:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # If no improvement found, perform a more aggressive local search\n    if new_solution.tolist() == base_solution.tolist():\n        # Select two random nodes and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6797660092343188,
            0.6206833124160767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already highly optimized)\n    # Here we select a solution with the highest sum of objectives (assuming worse solutions are more promising)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Evaluate the new solution's objectives\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # If the new solution is better in at least one objective, keep it\n        if (obj1 <= archive[selected_idx][1][0] or obj2 <= archive[selected_idx][1][1] or obj3 <= archive[selected_idx][1][2]):\n            break\n        else:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # If no improvement found, perform a more aggressive local search\n    if new_solution.tolist() == base_solution.tolist():\n        # Select two random nodes and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 110,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more potential for improvement)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% solutions to increase diversity\n        top_solutions = sorted_solutions[:max(1, len(sorted_solutions) // 5)]\n        # Randomly select one of the top solutions\n        base_solution, _ = random.choice(top_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, apply a more sophisticated operator\n        operator = random.choice(['2opt', 'oropt', 'cross_exchange'])\n\n        if operator == '2opt':\n            # Randomly select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'oropt':\n            # Randomly select a segment and move it to another position\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            remaining = np.delete(new_solution, range(i, j))\n            k = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n        elif operator == 'cross_exchange':\n            # Randomly select two segments and exchange them\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([\n                new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]\n            ])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
        "score": [
            -0.5496366529690164,
            1.0783782839775085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more potential for improvement)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% solutions to increase diversity\n        top_solutions = sorted_solutions[:max(1, len(sorted_solutions) // 5)]\n        # Randomly select one of the top solutions\n        base_solution, _ = random.choice(top_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, apply a more sophisticated operator\n        operator = random.choice(['2opt', 'oropt', 'cross_exchange'])\n\n        if operator == '2opt':\n            # Randomly select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'oropt':\n            # Randomly select a segment and move it to another position\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            remaining = np.delete(new_solution, range(i, j))\n            k = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n        elif operator == 'cross_exchange':\n            # Randomly select two segments and exchange them\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[k:l]\n            new_solution = np.concatenate([\n                new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]\n            ])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 111,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply a combination of 2-opt and node swap\n    if random.random() < 0.5:\n        # 2-opt move for one objective\n        obj = random.randint(0, 2)\n        if obj == 0:\n            dm = distance_matrix_1\n        elif obj == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Check if 2-opt improves the selected objective\n        if dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j-1], new_solution[j]] > dm[new_solution[i-1], new_solution[j-1]] + dm[new_solution[i], new_solution[j]]:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node swap for all objectives\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        return selected_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.6798779256509123,
            1.034759521484375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply a combination of 2-opt and node swap\n    if random.random() < 0.5:\n        # 2-opt move for one objective\n        obj = random.randint(0, 2)\n        if obj == 0:\n            dm = distance_matrix_1\n        elif obj == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Check if 2-opt improves the selected objective\n        if dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j-1], new_solution[j]] > dm[new_solution[i-1], new_solution[j-1]] + dm[new_solution[i], new_solution[j]]:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node swap for all objectives\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        return selected_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 112,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt local search with multi-objective awareness\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Evaluate the current and reversed segment in all three objectives\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if the reversed segment improves at least one objective\n        if reversed_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform a multi-objective aware edge swap\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate cost for current edges\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost for swapped edges\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if the swap improves at least one objective\n        if swapped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5396928641708597,
            3.047958827018738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt local search with multi-objective awareness\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Evaluate the current and reversed segment in all three objectives\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if the reversed segment improves at least one objective\n        if reversed_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform a multi-objective aware edge swap\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate cost for current edges\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost for swapped edges\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if the swap improves at least one objective\n        if swapped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 113,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., high crowding distance or low dominance)\n    # Here, we select a random solution from the archive for simplicity\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)  # index of the worst objective\n\n    # Choose distance matrix based on the worst objective\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the edge with the highest cost in the worst objective space\n    max_cost = -1\n    best_i, best_j = 0, 0\n    for i in range(n):\n        j = (i + 1) % n\n        cost = distance_matrix[new_solution[i], new_solution[j]]\n        if cost > max_cost:\n            max_cost = cost\n            best_i, best_j = i, j\n\n    # Swap the nodes to reduce the worst objective cost\n    if best_i != best_j:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.7700529559418586,
            0.7955013513565063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., high crowding distance or low dominance)\n    # Here, we select a random solution from the archive for simplicity\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)  # index of the worst objective\n\n    # Choose distance matrix based on the worst objective\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the edge with the highest cost in the worst objective space\n    max_cost = -1\n    best_i, best_j = 0, 0\n    for i in range(n):\n        j = (i + 1) % n\n        cost = distance_matrix[new_solution[i], new_solution[j]]\n        if cost > max_cost:\n            max_cost = cost\n            best_i, best_j = i, j\n\n    # Swap the nodes to reduce the worst objective cost\n    if best_i != best_j:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 114,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average objective value to encourage diversity\n    selected_solution = max(archive, key=lambda x: np.mean(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    num_nodes = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly decide between 2-opt and edge insertion\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(num_nodes, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion local search\n        i = np.random.randint(0, num_nodes)\n        j = np.random.randint(0, num_nodes)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != num_nodes:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6901412336548524,
            2.4142192602157593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average objective value to encourage diversity\n    selected_solution = max(archive, key=lambda x: np.mean(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    num_nodes = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly decide between 2-opt and edge insertion\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(num_nodes, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion local search\n        i = np.random.randint(0, num_nodes)\n        j = np.random.randint(0, num_nodes)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != num_nodes:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 115,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    probabilities = np.exp(-scores)  # Higher scores get lower probabilities (inverse relationship)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Select a segment to reverse (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: try to improve edges in all three objectives\n    for _ in range(3):  # Number of attempts to improve\n        # Select a random edge to replace\n        k = random.randint(0, n-2)\n        a, b = base_solution[k], base_solution[k+1]\n\n        # Find the best possible replacement edge considering all three objectives\n        candidates = []\n        for m in range(n):\n            if m != k and m != k+1:\n                c, d = base_solution[m], base_solution[(m+1)%n]\n                # Calculate potential improvement in all three objectives\n                orig_cost = (distance_matrix_1[a][b] + distance_matrix_2[a][b] + distance_matrix_3[a][b] +\n                             distance_matrix_1[c][d] + distance_matrix_2[c][d] + distance_matrix_3[c][d])\n                new_cost = (distance_matrix_1[a][c] + distance_matrix_2[a][c] + distance_matrix_3[a][c] +\n                            distance_matrix_1[b][d] + distance_matrix_2[b][d] + distance_matrix_3[b][d])\n                improvement = orig_cost - new_cost\n                candidates.append((improvement, m))\n\n        if candidates:\n            candidates.sort(reverse=True, key=lambda x: x[0])\n            best_improvement, m = candidates[0]\n            if best_improvement > 0:  # Only accept if there's improvement\n                # Perform the edge swap\n                if k < m:\n                    new_solution[k+1:m+1] = base_solution[m:k:-1]\n                else:\n                    new_solution[k+1:] = base_solution[-1:k:-1]\n                    new_solution[:m+1] = base_solution[m::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6627379387454003,
            1.2718016862869264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    probabilities = np.exp(-scores)  # Higher scores get lower probabilities (inverse relationship)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Select a segment to reverse (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: try to improve edges in all three objectives\n    for _ in range(3):  # Number of attempts to improve\n        # Select a random edge to replace\n        k = random.randint(0, n-2)\n        a, b = base_solution[k], base_solution[k+1]\n\n        # Find the best possible replacement edge considering all three objectives\n        candidates = []\n        for m in range(n):\n            if m != k and m != k+1:\n                c, d = base_solution[m], base_solution[(m+1)%n]\n                # Calculate potential improvement in all three objectives\n                orig_cost = (distance_matrix_1[a][b] + distance_matrix_2[a][b] + distance_matrix_3[a][b] +\n                             distance_matrix_1[c][d] + distance_matrix_2[c][d] + distance_matrix_3[c][d])\n                new_cost = (distance_matrix_1[a][c] + distance_matrix_2[a][c] + distance_matrix_3[a][c] +\n                            distance_matrix_1[b][d] + distance_matrix_2[b][d] + distance_matrix_3[b][d])\n                improvement = orig_cost - new_cost\n                candidates.append((improvement, m))\n\n        if candidates:\n            candidates.sort(reverse=True, key=lambda x: x[0])\n            best_improvement, m = candidates[0]\n            if best_improvement > 0:  # Only accept if there's improvement\n                # Perform the edge swap\n                if k < m:\n                    new_solution[k+1:m+1] = base_solution[m:k:-1]\n                else:\n                    new_solution[k+1:] = base_solution[-1:k:-1]\n                    new_solution[:m+1] = base_solution[m::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 116,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance (promising for further improvement)\n    crowding_distances = []\n    for sol, obj in archive:\n        # Calculate crowding distance for each objective\n        sorted_objs = sorted([(obj[0], i) for i, (sol, obj) in enumerate(archive)], key=lambda x: x[0])\n        cd1 = abs(sorted_objs[1][0] - sorted_objs[-2][0]) / (sorted_objs[-1][0] - sorted_objs[0][0]) if len(sorted_objs) > 1 else 0\n\n        sorted_objs = sorted([(obj[1], i) for i, (sol, obj) in enumerate(archive)], key=lambda x: x[0])\n        cd2 = abs(sorted_objs[1][0] - sorted_objs[-2][0]) / (sorted_objs[-1][0] - sorted_objs[0][0]) if len(sorted_objs) > 1 else 0\n\n        sorted_objs = sorted([(obj[2], i) for i, (sol, obj) in enumerate(archive)], key=lambda x: x[0])\n        cd3 = abs(sorted_objs[1][0] - sorted_objs[-2][0]) / (sorted_objs[-1][0] - sorted_objs[0][0]) if len(sorted_objs) > 1 else 0\n\n        crowding_distances.append(cd1 + cd2 + cd3)\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the new solution is worse in any objective, try to improve it\n    for _ in range(3):\n        # Calculate current objectives\n        current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # Find the worst objective\n        worst_obj = np.argmax([current_obj1, current_obj2, current_obj3])\n\n        # Try to improve the worst objective with a local 2-opt\n        for _ in range(5):\n            a, b = sorted(random.sample(range(n), 2))\n            candidate = new_solution.copy()\n            candidate[a:b+1] = candidate[a:b+1][::-1]\n\n            # Calculate candidate objectives\n            candidate_obj1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            candidate_obj2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            candidate_obj3 = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Accept if improvement in the worst objective\n            if [candidate_obj1, candidate_obj2, candidate_obj3][worst_obj] < [current_obj1, current_obj2, current_obj3][worst_obj]:\n                new_solution = candidate\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6107277955936014,
            3.790488767623901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance (promising for further improvement)\n    crowding_distances = []\n    for sol, obj in archive:\n        # Calculate crowding distance for each objective\n        sorted_objs = sorted([(obj[0], i) for i, (sol, obj) in enumerate(archive)], key=lambda x: x[0])\n        cd1 = abs(sorted_objs[1][0] - sorted_objs[-2][0]) / (sorted_objs[-1][0] - sorted_objs[0][0]) if len(sorted_objs) > 1 else 0\n\n        sorted_objs = sorted([(obj[1], i) for i, (sol, obj) in enumerate(archive)], key=lambda x: x[0])\n        cd2 = abs(sorted_objs[1][0] - sorted_objs[-2][0]) / (sorted_objs[-1][0] - sorted_objs[0][0]) if len(sorted_objs) > 1 else 0\n\n        sorted_objs = sorted([(obj[2], i) for i, (sol, obj) in enumerate(archive)], key=lambda x: x[0])\n        cd3 = abs(sorted_objs[1][0] - sorted_objs[-2][0]) / (sorted_objs[-1][0] - sorted_objs[0][0]) if len(sorted_objs) > 1 else 0\n\n        crowding_distances.append(cd1 + cd2 + cd3)\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: if the new solution is worse in any objective, try to improve it\n    for _ in range(3):\n        # Calculate current objectives\n        current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # Find the worst objective\n        worst_obj = np.argmax([current_obj1, current_obj2, current_obj3])\n\n        # Try to improve the worst objective with a local 2-opt\n        for _ in range(5):\n            a, b = sorted(random.sample(range(n), 2))\n            candidate = new_solution.copy()\n            candidate[a:b+1] = candidate[a:b+1][::-1]\n\n            # Calculate candidate objectives\n            candidate_obj1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            candidate_obj2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            candidate_obj3 = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Accept if improvement in the worst objective\n            if [candidate_obj1, candidate_obj2, candidate_obj3][worst_obj] < [current_obj1, current_obj2, current_obj3][worst_obj]:\n                new_solution = candidate\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 117,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by sum of objectives (descending) to prioritize those with higher potential\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a multi-objective aware perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for one of the objectives (randomly chosen)\n    obj_choice = np.random.choice([0, 1, 2])\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation: swap two nodes based on their combined distance in all objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply perturbation\n        a, b = np.random.choice(n, 2, replace=False)\n        # Calculate combined distance before and after swap\n        before_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        after_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        # If swap doesn't improve combined distance, revert\n        if after_dist > before_dist:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6313269344079686,
            0.9946087598800659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by sum of objectives (descending) to prioritize those with higher potential\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a multi-objective aware perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for one of the objectives (randomly chosen)\n    obj_choice = np.random.choice([0, 1, 2])\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation: swap two nodes based on their combined distance in all objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply perturbation\n        a, b = np.random.choice(n, 2, replace=False)\n        # Calculate combined distance before and after swap\n        before_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        after_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        # If swap doesn't improve combined distance, revert\n        if after_dist > before_dist:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 118,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate the improvement potential for each objective\n    obj1_before = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n    obj2_before = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n    obj3_before = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n    # Try swapping nodes that are critical in any objective\n    critical_nodes = set()\n    for k in range(n):\n        if (distance_matrix_1[new_solution[k-1], new_solution[k]] > np.mean(distance_matrix_1) or\n            distance_matrix_2[new_solution[k-1], new_solution[k]] > np.mean(distance_matrix_2) or\n            distance_matrix_3[new_solution[k-1], new_solution[k]] > np.mean(distance_matrix_3)):\n            critical_nodes.add(k)\n\n    if len(critical_nodes) >= 2:\n        a, b = np.random.choice(list(critical_nodes), size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Verify the solution remains valid\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.727278433852708,
            2.3189735054969787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate the improvement potential for each objective\n    obj1_before = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n    obj2_before = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n    obj3_before = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n    # Try swapping nodes that are critical in any objective\n    critical_nodes = set()\n    for k in range(n):\n        if (distance_matrix_1[new_solution[k-1], new_solution[k]] > np.mean(distance_matrix_1) or\n            distance_matrix_2[new_solution[k-1], new_solution[k]] > np.mean(distance_matrix_2) or\n            distance_matrix_3[new_solution[k-1], new_solution[k]] > np.mean(distance_matrix_3)):\n            critical_nodes.add(k)\n\n    if len(critical_nodes) >= 2:\n        a, b = np.random.choice(list(critical_nodes), size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Verify the solution remains valid\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 119,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution based on objective values and diversity\n    scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Normalize objectives (assuming minimization)\n        norm_obj = np.array(obj) / (np.array(obj) + 1e-10)\n        # Score is a combination of objective values and diversity (inverse of crowding distance)\n        score = np.sum(norm_obj) + (1.0 / (len(archive) - i + 1))  # Simple diversity measure\n        scores.append(score)\n\n    # Select the solution with the highest score (best combination of objectives and diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random 2-opt move (standard local search)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Objective-aware 2-opt (consider all three objectives)\n    # Evaluate the move in all three objective spaces\n    def evaluate_move(a, b, c, d):\n        # Calculate change in all three objectives\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n        return delta1, delta2, delta3\n\n    # Try to find an improving move in any of the objectives\n    improved = False\n    for _ in range(10):  # Limit the number of trials\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        c, d = np.random.choice(n, size=2, replace=False)\n        if c > d:\n            c, d = d, c\n\n        # Evaluate the move\n        delta1, delta2, delta3 = evaluate_move(a, b, c, d)\n\n        # If the move improves any objective, accept it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Apply the move\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n            temp_solution[c:d+1] = temp_solution[c:d+1][::-1]\n            new_solution = temp_solution\n            improved = True\n            break\n\n    # If no improvement found, try a different type of move\n    if not improved:\n        # Step 3: Random insertion move\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.725271297381361,
            1.9867786526679994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution based on objective values and diversity\n    scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Normalize objectives (assuming minimization)\n        norm_obj = np.array(obj) / (np.array(obj) + 1e-10)\n        # Score is a combination of objective values and diversity (inverse of crowding distance)\n        score = np.sum(norm_obj) + (1.0 / (len(archive) - i + 1))  # Simple diversity measure\n        scores.append(score)\n\n    # Select the solution with the highest score (best combination of objectives and diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random 2-opt move (standard local search)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Objective-aware 2-opt (consider all three objectives)\n    # Evaluate the move in all three objective spaces\n    def evaluate_move(a, b, c, d):\n        # Calculate change in all three objectives\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n        return delta1, delta2, delta3\n\n    # Try to find an improving move in any of the objectives\n    improved = False\n    for _ in range(10):  # Limit the number of trials\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        c, d = np.random.choice(n, size=2, replace=False)\n        if c > d:\n            c, d = d, c\n\n        # Evaluate the move\n        delta1, delta2, delta3 = evaluate_move(a, b, c, d)\n\n        # If the move improves any objective, accept it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Apply the move\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n            temp_solution[c:d+1] = temp_solution[c:d+1][::-1]\n            new_solution = temp_solution\n            improved = True\n            break\n\n    # If no improvement found, try a different type of move\n    if not improved:\n        # Step 3: Random insertion move\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 120,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = min(3, max(1, len(archive_sorted) // 3))\n    selected_idx = random.randint(0, candidate_indices - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two non-adjacent edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    while j - i <= 1:  # Ensure edges are not adjacent\n        i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge selection: with 30% probability, select edges based on worst objective\n    if random.random() < 0.3:\n        # Calculate current objectives\n        current_obj1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_obj2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_obj3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        # Identify the worst objective\n        worst_obj = max((current_obj1, current_obj2, current_obj3))\n\n        # Find edges that improve the worst objective\n        improved = False\n        for _ in range(10):  # Try 10 times to find improvement\n            i, j = sorted(random.sample(range(n), 2))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n\n            temp_obj1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            temp_obj2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            temp_obj3 = sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            temp_worst = max(temp_obj1, temp_obj2, temp_obj3)\n\n            if temp_worst < worst_obj:\n                new_solution = temp_solution\n                improved = True\n                break\n\n        if not improved:\n            # If no improvement found, revert to original 2-opt\n            new_solution = base_solution.copy()\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7242055718016924,
            1.3389040946960449
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = min(3, max(1, len(archive_sorted) // 3))\n    selected_idx = random.randint(0, candidate_indices - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two non-adjacent edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    while j - i <= 1:  # Ensure edges are not adjacent\n        i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge selection: with 30% probability, select edges based on worst objective\n    if random.random() < 0.3:\n        # Calculate current objectives\n        current_obj1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_obj2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_obj3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        # Identify the worst objective\n        worst_obj = max((current_obj1, current_obj2, current_obj3))\n\n        # Find edges that improve the worst objective\n        improved = False\n        for _ in range(10):  # Try 10 times to find improvement\n            i, j = sorted(random.sample(range(n), 2))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n\n            temp_obj1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            temp_obj2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            temp_obj3 = sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            temp_worst = max(temp_obj1, temp_obj2, temp_obj3)\n\n            if temp_worst < worst_obj:\n                new_solution = temp_solution\n                improved = True\n                break\n\n        if not improved:\n            # If no improvement found, revert to original 2-opt\n            new_solution = base_solution.copy()\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 121,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and insertion moves\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # 2-opt move (for one objective)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Insertion move (for another objective)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Invalid solution generated\")\n\n    return new_solution\n\n",
        "score": [
            -0.6573565788753262,
            0.8446175456047058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and insertion moves\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # 2-opt move (for one objective)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Insertion move (for another objective)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Invalid solution generated\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 122,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for potential swaps\n    i, j = random.sample(range(n), 2)\n\n    # Calculate the change in all three objectives\n    def calculate_delta(sol, a, b):\n        # Calculate the change in tour length for all three objectives\n        prev_a = sol[a-1] if a > 0 else sol[-1]\n        next_a = sol[(a+1)%n]\n        prev_b = sol[b-1] if b > 0 else sol[-1]\n        next_b = sol[(b+1)%n]\n\n        delta_1 = (distance_matrix_1[prev_a, sol[b]] + distance_matrix_1[sol[b], next_a] +\n                   distance_matrix_1[prev_b, sol[a]] + distance_matrix_1[sol[a], next_b] -\n                   distance_matrix_1[prev_a, sol[a]] - distance_matrix_1[sol[a], next_a] -\n                   distance_matrix_1[prev_b, sol[b]] - distance_matrix_1[sol[b], next_b])\n\n        delta_2 = (distance_matrix_2[prev_a, sol[b]] + distance_matrix_2[sol[b], next_a] +\n                   distance_matrix_2[prev_b, sol[a]] + distance_matrix_2[sol[a], next_b] -\n                   distance_matrix_2[prev_a, sol[a]] - distance_matrix_2[sol[a], next_a] -\n                   distance_matrix_2[prev_b, sol[b]] - distance_matrix_2[sol[b], next_b])\n\n        delta_3 = (distance_matrix_3[prev_a, sol[b]] + distance_matrix_3[sol[b], next_a] +\n                   distance_matrix_3[prev_b, sol[a]] + distance_matrix_3[sol[a], next_b] -\n                   distance_matrix_3[prev_a, sol[a]] - distance_matrix_3[sol[a], next_a] -\n                   distance_matrix_3[prev_b, sol[b]] - distance_matrix_3[sol[b], next_b])\n\n        return (delta_1, delta_2, delta_3)\n\n    # Evaluate the swap\n    delta_1, delta_2, delta_3 = calculate_delta(new_solution, i, j)\n\n    # If the swap improves at least one objective, perform it\n    if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If no improvement, try a 2-opt move\n        a, b = sorted(random.sample(range(n), 2))\n        if a + 1 < b:\n            # Reverse the segment between a+1 and b\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n            # Check if the 2-opt move improves any objective\n            delta_1, delta_2, delta_3 = calculate_delta(new_solution, a, b)\n            if delta_1 >= 0 and delta_2 >= 0 and delta_3 >= 0:\n                # Undo if no improvement\n                new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6930154255906471,
            0.7486727118492127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for potential swaps\n    i, j = random.sample(range(n), 2)\n\n    # Calculate the change in all three objectives\n    def calculate_delta(sol, a, b):\n        # Calculate the change in tour length for all three objectives\n        prev_a = sol[a-1] if a > 0 else sol[-1]\n        next_a = sol[(a+1)%n]\n        prev_b = sol[b-1] if b > 0 else sol[-1]\n        next_b = sol[(b+1)%n]\n\n        delta_1 = (distance_matrix_1[prev_a, sol[b]] + distance_matrix_1[sol[b], next_a] +\n                   distance_matrix_1[prev_b, sol[a]] + distance_matrix_1[sol[a], next_b] -\n                   distance_matrix_1[prev_a, sol[a]] - distance_matrix_1[sol[a], next_a] -\n                   distance_matrix_1[prev_b, sol[b]] - distance_matrix_1[sol[b], next_b])\n\n        delta_2 = (distance_matrix_2[prev_a, sol[b]] + distance_matrix_2[sol[b], next_a] +\n                   distance_matrix_2[prev_b, sol[a]] + distance_matrix_2[sol[a], next_b] -\n                   distance_matrix_2[prev_a, sol[a]] - distance_matrix_2[sol[a], next_a] -\n                   distance_matrix_2[prev_b, sol[b]] - distance_matrix_2[sol[b], next_b])\n\n        delta_3 = (distance_matrix_3[prev_a, sol[b]] + distance_matrix_3[sol[b], next_a] +\n                   distance_matrix_3[prev_b, sol[a]] + distance_matrix_3[sol[a], next_b] -\n                   distance_matrix_3[prev_a, sol[a]] - distance_matrix_3[sol[a], next_a] -\n                   distance_matrix_3[prev_b, sol[b]] - distance_matrix_3[sol[b], next_b])\n\n        return (delta_1, delta_2, delta_3)\n\n    # Evaluate the swap\n    delta_1, delta_2, delta_3 = calculate_delta(new_solution, i, j)\n\n    # If the swap improves at least one objective, perform it\n    if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If no improvement, try a 2-opt move\n        a, b = sorted(random.sample(range(n), 2))\n        if a + 1 < b:\n            # Reverse the segment between a+1 and b\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n            # Check if the 2-opt move improves any objective\n            delta_1, delta_2, delta_3 = calculate_delta(new_solution, a, b)\n            if delta_1 >= 0 and delta_2 >= 0 and delta_3 >= 0:\n                # Undo if no improvement\n                new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 123,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity (most unique nodes in top segments)\n    def diversity_score(solution):\n        segments = [solution[:len(solution)//3], solution[len(solution)//3:2*len(solution)//3], solution[2*len(solution)//3:]]\n        unique_counts = [len(set(seg)) for seg in segments]\n        return sum(unique_counts)\n\n    archive_with_scores = [(sol, obj, diversity_score(sol)) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: x[2], reverse=True)\n    selected = archive_with_scores[0][0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 1. Multi-objective 2-opt with random objective selection\n        obj_choice = random.choice([1, 2, 3])\n        if obj_choice == 1:\n            dist_matrix = distance_matrix_1\n        elif obj_choice == 2:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        if dist_matrix[solution[i-1], solution[j]] + dist_matrix[solution[j], solution[i]] < dist_matrix[solution[i-1], solution[i]] + dist_matrix[solution[j], solution[j-1]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # 2. Multi-objective or-opt (random objective)\n        obj_choice = random.choice([1, 2, 3])\n        if obj_choice == 1:\n            dist_matrix = distance_matrix_1\n        elif obj_choice == 2:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        if dist_matrix[solution[i-1], solution[j]] + dist_matrix[solution[j], solution[i+1]] - dist_matrix[solution[i-1], solution[i]] < dist_matrix[solution[i-1], solution[i]] + dist_matrix[solution[i], solution[i+1]]:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n        # 3. Random swap for diversity\n        if random.random() < 0.3:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected)\n    return neighbor\n\n",
        "score": [
            -0.7390502428332055,
            1.588456678390503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity (most unique nodes in top segments)\n    def diversity_score(solution):\n        segments = [solution[:len(solution)//3], solution[len(solution)//3:2*len(solution)//3], solution[2*len(solution)//3:]]\n        unique_counts = [len(set(seg)) for seg in segments]\n        return sum(unique_counts)\n\n    archive_with_scores = [(sol, obj, diversity_score(sol)) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: x[2], reverse=True)\n    selected = archive_with_scores[0][0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 1. Multi-objective 2-opt with random objective selection\n        obj_choice = random.choice([1, 2, 3])\n        if obj_choice == 1:\n            dist_matrix = distance_matrix_1\n        elif obj_choice == 2:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        if dist_matrix[solution[i-1], solution[j]] + dist_matrix[solution[j], solution[i]] < dist_matrix[solution[i-1], solution[i]] + dist_matrix[solution[j], solution[j-1]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # 2. Multi-objective or-opt (random objective)\n        obj_choice = random.choice([1, 2, 3])\n        if obj_choice == 1:\n            dist_matrix = distance_matrix_1\n        elif obj_choice == 2:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        if dist_matrix[solution[i-1], solution[j]] + dist_matrix[solution[j], solution[i+1]] - dist_matrix[solution[i-1], solution[i]] < dist_matrix[solution[i-1], solution[i]] + dist_matrix[solution[i], solution[i+1]]:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n        # 3. Random swap for diversity\n        if random.random() < 0.3:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected)\n    return neighbor\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 124,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Select two random edges to perform 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Evaluate the move across all three objectives\n        def evaluate_move(sol, i, j):\n            original_cost = (distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_1[sol[j-1], sol[j]] +\n                             distance_matrix_2[sol[i-1], sol[i]] + distance_matrix_2[sol[j-1], sol[j]] +\n                             distance_matrix_3[sol[i-1], sol[i]] + distance_matrix_3[sol[j-1], sol[j]])\n            new_cost = (distance_matrix_1[sol[i-1], sol[j-1]] + distance_matrix_1[sol[i], sol[j]] +\n                         distance_matrix_2[sol[i-1], sol[j-1]] + distance_matrix_2[sol[i], sol[j]] +\n                         distance_matrix_3[sol[i-1], sol[j-1]] + distance_matrix_3[sol[i], sol[j]])\n            return new_cost < original_cost\n\n        if evaluate_move(new_solution, i, j):\n            # Perform 2-opt move\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Select three random points for 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Evaluate the move across all three objectives\n        def evaluate_3opt_move(sol, i, j, k):\n            original_cost = (distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_1[sol[j-1], sol[j]] + distance_matrix_1[sol[k-1], sol[k]] +\n                             distance_matrix_2[sol[i-1], sol[i]] + distance_matrix_2[sol[j-1], sol[j]] + distance_matrix_2[sol[k-1], sol[k]] +\n                             distance_matrix_3[sol[i-1], sol[i]] + distance_matrix_3[sol[j-1], sol[j]] + distance_matrix_3[sol[k-1], sol[k]])\n            # There are 4 possible configurations for 3-opt, we'll try the best one\n            configs = [\n                (sol[i:j][::-1], sol[j:k], sol[k:]),\n                (sol[i:j], sol[j:k][::-1], sol[k:]),\n                (sol[i:j], sol[j:k], sol[k:][::-1])\n            ]\n            best_config = None\n            best_cost = float('inf')\n\n            for config in configs:\n                temp_sol = np.concatenate((sol[:i], config[0], config[1], config[2], sol[k+1:]))\n                new_cost = (distance_matrix_1[temp_sol[i-1], temp_sol[i]] + distance_matrix_1[temp_sol[j-1], temp_sol[j]] + distance_matrix_1[temp_sol[k-1], temp_sol[k]] +\n                            distance_matrix_2[temp_sol[i-1], temp_sol[i]] + distance_matrix_2[temp_sol[j-1], temp_sol[j]] + distance_matrix_2[temp_sol[k-1], temp_sol[k]] +\n                            distance_matrix_3[temp_sol[i-1], temp_sol[i]] + distance_matrix_3[temp_sol[j-1], temp_sol[j]] + distance_matrix_3[temp_sol[k-1], temp_sol[k]])\n                if new_cost < best_cost:\n                    best_cost = new_cost\n                    best_config = config\n\n            return best_cost < original_cost, best_config\n\n        improvement, best_config = evaluate_3opt_move(new_solution, i, j, k)\n        if improvement:\n            # Perform the best 3-opt move\n            new_solution = np.concatenate((new_solution[:i], best_config[0], best_config[1], best_config[2], new_solution[k+1:]))\n\n    return new_solution\n\n",
        "score": [
            -0.5350042639373527,
            1.4845809936523438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Select two random edges to perform 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Evaluate the move across all three objectives\n        def evaluate_move(sol, i, j):\n            original_cost = (distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_1[sol[j-1], sol[j]] +\n                             distance_matrix_2[sol[i-1], sol[i]] + distance_matrix_2[sol[j-1], sol[j]] +\n                             distance_matrix_3[sol[i-1], sol[i]] + distance_matrix_3[sol[j-1], sol[j]])\n            new_cost = (distance_matrix_1[sol[i-1], sol[j-1]] + distance_matrix_1[sol[i], sol[j]] +\n                         distance_matrix_2[sol[i-1], sol[j-1]] + distance_matrix_2[sol[i], sol[j]] +\n                         distance_matrix_3[sol[i-1], sol[j-1]] + distance_matrix_3[sol[i], sol[j]])\n            return new_cost < original_cost\n\n        if evaluate_move(new_solution, i, j):\n            # Perform 2-opt move\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Select three random points for 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Evaluate the move across all three objectives\n        def evaluate_3opt_move(sol, i, j, k):\n            original_cost = (distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_1[sol[j-1], sol[j]] + distance_matrix_1[sol[k-1], sol[k]] +\n                             distance_matrix_2[sol[i-1], sol[i]] + distance_matrix_2[sol[j-1], sol[j]] + distance_matrix_2[sol[k-1], sol[k]] +\n                             distance_matrix_3[sol[i-1], sol[i]] + distance_matrix_3[sol[j-1], sol[j]] + distance_matrix_3[sol[k-1], sol[k]])\n            # There are 4 possible configurations for 3-opt, we'll try the best one\n            configs = [\n                (sol[i:j][::-1], sol[j:k], sol[k:]),\n                (sol[i:j], sol[j:k][::-1], sol[k:]),\n                (sol[i:j], sol[j:k], sol[k:][::-1])\n            ]\n            best_config = None\n            best_cost = float('inf')\n\n            for config in configs:\n                temp_sol = np.concatenate((sol[:i], config[0], config[1], config[2], sol[k+1:]))\n                new_cost = (distance_matrix_1[temp_sol[i-1], temp_sol[i]] + distance_matrix_1[temp_sol[j-1], temp_sol[j]] + distance_matrix_1[temp_sol[k-1], temp_sol[k]] +\n                            distance_matrix_2[temp_sol[i-1], temp_sol[i]] + distance_matrix_2[temp_sol[j-1], temp_sol[j]] + distance_matrix_2[temp_sol[k-1], temp_sol[k]] +\n                            distance_matrix_3[temp_sol[i-1], temp_sol[i]] + distance_matrix_3[temp_sol[j-1], temp_sol[j]] + distance_matrix_3[temp_sol[k-1], temp_sol[k]])\n                if new_cost < best_cost:\n                    best_cost = new_cost\n                    best_config = config\n\n            return best_cost < original_cost, best_config\n\n        improvement, best_config = evaluate_3opt_move(new_solution, i, j, k)\n        if improvement:\n            # Perform the best 3-opt move\n            new_solution = np.concatenate((new_solution[:i], best_config[0], best_config[1], best_config[2], new_solution[k+1:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 125,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # We prioritize solutions that are not too close to the Pareto front in any objective\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    normalized_objectives = objectives / avg_objectives\n\n    # Calculate a score for each solution based on how much it deviates from the average\n    scores = np.sum(np.abs(normalized_objectives - 1), axis=1)\n    probabilities = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply a combination of 2-opt and node insertion\n        # First, perform 2-opt on a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Then, perform a node insertion with a bias towards improving the worst objective\n        # Calculate current objectives\n        current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Identify the worst objective\n        worst_obj = np.argmax([current_obj1, current_obj2, current_obj3])\n\n        # Select a node to move\n        node_to_move = random.choice(new_solution[1:-1])  # Avoid moving first/last to simplify\n\n        # Find the best insertion point to improve the worst objective\n        best_improvement = 0\n        best_pos = -1\n\n        for pos in range(1, n):\n            if pos == node_to_move:\n                continue\n\n            # Create a candidate solution\n            candidate = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n            candidate = np.insert(candidate, pos, node_to_move)\n\n            # Calculate new objectives\n            new_obj1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            new_obj2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            new_obj3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n            # Calculate improvement for the worst objective\n            current_worst = [current_obj1, current_obj2, current_obj3][worst_obj]\n            new_worst = [new_obj1, new_obj2, new_obj3][worst_obj]\n            improvement = current_worst - new_worst\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the best insertion found\n            node_idx = np.where(new_solution == node_to_move)[0][0]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7286972590873778,
            3.1112222552299498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # We prioritize solutions that are not too close to the Pareto front in any objective\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    normalized_objectives = objectives / avg_objectives\n\n    # Calculate a score for each solution based on how much it deviates from the average\n    scores = np.sum(np.abs(normalized_objectives - 1), axis=1)\n    probabilities = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply a combination of 2-opt and node insertion\n        # First, perform 2-opt on a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Then, perform a node insertion with a bias towards improving the worst objective\n        # Calculate current objectives\n        current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Identify the worst objective\n        worst_obj = np.argmax([current_obj1, current_obj2, current_obj3])\n\n        # Select a node to move\n        node_to_move = random.choice(new_solution[1:-1])  # Avoid moving first/last to simplify\n\n        # Find the best insertion point to improve the worst objective\n        best_improvement = 0\n        best_pos = -1\n\n        for pos in range(1, n):\n            if pos == node_to_move:\n                continue\n\n            # Create a candidate solution\n            candidate = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n            candidate = np.insert(candidate, pos, node_to_move)\n\n            # Calculate new objectives\n            new_obj1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            new_obj2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            new_obj3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n            # Calculate improvement for the worst objective\n            current_worst = [current_obj1, current_obj2, current_obj3][worst_obj]\n            new_worst = [new_obj1, new_obj2, new_obj3][worst_obj]\n            improvement = current_worst - new_worst\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the best insertion found\n            node_idx = np.where(new_solution == node_to_move)[0][0]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 126,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest crowding distance in the Pareto front\n    def crowding_distance(archive):\n        objectives = np.array([obj for _, obj in archive])\n        distances = np.zeros(len(archive))\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                if sorted_obj[-1] == sorted_obj[0]:\n                    distances[sorted_idx[i]] += 0\n                else:\n                    distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply 2-opt and swap between objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and objective-based swap\n    if np.random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-based swap: identify nodes with high contribution to one objective\n        # and swap them with nodes that could improve other objectives\n        obj1 = archive[selected_idx][1][0]\n        obj2 = archive[selected_idx][1][1]\n        obj3 = archive[selected_idx][1][2]\n\n        # Calculate edge contributions to each objective\n        contributions = []\n        for i in range(n):\n            j = (i + 1) % n\n            node_i, node_j = new_solution[i], new_solution[j]\n            contrib1 = distance_matrix_1[node_i, node_j]\n            contrib2 = distance_matrix_2[node_i, node_j]\n            contrib3 = distance_matrix_3[node_i, node_j]\n            contributions.append((contrib1, contrib2, contrib3))\n\n        contributions = np.array(contributions)\n\n        # Find edges with high contribution to one objective\n        for m in range(3):\n            high_contrib_edges = np.where(contributions[:, m] > np.percentile(contributions[:, m], 75))[0]\n            if len(high_contrib_edges) > 0:\n                edge_idx = np.random.choice(high_contrib_edges)\n                # Find a node that could improve other objectives\n                for other_m in range(3):\n                    if other_m == m:\n                        continue\n                    low_contrib_nodes = np.where(contributions[:, other_m] < np.percentile(contributions[:, other_m], 25))[0]\n                    if len(low_contrib_nodes) > 0:\n                        node_idx = np.random.choice(low_contrib_nodes)\n                        # Swap the nodes\n                        new_solution[edge_idx], new_solution[node_idx] = new_solution[node_idx], new_solution[edge_idx]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7301206930985624,
            2.580658268928528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest crowding distance in the Pareto front\n    def crowding_distance(archive):\n        objectives = np.array([obj for _, obj in archive])\n        distances = np.zeros(len(archive))\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                if sorted_obj[-1] == sorted_obj[0]:\n                    distances[sorted_idx[i]] += 0\n                else:\n                    distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply 2-opt and swap between objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and objective-based swap\n    if np.random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-based swap: identify nodes with high contribution to one objective\n        # and swap them with nodes that could improve other objectives\n        obj1 = archive[selected_idx][1][0]\n        obj2 = archive[selected_idx][1][1]\n        obj3 = archive[selected_idx][1][2]\n\n        # Calculate edge contributions to each objective\n        contributions = []\n        for i in range(n):\n            j = (i + 1) % n\n            node_i, node_j = new_solution[i], new_solution[j]\n            contrib1 = distance_matrix_1[node_i, node_j]\n            contrib2 = distance_matrix_2[node_i, node_j]\n            contrib3 = distance_matrix_3[node_i, node_j]\n            contributions.append((contrib1, contrib2, contrib3))\n\n        contributions = np.array(contributions)\n\n        # Find edges with high contribution to one objective\n        for m in range(3):\n            high_contrib_edges = np.where(contributions[:, m] > np.percentile(contributions[:, m], 75))[0]\n            if len(high_contrib_edges) > 0:\n                edge_idx = np.random.choice(high_contrib_edges)\n                # Find a node that could improve other objectives\n                for other_m in range(3):\n                    if other_m == m:\n                        continue\n                    low_contrib_nodes = np.where(contributions[:, other_m] < np.percentile(contributions[:, other_m], 25))[0]\n                    if len(low_contrib_nodes) > 0:\n                        node_idx = np.random.choice(low_contrib_nodes)\n                        # Swap the nodes\n                        new_solution[edge_idx], new_solution[node_idx] = new_solution[node_idx], new_solution[edge_idx]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 127,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher objective values)\n    objectives = np.array([obj for _, obj in archive])\n    max_objectives = np.max(objectives, axis=0)\n    normalized_objectives = objectives / max_objectives\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with probability based on objective diversity\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(np.arange(1, n-1), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge insertion with probability based on objective diversity\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(np.arange(1, n-1), size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(np.arange(1, n-1), size=2, replace=False))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7279925944926294,
            0.9542475700378418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher objective values)\n    objectives = np.array([obj for _, obj in archive])\n    max_objectives = np.max(objectives, axis=0)\n    normalized_objectives = objectives / max_objectives\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with probability based on objective diversity\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(np.arange(1, n-1), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge insertion with probability based on objective diversity\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(np.arange(1, n-1), size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(np.arange(1, n-1), size=2, replace=False))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 128,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential score (inverse of objective values)\n    improvement_scores = [1 / (obj[0] + obj[1] + obj[2] + 1e-10) for obj in archive_objectives]\n    selected_idx = np.random.choice(len(archive), p=np.array(improvement_scores)/sum(improvement_scores))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select two random edges to potentially reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate potential improvement in all three objectives\n    def calculate_improvement(sol, i, j):\n        # Current edges in all three spaces\n        current_edges = [\n            (sol[i-1], sol[i]),\n            (sol[j], sol[j+1] if j+1 < n else sol[0]),\n            (sol[i-1], sol[j]),\n            (sol[i], sol[j+1] if j+1 < n else sol[0])\n        ]\n\n        # New edges if we reverse i to j\n        new_edges = [\n            (sol[i-1], sol[j]),\n            (sol[i], sol[j+1] if j+1 < n else sol[0]),\n            (sol[i-1], sol[i]),\n            (sol[j], sol[j+1] if j+1 < n else sol[0])\n        ]\n\n        # Calculate improvement in each objective\n        improvement = [0, 0, 0]\n        for k in range(4):\n            improvement[0] += distance_matrix_1[current_edges[k][0], current_edges[k][1]] - distance_matrix_1[new_edges[k][0], new_edges[k][1]]\n            improvement[1] += distance_matrix_2[current_edges[k][0], current_edges[k][1]] - distance_matrix_2[new_edges[k][0], new_edges[k][1]]\n            improvement[2] += distance_matrix_3[current_edges[k][0], current_edges[k][1]] - distance_matrix_3[new_edges[k][0], new_edges[k][1]]\n\n        return improvement\n\n    improvement = calculate_improvement(new_solution, i, j)\n\n    # If the move improves at least one objective, apply it\n    if any(imp > 0 for imp in improvement):\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional multi-objective edge swap (novel operator)\n    # Find the worst edge in each objective space\n    worst_edges = []\n    for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n        max_edge = -1\n        max_dist = -1\n        for k in range(n):\n            current = new_solution[k]\n            next_node = new_solution[k+1] if k+1 < n else new_solution[0]\n            dist = dm[current, next_node]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = k\n        worst_edges.append(max_edge)\n\n    # Select the most critical edge to improve (appears in most worst edges)\n    edge_counts = np.bincount(worst_edges, minlength=n)\n    critical_edge = np.argmax(edge_counts)\n\n    # Swap this edge with another random edge\n    swap_pos = np.random.choice(n)\n    new_solution[critical_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[critical_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.7309093305607747,
            1.3930700898170472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential score (inverse of objective values)\n    improvement_scores = [1 / (obj[0] + obj[1] + obj[2] + 1e-10) for obj in archive_objectives]\n    selected_idx = np.random.choice(len(archive), p=np.array(improvement_scores)/sum(improvement_scores))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select two random edges to potentially reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate potential improvement in all three objectives\n    def calculate_improvement(sol, i, j):\n        # Current edges in all three spaces\n        current_edges = [\n            (sol[i-1], sol[i]),\n            (sol[j], sol[j+1] if j+1 < n else sol[0]),\n            (sol[i-1], sol[j]),\n            (sol[i], sol[j+1] if j+1 < n else sol[0])\n        ]\n\n        # New edges if we reverse i to j\n        new_edges = [\n            (sol[i-1], sol[j]),\n            (sol[i], sol[j+1] if j+1 < n else sol[0]),\n            (sol[i-1], sol[i]),\n            (sol[j], sol[j+1] if j+1 < n else sol[0])\n        ]\n\n        # Calculate improvement in each objective\n        improvement = [0, 0, 0]\n        for k in range(4):\n            improvement[0] += distance_matrix_1[current_edges[k][0], current_edges[k][1]] - distance_matrix_1[new_edges[k][0], new_edges[k][1]]\n            improvement[1] += distance_matrix_2[current_edges[k][0], current_edges[k][1]] - distance_matrix_2[new_edges[k][0], new_edges[k][1]]\n            improvement[2] += distance_matrix_3[current_edges[k][0], current_edges[k][1]] - distance_matrix_3[new_edges[k][0], new_edges[k][1]]\n\n        return improvement\n\n    improvement = calculate_improvement(new_solution, i, j)\n\n    # If the move improves at least one objective, apply it\n    if any(imp > 0 for imp in improvement):\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional multi-objective edge swap (novel operator)\n    # Find the worst edge in each objective space\n    worst_edges = []\n    for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n        max_edge = -1\n        max_dist = -1\n        for k in range(n):\n            current = new_solution[k]\n            next_node = new_solution[k+1] if k+1 < n else new_solution[0]\n            dist = dm[current, next_node]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = k\n        worst_edges.append(max_edge)\n\n    # Select the most critical edge to improve (appears in most worst edges)\n    edge_counts = np.bincount(worst_edges, minlength=n)\n    critical_edge = np.argmax(edge_counts)\n\n    # Swap this edge with another random edge\n    swap_pos = np.random.choice(n)\n    new_solution[critical_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[critical_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 129,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # First, perform a 2-opt move to improve the most congested objective\n    def calculate_total_distance(sol):\n        dist1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        dist2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        dist3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (dist1, dist2, dist3)\n\n    current_distances = calculate_total_distance(new_solution)\n\n    # Find the most congested objective (highest distance)\n    max_obj = np.argmax(current_distances)\n\n    # Perform 2-opt on the most congested objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n-1):\n        for j in range(i+2, n):\n            # Calculate the change in distance for the most congested objective\n            old_dist = distance_matrix_1[new_solution[i], new_solution[i+1]] if max_obj == 0 else \\\n                       distance_matrix_2[new_solution[i], new_solution[i+1]] if max_obj == 1 else \\\n                       distance_matrix_3[new_solution[i], new_solution[i+1]]\n            old_dist += distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] if max_obj == 0 else \\\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] if max_obj == 1 else \\\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n            new_dist = distance_matrix_1[new_solution[i], new_solution[j]] if max_obj == 0 else \\\n                       distance_matrix_2[new_solution[i], new_solution[j]] if max_obj == 1 else \\\n                       distance_matrix_3[new_solution[i], new_solution[j]]\n            new_dist += distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] if max_obj == 0 else \\\n                        distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] if max_obj == 1 else \\\n                        distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        # Perform the 2-opt swap\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Then perform an objective-aware swap to balance the objectives\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate the new distances\n        new_distances = calculate_total_distance(temp_solution)\n\n        # Accept the swap if it improves at least one objective\n        if any(new_dist < current_dist for new_dist, current_dist in zip(new_distances, current_distances)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7566543809231192,
            1.9780354738235473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # First, perform a 2-opt move to improve the most congested objective\n    def calculate_total_distance(sol):\n        dist1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        dist2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        dist3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (dist1, dist2, dist3)\n\n    current_distances = calculate_total_distance(new_solution)\n\n    # Find the most congested objective (highest distance)\n    max_obj = np.argmax(current_distances)\n\n    # Perform 2-opt on the most congested objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n-1):\n        for j in range(i+2, n):\n            # Calculate the change in distance for the most congested objective\n            old_dist = distance_matrix_1[new_solution[i], new_solution[i+1]] if max_obj == 0 else \\\n                       distance_matrix_2[new_solution[i], new_solution[i+1]] if max_obj == 1 else \\\n                       distance_matrix_3[new_solution[i], new_solution[i+1]]\n            old_dist += distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] if max_obj == 0 else \\\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] if max_obj == 1 else \\\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n            new_dist = distance_matrix_1[new_solution[i], new_solution[j]] if max_obj == 0 else \\\n                       distance_matrix_2[new_solution[i], new_solution[j]] if max_obj == 1 else \\\n                       distance_matrix_3[new_solution[i], new_solution[j]]\n            new_dist += distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] if max_obj == 0 else \\\n                        distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] if max_obj == 1 else \\\n                        distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        # Perform the 2-opt swap\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Then perform an objective-aware swap to balance the objectives\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate the new distances\n        new_distances = calculate_total_distance(temp_solution)\n\n        # Accept the swap if it improves at least one objective\n        if any(new_dist < current_dist for new_dist, current_dist in zip(new_distances, current_distances)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 130,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = None\n    best_score = -1\n\n    for sol, obj in archive:\n        # Calculate a score based on the potential for improvement in all three objectives\n        improvement_potential = sum(obj)  # Sum of objectives (lower is better)\n        score = 1 / (1 + improvement_potential)  # Higher score for worse solutions (more potential)\n\n        if score > best_score:\n            best_score = score\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of 2-opt and random swap\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on a random segment\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for random swap\n        # Perform a random swap of two nodes\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7192446589606731,
            1.4118536233901977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = None\n    best_score = -1\n\n    for sol, obj in archive:\n        # Calculate a score based on the potential for improvement in all three objectives\n        improvement_potential = sum(obj)  # Sum of objectives (lower is better)\n        score = 1 / (1 + improvement_potential)  # Higher score for worse solutions (more potential)\n\n        if score > best_score:\n            best_score = score\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of 2-opt and random swap\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on a random segment\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for random swap\n        # Perform a random swap of two nodes\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 131,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity scores based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity_scores = np.sum(np.abs(objectives - mean_obj), axis=1)\n    probabilities = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (swap two non-adjacent edges)\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if i != j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform a 3-opt move (more complex rearrangement)\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    if a != b != c:\n        # Randomly choose one of the possible 3-opt configurations\n        config = random.randint(0, 7)\n        if config == 0:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n        elif config == 1:\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n        elif config == 2:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n        elif config == 3:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        elif config == 4:\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        elif config == 5:\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n        elif config == 6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        elif config == 7:\n            pass  # no change\n\n    # Finally, perform an objective-aware edge swap\n    # Find edges that are long in at least one objective space\n    for _ in range(3):  # Try a few swaps\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n        k = (j + 1) % n\n\n        # Calculate the cost of the current edges\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Calculate the cost of the proposed swap\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[k]] +\n                    distance_matrix_3[new_solution[i], new_solution[k]])\n\n        if new_cost < current_cost:\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.6702593511842062,
            1.2804773688316344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity scores based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity_scores = np.sum(np.abs(objectives - mean_obj), axis=1)\n    probabilities = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (swap two non-adjacent edges)\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if i != j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform a 3-opt move (more complex rearrangement)\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    if a != b != c:\n        # Randomly choose one of the possible 3-opt configurations\n        config = random.randint(0, 7)\n        if config == 0:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n        elif config == 1:\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n        elif config == 2:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n        elif config == 3:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        elif config == 4:\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        elif config == 5:\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n        elif config == 6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        elif config == 7:\n            pass  # no change\n\n    # Finally, perform an objective-aware edge swap\n    # Find edges that are long in at least one objective space\n    for _ in range(3):  # Try a few swaps\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n        k = (j + 1) % n\n\n        # Calculate the cost of the current edges\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Calculate the cost of the proposed swap\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[k]] +\n                    distance_matrix_3[new_solution[i], new_solution[k]])\n\n        if new_cost < current_cost:\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 132,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the average objective values\n    avg_obj = np.mean(objectives, axis=0)\n\n    # Select solutions that are above average in at least two objectives\n    promising_indices = [i for i, obj in enumerate(objectives)\n                        if sum(o > avg for o, avg in zip(obj, avg_obj)) >= 2]\n\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n\n    selected_idx = random.choice(promising_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: 2-opt with multi-objective awareness\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Additional multi-objective refinement: check if the swap improves any objective\n    original_obj = objectives[selected_idx]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    )\n\n    # If the new solution is worse in all objectives, revert to the original\n    if all(new > orig for new, orig in zip(new_obj, original_obj)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6713837580103149,
            2.6455100655555723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the average objective values\n    avg_obj = np.mean(objectives, axis=0)\n\n    # Select solutions that are above average in at least two objectives\n    promising_indices = [i for i, obj in enumerate(objectives)\n                        if sum(o > avg for o, avg in zip(obj, avg_obj)) >= 2]\n\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n\n    selected_idx = random.choice(promising_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: 2-opt with multi-objective awareness\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Additional multi-objective refinement: check if the swap improves any objective\n    original_obj = objectives[selected_idx]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    )\n\n    # If the new solution is worse in all objectives, revert to the original\n    if all(new > orig for new, orig in zip(new_obj, original_obj)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 133,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: combine 2-opt and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly decide between 2-opt and node insertion\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        node_to_move = np.random.choice(new_solution)\n        pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = np.random.randint(0, n)\n        new_solution = np.roll(new_solution, -pos)\n        new_solution = np.roll(new_solution, new_pos)\n        new_solution[0] = node_to_move\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(selected_solution)):\n        # Fallback to 2-opt if insertion fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6414439817713575,
            0.806734812259674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: combine 2-opt and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly decide between 2-opt and node insertion\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        node_to_move = np.random.choice(new_solution)\n        pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = np.random.randint(0, n)\n        new_solution = np.roll(new_solution, -pos)\n        new_solution = np.roll(new_solution, new_pos)\n        new_solution[0] = node_to_move\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(selected_solution)):\n        # Fallback to 2-opt if insertion fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * obj_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator combining 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the most constrained objective\n    obj1_total = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_total = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj3_total = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Identify the most constrained objective\n    most_constrained = np.argmax([obj1_total, obj2_total, obj3_total])\n\n    # Perform 2-opt on the most constrained objective\n    for _ in range(10):  # Limit iterations for efficiency\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Try reversing the segment between i and j\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Evaluate the new solution for the most constrained objective\n        if most_constrained == 0:\n            new_obj = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            if new_obj < obj1_total:\n                new_solution = candidate\n                obj1_total = new_obj\n        elif most_constrained == 1:\n            new_obj = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            if new_obj < obj2_total:\n                new_solution = candidate\n                obj2_total = new_obj\n        else:\n            new_obj = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            if new_obj < obj3_total:\n                new_solution = candidate\n                obj3_total = new_obj\n\n    # Then perform objective-aware swaps to balance the objectives\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_obj2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_obj3 = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if it improves at least one objective\n        if (new_obj1 <= obj1_total) or (new_obj2 <= obj2_total) or (new_obj3 <= obj3_total):\n            new_solution = candidate\n            obj1_total, obj2_total, obj3_total = new_obj1, new_obj2, new_obj3\n\n    return new_solution\n\n",
        "score": [
            -0.6583624718004506,
            2.509564733505249
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * obj_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator combining 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the most constrained objective\n    obj1_total = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_total = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj3_total = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Identify the most constrained objective\n    most_constrained = np.argmax([obj1_total, obj2_total, obj3_total])\n\n    # Perform 2-opt on the most constrained objective\n    for _ in range(10):  # Limit iterations for efficiency\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Try reversing the segment between i and j\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Evaluate the new solution for the most constrained objective\n        if most_constrained == 0:\n            new_obj = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            if new_obj < obj1_total:\n                new_solution = candidate\n                obj1_total = new_obj\n        elif most_constrained == 1:\n            new_obj = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            if new_obj < obj2_total:\n                new_solution = candidate\n                obj2_total = new_obj\n        else:\n            new_obj = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            if new_obj < obj3_total:\n                new_solution = candidate\n                obj3_total = new_obj\n\n    # Then perform objective-aware swaps to balance the objectives\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_obj2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_obj3 = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if it improves at least one objective\n        if (new_obj1 <= obj1_total) or (new_obj2 <= obj2_total) or (new_obj3 <= obj3_total):\n            new_solution = candidate\n            obj1_total, obj2_total, obj3_total = new_obj1, new_obj2, new_obj3\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 135,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% or at least 1 solution\n        selection_pool = archive_sorted[:max(1, int(0.3 * len(archive)))]\n        # Randomly select a solution from the pool\n        selected = random.choice(selection_pool)\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n > 2:\n        # Perform 2-opt move with probability 0.7\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Perform objective-aware swap with probability 0.5\n        if random.random() < 0.5:\n            # Calculate the current cost for each objective\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n                cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n                cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n                return (cost1, cost2, cost3)\n\n            current_cost = calculate_cost(new_solution)\n\n            # Try swapping nodes that would improve at least one objective\n            for _ in range(5):  # Try up to 5 random swaps\n                i, j = random.sample(range(n), 2)\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_cost = calculate_cost(temp_solution)\n\n                # Accept if at least one objective improves\n                if any(temp_cost[k] < current_cost[k] for k in range(3)):\n                    new_solution = temp_solution\n                    current_cost = temp_cost\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7477125339525432,
            0.7829169869422913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% or at least 1 solution\n        selection_pool = archive_sorted[:max(1, int(0.3 * len(archive)))]\n        # Randomly select a solution from the pool\n        selected = random.choice(selection_pool)\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n > 2:\n        # Perform 2-opt move with probability 0.7\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Perform objective-aware swap with probability 0.5\n        if random.random() < 0.5:\n            # Calculate the current cost for each objective\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n                cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n                cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n                return (cost1, cost2, cost3)\n\n            current_cost = calculate_cost(new_solution)\n\n            # Try swapping nodes that would improve at least one objective\n            for _ in range(5):  # Try up to 5 random swaps\n                i, j = random.sample(range(n), 2)\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_cost = calculate_cost(temp_solution)\n\n                # Accept if at least one objective improves\n                if any(temp_cost[k] < current_cost[k] for k in range(3)):\n                    new_solution = temp_solution\n                    current_cost = temp_cost\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 136,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    std_objectives = np.std(objectives, axis=0)\n\n    # Normalize objectives to identify solutions with high potential\n    normalized_objectives = [(obj - avg_objectives) / (std_objectives + 1e-8) for obj in objectives]\n    potential_scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n\n    # Select top 30% solutions with highest potential\n    top_indices = np.argsort(potential_scores)[-max(1, len(archive) // 3):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments of the tour for local search\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge exchange between k and l\n    if k != l and k + 1 != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    # Additional improvement: try to optimize for the worst objective\n    worst_obj_idx = np.argmax(archive[selected_idx][1])\n    if worst_obj_idx == 0:\n        current_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        current_matrix = distance_matrix_2\n    else:\n        current_matrix = distance_matrix_3\n\n    # Try to improve the worst objective with a 2-opt local search\n    improved = False\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a == b or a + 1 == b:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = current_matrix[new_solution[a-1], new_solution[a]] + current_matrix[new_solution[b-1], new_solution[b]]\n        new_dist = current_matrix[new_solution[a-1], new_solution[b-1]] + current_matrix[new_solution[a], new_solution[b]]\n\n        if new_dist < current_dist:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            improved = True\n\n    if not improved:\n        # If no improvement, try a different operator\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7852729195159693,
            1.4758691906929016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    std_objectives = np.std(objectives, axis=0)\n\n    # Normalize objectives to identify solutions with high potential\n    normalized_objectives = [(obj - avg_objectives) / (std_objectives + 1e-8) for obj in objectives]\n    potential_scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n\n    # Select top 30% solutions with highest potential\n    top_indices = np.argsort(potential_scores)[-max(1, len(archive) // 3):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments of the tour for local search\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge exchange between k and l\n    if k != l and k + 1 != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    # Additional improvement: try to optimize for the worst objective\n    worst_obj_idx = np.argmax(archive[selected_idx][1])\n    if worst_obj_idx == 0:\n        current_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        current_matrix = distance_matrix_2\n    else:\n        current_matrix = distance_matrix_3\n\n    # Try to improve the worst objective with a 2-opt local search\n    improved = False\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a == b or a + 1 == b:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = current_matrix[new_solution[a-1], new_solution[a]] + current_matrix[new_solution[b-1], new_solution[b]]\n        new_dist = current_matrix[new_solution[a-1], new_solution[b-1]] + current_matrix[new_solution[a], new_solution[b]]\n\n        if new_dist < current_dist:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            improved = True\n\n    if not improved:\n        # If no improvement, try a different operator\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a != b:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 137,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30% to avoid premature convergence\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Select two distinct edges based on their contribution to all three objectives\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n        # Calculate edge contributions across all three objectives\n        edge_contributions = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        # If the selected edges have high combined contribution, consider reversing\n        if sum(edge_contributions) > np.mean([sum(x[1]) for x in archive]):\n            # Perform 2-opt move\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n            # Verify feasibility (no duplicates)\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # If no improvement found, perform a random swap as fallback\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6542973141526953,
            1.998824143409729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30% to avoid premature convergence\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Select two distinct edges based on their contribution to all three objectives\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n        # Calculate edge contributions across all three objectives\n        edge_contributions = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        # If the selected edges have high combined contribution, consider reversing\n        if sum(edge_contributions) > np.mean([sum(x[1]) for x in archive]):\n            # Perform 2-opt move\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n            # Verify feasibility (no duplicates)\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # If no improvement found, perform a random swap as fallback\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(range(n), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 138,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Simple selection based on the worst objective (can be replaced with more sophisticated selection)\n        objectives = [obj for _, obj in archive]\n        worst_obj = max(objectives, key=lambda x: sum(x))\n        candidates = [sol for sol, obj in archive if sum(obj) == sum(worst_obj)]\n        base_solution = random.choice(candidates).copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too short, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two segments to swap or reverse based on objective improvements\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements for each objective\n        def calculate_improvement(solution, i1, i2):\n            # Calculate the change in tour length for each objective\n            delta1 = distance_matrix_1[solution[i1-1], solution[i2]] + distance_matrix_1[solution[i2], solution[(i1+1)%n]] - \\\n                     distance_matrix_1[solution[i1-1], solution[i1]] - distance_matrix_1[solution[i2], solution[i2-1]]\n            delta2 = distance_matrix_2[solution[i1-1], solution[i2]] + distance_matrix_2[solution[i2], solution[(i1+1)%n]] - \\\n                     distance_matrix_2[solution[i1-1], solution[i1]] - distance_matrix_2[solution[i2], solution[i2-1]]\n            delta3 = distance_matrix_3[solution[i1-1], solution[i2]] + distance_matrix_3[solution[i2], solution[(i1+1)%n]] - \\\n                     distance_matrix_3[solution[i1-1], solution[i1]] - distance_matrix_3[solution[i2], solution[i2-1]]\n            return delta1, delta2, delta3\n\n        # Evaluate two possible moves: swap segments or reverse one segment\n        delta_swap = calculate_improvement(new_solution, i, j)\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]  # Reverse segment\n        delta_reverse = calculate_improvement(temp_solution, k, l)\n\n        # Choose the move that improves at least one objective\n        if sum(delta_swap) < 0 or sum(delta_reverse) < 0:\n            if sum(delta_swap) < sum(delta_reverse):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            # If no improvement, perform a random move\n            if random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6912718780008694,
            1.1549945235252381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Simple selection based on the worst objective (can be replaced with more sophisticated selection)\n        objectives = [obj for _, obj in archive]\n        worst_obj = max(objectives, key=lambda x: sum(x))\n        candidates = [sol for sol, obj in archive if sum(obj) == sum(worst_obj)]\n        base_solution = random.choice(candidates).copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too short, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two segments to swap or reverse based on objective improvements\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements for each objective\n        def calculate_improvement(solution, i1, i2):\n            # Calculate the change in tour length for each objective\n            delta1 = distance_matrix_1[solution[i1-1], solution[i2]] + distance_matrix_1[solution[i2], solution[(i1+1)%n]] - \\\n                     distance_matrix_1[solution[i1-1], solution[i1]] - distance_matrix_1[solution[i2], solution[i2-1]]\n            delta2 = distance_matrix_2[solution[i1-1], solution[i2]] + distance_matrix_2[solution[i2], solution[(i1+1)%n]] - \\\n                     distance_matrix_2[solution[i1-1], solution[i1]] - distance_matrix_2[solution[i2], solution[i2-1]]\n            delta3 = distance_matrix_3[solution[i1-1], solution[i2]] + distance_matrix_3[solution[i2], solution[(i1+1)%n]] - \\\n                     distance_matrix_3[solution[i1-1], solution[i1]] - distance_matrix_3[solution[i2], solution[i2-1]]\n            return delta1, delta2, delta3\n\n        # Evaluate two possible moves: swap segments or reverse one segment\n        delta_swap = calculate_improvement(new_solution, i, j)\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]  # Reverse segment\n        delta_reverse = calculate_improvement(temp_solution, k, l)\n\n        # Choose the move that improves at least one objective\n        if sum(delta_swap) < 0 or sum(delta_reverse) < 0:\n            if sum(delta_swap) < sum(delta_reverse):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            # If no improvement, perform a random move\n            if random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 139,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores based on objective values\n    improvement_scores = []\n    for obj in objectives:\n        # Higher score means more potential for improvement (lower objective values)\n        score = 1.0 / (1.0 + sum(obj))\n        improvement_scores.append(score)\n\n    # Normalize scores to form a probability distribution\n    total_score = sum(improvement_scores)\n    if total_score == 0:\n        probabilities = [1.0 / len(improvement_scores) for _ in improvement_scores]\n    else:\n        probabilities = [score / total_score for score in improvement_scores]\n\n    # Select a base solution based on the probability distribution\n    base_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[base_idx].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Apply a combination of 2-opt and 3-opt moves\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and 3-opt with 50% probability\n        if np.random.random() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            # Apply the 3-opt move (one of the possible 3-opt transformations)\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8268774722851295,
            1.151142990589142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores based on objective values\n    improvement_scores = []\n    for obj in objectives:\n        # Higher score means more potential for improvement (lower objective values)\n        score = 1.0 / (1.0 + sum(obj))\n        improvement_scores.append(score)\n\n    # Normalize scores to form a probability distribution\n    total_score = sum(improvement_scores)\n    if total_score == 0:\n        probabilities = [1.0 / len(improvement_scores) for _ in improvement_scores]\n    else:\n        probabilities = [score / total_score for score in improvement_scores]\n\n    # Select a base solution based on the probability distribution\n    base_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[base_idx].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Apply a combination of 2-opt and 3-opt moves\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and 3-opt with 50% probability\n        if np.random.random() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            # Apply the 3-opt move (one of the possible 3-opt transformations)\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 140,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, selected_objective = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or multi-objective swap based on randomness\n        if random.random() < 0.7:\n            # 2-opt move: select two random non-adjacent edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            while j - i <= 1:\n                i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Multi-objective aware swap: select nodes that are far apart in at least one objective space\n            i, j = random.sample(range(n), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate distances in all three objective spaces\n            dist1 = distance_matrix_1[node_i, node_j]\n            dist2 = distance_matrix_2[node_i, node_j]\n            dist3 = distance_matrix_3[node_i, node_j]\n\n            # If the nodes are far apart in at least one space, swap them\n            if max(dist1, dist2, dist3) > np.mean([distance_matrix_1.mean(), distance_matrix_2.mean(), distance_matrix_3.mean()]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7852387355734537,
            0.9508913636207581
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, selected_objective = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or multi-objective swap based on randomness\n        if random.random() < 0.7:\n            # 2-opt move: select two random non-adjacent edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            while j - i <= 1:\n                i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Multi-objective aware swap: select nodes that are far apart in at least one objective space\n            i, j = random.sample(range(n), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate distances in all three objective spaces\n            dist1 = distance_matrix_1[node_i, node_j]\n            dist2 = distance_matrix_2[node_i, node_j]\n            dist3 = distance_matrix_3[node_i, node_j]\n\n            # If the nodes are far apart in at least one space, swap them\n            if max(dist1, dist2, dist3) > np.mean([distance_matrix_1.mean(), distance_matrix_2.mean(), distance_matrix_3.mean()]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 141,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the variance of each objective across the archive\n        objectives = np.array([obj for _, obj in archive])\n        variances = np.var(objectives, axis=0)\n        # Select solutions with high variance in any objective\n        candidate_indices = np.where(np.any(variances > np.median(variances), axis=0))[0]\n        if len(candidate_indices) > 0:\n            selected_index = random.choice(candidate_indices)\n            base_solution = archive[selected_index][0].copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply a weighted 2-opt move based on the objectives' importance\n    # 2. If no improvement, apply a 3-opt move for diversity\n\n    # Calculate weights based on objective values (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        weights = 1 - np.mean(normalized_objectives, axis=0)  # Higher weight for worse objectives\n    else:\n        weights = np.array([1.0, 1.0, 1.0])  # Equal weights if only one solution\n\n    # 2-opt move with weighted probability\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    # Calculate the change in cost for each objective\n    delta_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[j]] +\n        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n        distance_matrix_1[new_solution[i-1], new_solution[i]] -\n        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n        distance_matrix_2[new_solution[i-1], new_solution[i]] -\n        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n        distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n        distance_matrix_3[new_solution[i-1], new_solution[i]] -\n        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n    ]\n\n    # Weighted improvement check\n    weighted_improvement = sum(w * dc for w, dc in zip(weights, delta_costs))\n    if weighted_improvement > 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move for diversity\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Try different segment orderings\n        options = [\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]])\n        ]\n        # Evaluate all options\n        best_option = new_solution.copy()\n        best_weighted_improvement = 0\n        for option in options:\n            delta_costs = [\n                sum(distance_matrix_1[option[k-1], option[k]] for k in range(n)) - sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n                sum(distance_matrix_2[option[k-1], option[k]] for k in range(n)) - sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n                sum(distance_matrix_3[option[k-1], option[k]] for k in range(n)) - sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n            ]\n            current_weighted_improvement = sum(w * dc for w, dc in zip(weights, delta_costs))\n            if current_weighted_improvement > best_weighted_improvement:\n                best_weighted_improvement = current_weighted_improvement\n                best_option = option.copy()\n        new_solution = best_option\n\n    return new_solution\n\n",
        "score": [
            -0.6745246838356287,
            1.691060972213745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the variance of each objective across the archive\n        objectives = np.array([obj for _, obj in archive])\n        variances = np.var(objectives, axis=0)\n        # Select solutions with high variance in any objective\n        candidate_indices = np.where(np.any(variances > np.median(variances), axis=0))[0]\n        if len(candidate_indices) > 0:\n            selected_index = random.choice(candidate_indices)\n            base_solution = archive[selected_index][0].copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply a weighted 2-opt move based on the objectives' importance\n    # 2. If no improvement, apply a 3-opt move for diversity\n\n    # Calculate weights based on objective values (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        weights = 1 - np.mean(normalized_objectives, axis=0)  # Higher weight for worse objectives\n    else:\n        weights = np.array([1.0, 1.0, 1.0])  # Equal weights if only one solution\n\n    # 2-opt move with weighted probability\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    # Calculate the change in cost for each objective\n    delta_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[j]] +\n        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n        distance_matrix_1[new_solution[i-1], new_solution[i]] -\n        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n        distance_matrix_2[new_solution[i-1], new_solution[i]] -\n        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n        distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n        distance_matrix_3[new_solution[i-1], new_solution[i]] -\n        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n    ]\n\n    # Weighted improvement check\n    weighted_improvement = sum(w * dc for w, dc in zip(weights, delta_costs))\n    if weighted_improvement > 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move for diversity\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Try different segment orderings\n        options = [\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]])\n        ]\n        # Evaluate all options\n        best_option = new_solution.copy()\n        best_weighted_improvement = 0\n        for option in options:\n            delta_costs = [\n                sum(distance_matrix_1[option[k-1], option[k]] for k in range(n)) - sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n                sum(distance_matrix_2[option[k-1], option[k]] for k in range(n)) - sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n                sum(distance_matrix_3[option[k-1], option[k]] for k in range(n)) - sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n            ]\n            current_weighted_improvement = sum(w * dc for w, dc in zip(weights, delta_costs))\n            if current_weighted_improvement > best_weighted_improvement:\n                best_weighted_improvement = current_weighted_improvement\n                best_option = option.copy()\n        new_solution = best_option\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 142,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the \"improvement potential\" for each solution (inverse of objective values)\n    potentials = [1.0 / (obj[0] + obj[1] + obj[2]) for (sol, obj) in archive]\n    total_potential = sum(potentials)\n\n    # Randomly select a solution with probability proportional to its potential\n    selected_idx = random.choices(range(len(archive)), weights=potentials, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a random local search operator based on the objectives\n    operator = random.choice(['2opt', '3opt', 'objective_swap'])\n\n    if operator == '2opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3opt':\n        # 3-opt local search (more disruptive)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    elif operator == 'objective_swap':\n        # Objective-aware swap: identify segments with high cost in any objective and reverse them\n        # Calculate the cost of each edge in all three objectives\n        edge_costs = np.zeros((n, n))\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    node_i = new_solution[i]\n                    node_j = new_solution[j]\n                    edge_costs[i,j] = (distance_matrix_1[node_i, node_j] +\n                                      distance_matrix_2[node_i, node_j] +\n                                      distance_matrix_3[node_i, node_j])\n\n        # Find the segment with the highest total cost\n        max_cost = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                segment_cost = sum(edge_costs[i:j, i:j].flatten())\n                if segment_cost > max_cost:\n                    max_cost = segment_cost\n                    best_i, best_j = i, j\n\n        # Reverse the high-cost segment\n        new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7117960181337232,
            3.1332865238189695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the \"improvement potential\" for each solution (inverse of objective values)\n    potentials = [1.0 / (obj[0] + obj[1] + obj[2]) for (sol, obj) in archive]\n    total_potential = sum(potentials)\n\n    # Randomly select a solution with probability proportional to its potential\n    selected_idx = random.choices(range(len(archive)), weights=potentials, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a random local search operator based on the objectives\n    operator = random.choice(['2opt', '3opt', 'objective_swap'])\n\n    if operator == '2opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3opt':\n        # 3-opt local search (more disruptive)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    elif operator == 'objective_swap':\n        # Objective-aware swap: identify segments with high cost in any objective and reverse them\n        # Calculate the cost of each edge in all three objectives\n        edge_costs = np.zeros((n, n))\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    node_i = new_solution[i]\n                    node_j = new_solution[j]\n                    edge_costs[i,j] = (distance_matrix_1[node_i, node_j] +\n                                      distance_matrix_2[node_i, node_j] +\n                                      distance_matrix_3[node_i, node_j])\n\n        # Find the segment with the highest total cost\n        max_cost = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                segment_cost = sum(edge_costs[i:j, i:j].flatten())\n                if segment_cost > max_cost:\n                    max_cost = segment_cost\n                    best_i, best_j = i, j\n\n        # Reverse the high-cost segment\n        new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 143,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_optimal_solutions = [sol for sol, obj in archive if not all(obj[i] <= min(obj2[i] for sol2, obj2 in archive) for i in range(3))]\n    if not non_optimal_solutions:\n        non_optimal_solutions = [sol for sol, _ in archive]\n\n    # Select a solution with the highest average rank across objectives (promising for multi-objective improvement)\n    ranks = []\n    for sol, obj in archive:\n        rank = sum([sum(1 for sol2, obj2 in archive if obj2[i] < obj[i]) for i in range(3)]) / 3\n        ranks.append((rank, sol))\n\n    ranks.sort(key=lambda x: x[0])\n    selected_solution = ranks[0][1].copy()\n\n    # Apply hybrid local search: combination of 2-opt and objective-weighted edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt within the segment\n    if len(segment) >= 2:\n        k, l = np.random.choice(len(segment), 2, replace=False)\n        if k > l:\n            k, l = l, k\n        segment[k:l+1] = segment[k:l+1][::-1]\n\n    # Apply objective-weighted edge swaps\n    for _ in range(3):  # Perform 3 random objective-weighted swaps\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_1[node_b, new_solution[(b-1)%n]] + distance_matrix_1[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_1[node_b, new_solution[(b-1)%n]] + distance_matrix_1[node_b, new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_2[node_b, new_solution[(b-1)%n]] + distance_matrix_2[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_2[node_b, new_solution[(b-1)%n]] + distance_matrix_2[node_b, new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_3[node_b, new_solution[(b-1)%n]] + distance_matrix_3[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_3[node_b, new_solution[(b-1)%n]] + distance_matrix_3[node_b, new_solution[(b+1)%n]])\n\n        # Weighted acceptance probability based on objective improvements\n        weighted_delta = (delta1 + delta2 + delta3) / 3\n        if weighted_delta < 0 or (np.random.random() < 0.3 and weighted_delta < 10):  # Accept if improvement or with small probability\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.663699571375947,
            3.63105126619339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_optimal_solutions = [sol for sol, obj in archive if not all(obj[i] <= min(obj2[i] for sol2, obj2 in archive) for i in range(3))]\n    if not non_optimal_solutions:\n        non_optimal_solutions = [sol for sol, _ in archive]\n\n    # Select a solution with the highest average rank across objectives (promising for multi-objective improvement)\n    ranks = []\n    for sol, obj in archive:\n        rank = sum([sum(1 for sol2, obj2 in archive if obj2[i] < obj[i]) for i in range(3)]) / 3\n        ranks.append((rank, sol))\n\n    ranks.sort(key=lambda x: x[0])\n    selected_solution = ranks[0][1].copy()\n\n    # Apply hybrid local search: combination of 2-opt and objective-weighted edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt within the segment\n    if len(segment) >= 2:\n        k, l = np.random.choice(len(segment), 2, replace=False)\n        if k > l:\n            k, l = l, k\n        segment[k:l+1] = segment[k:l+1][::-1]\n\n    # Apply objective-weighted edge swaps\n    for _ in range(3):  # Perform 3 random objective-weighted swaps\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_1[node_b, new_solution[(b-1)%n]] + distance_matrix_1[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_1[node_b, new_solution[(b-1)%n]] + distance_matrix_1[node_b, new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_2[node_b, new_solution[(b-1)%n]] + distance_matrix_2[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_2[node_b, new_solution[(b-1)%n]] + distance_matrix_2[node_b, new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_3[node_b, new_solution[(b-1)%n]] + distance_matrix_3[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_3[node_b, new_solution[(b-1)%n]] + distance_matrix_3[node_b, new_solution[(b+1)%n]])\n\n        # Weighted acceptance probability based on objective improvements\n        weighted_delta = (delta1 + delta2 + delta3) / 3\n        if weighted_delta < 0 or (np.random.random() < 0.3 and weighted_delta < 10):  # Accept if improvement or with small probability\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 144,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.sum(objectives, axis=0, keepdims=True)\n    weights = 1 / (normalized_obj + 1e-10)  # Avoid division by zero\n    weights = weights / np.sum(weights, axis=0, keepdims=True)\n    combined_weights = np.prod(weights, axis=1)\n    combined_weights = combined_weights / np.sum(combined_weights)\n\n    selected_idx = np.random.choice(len(archive), p=combined_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Apply 2-opt with probability based on objective diversity\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node swap with probability based on objective diversity\n    if random.random() < 0.5:\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply edge insertion with probability based on objective diversity\n    if random.random() < 0.3:\n        i = random.randint(0, n_nodes-1)\n        j = random.randint(0, n_nodes-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n_nodes:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n_nodes), unique)\n        for idx, node in enumerate(new_solution):\n            if counts[np.where(unique == node)[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n                counts[np.where(unique == node)[0][0]] -= 1\n\n    return new_solution\n\n",
        "score": [
            -0.7377277036523453,
            1.1627434134483337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.sum(objectives, axis=0, keepdims=True)\n    weights = 1 / (normalized_obj + 1e-10)  # Avoid division by zero\n    weights = weights / np.sum(weights, axis=0, keepdims=True)\n    combined_weights = np.prod(weights, axis=1)\n    combined_weights = combined_weights / np.sum(combined_weights)\n\n    selected_idx = np.random.choice(len(archive), p=combined_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Apply 2-opt with probability based on objective diversity\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node swap with probability based on objective diversity\n    if random.random() < 0.5:\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply edge insertion with probability based on objective diversity\n    if random.random() < 0.3:\n        i = random.randint(0, n_nodes-1)\n        j = random.randint(0, n_nodes-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n_nodes:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n_nodes), unique)\n        for idx, node in enumerate(new_solution):\n            if counts[np.where(unique == node)[0][0]] > 1:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n                counts[np.where(unique == node)[0][0]] -= 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 145,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objective_variance * objectives, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt, 3-opt, or a custom multi-objective operator\n    operator_choice = random.random()\n\n    if operator_choice < 0.4:  # 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator_choice < 0.7:  # 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:  # Custom multi-objective operator: swap segments based on objective improvement\n        # Calculate current total distances\n        current_dist1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_dist2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_dist3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Try multiple random swaps and keep the one that improves the most in at least one objective\n        best_new_solution = new_solution.copy()\n        best_improvement = 0\n\n        for _ in range(5):  # Try 5 random swaps\n            temp_solution = new_solution.copy()\n            i, j = sorted(random.sample(range(n), 2))\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n\n            # Calculate new distances\n            new_dist1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_dist2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_dist3 = sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Calculate improvement (negative means worse)\n            improvement1 = current_dist1 - new_dist1\n            improvement2 = current_dist2 - new_dist2\n            improvement3 = current_dist3 - new_dist3\n\n            # Keep if at least one objective improves\n            if max(improvement1, improvement2, improvement3) > best_improvement:\n                best_new_solution = temp_solution.copy()\n                best_improvement = max(improvement1, improvement2, improvement3)\n\n        new_solution = best_new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6640388511580679,
            1.3425270438194274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objective_variance * objectives, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt, 3-opt, or a custom multi-objective operator\n    operator_choice = random.random()\n\n    if operator_choice < 0.4:  # 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator_choice < 0.7:  # 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:  # Custom multi-objective operator: swap segments based on objective improvement\n        # Calculate current total distances\n        current_dist1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_dist2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_dist3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Try multiple random swaps and keep the one that improves the most in at least one objective\n        best_new_solution = new_solution.copy()\n        best_improvement = 0\n\n        for _ in range(5):  # Try 5 random swaps\n            temp_solution = new_solution.copy()\n            i, j = sorted(random.sample(range(n), 2))\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n\n            # Calculate new distances\n            new_dist1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_dist2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_dist3 = sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Calculate improvement (negative means worse)\n            improvement1 = current_dist1 - new_dist1\n            improvement2 = current_dist2 - new_dist2\n            improvement3 = current_dist3 - new_dist3\n\n            # Keep if at least one objective improves\n            if max(improvement1, improvement2, improvement3) > best_improvement:\n                best_new_solution = temp_solution.copy()\n                best_improvement = max(improvement1, improvement2, improvement3)\n\n        new_solution = best_new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 146,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the worst objective\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and segment reordering\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for very small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for improvement\n        objectives = archive_sorted[selected_idx][1]\n        worst_obj = np.argmax(objectives)\n\n        # Choose between 2-opt or segment reordering based on the worst objective\n        if np.random.rand() < 0.7 or worst_obj == 0:\n            # 2-opt with distance matrix prioritization\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i + 1 != j:\n                # Check if reversing this segment improves the worst objective\n                original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                                 distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                                 distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment reordering for the worst objective\n            segment_size = min(5, n // 3)\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start+segment_size]\n\n            # Evaluate different positions for the segment\n            best_pos = start\n            best_cost = float('inf')\n\n            for pos in range(n - segment_size + 1):\n                if pos == start:\n                    continue\n\n                # Try inserting the segment at different positions\n                temp_solution = np.concatenate([\n                    new_solution[:start],\n                    new_solution[start+segment_size:pos],\n                    segment,\n                    new_solution[pos:]\n                ])\n\n                # Calculate cost for the worst objective\n                cost = 0\n                for k in range(n):\n                    if worst_obj == 0:\n                        cost += distance_matrix_1[temp_solution[k-1], temp_solution[k]]\n                    elif worst_obj == 1:\n                        cost += distance_matrix_2[temp_solution[k-1], temp_solution[k]]\n                    else:\n                        cost += distance_matrix_3[temp_solution[k-1], temp_solution[k]]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Apply the best found position\n            if best_pos != start:\n                temp_solution = np.concatenate([\n                    new_solution[:start],\n                    new_solution[start+segment_size:best_pos],\n                    segment,\n                    new_solution[best_pos:]\n                ])\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6574743638370049,
            1.3610244154930116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the worst objective\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and segment reordering\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for very small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for improvement\n        objectives = archive_sorted[selected_idx][1]\n        worst_obj = np.argmax(objectives)\n\n        # Choose between 2-opt or segment reordering based on the worst objective\n        if np.random.rand() < 0.7 or worst_obj == 0:\n            # 2-opt with distance matrix prioritization\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i + 1 != j:\n                # Check if reversing this segment improves the worst objective\n                original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                                 distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                                 distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment reordering for the worst objective\n            segment_size = min(5, n // 3)\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start+segment_size]\n\n            # Evaluate different positions for the segment\n            best_pos = start\n            best_cost = float('inf')\n\n            for pos in range(n - segment_size + 1):\n                if pos == start:\n                    continue\n\n                # Try inserting the segment at different positions\n                temp_solution = np.concatenate([\n                    new_solution[:start],\n                    new_solution[start+segment_size:pos],\n                    segment,\n                    new_solution[pos:]\n                ])\n\n                # Calculate cost for the worst objective\n                cost = 0\n                for k in range(n):\n                    if worst_obj == 0:\n                        cost += distance_matrix_1[temp_solution[k-1], temp_solution[k]]\n                    elif worst_obj == 1:\n                        cost += distance_matrix_2[temp_solution[k-1], temp_solution[k]]\n                    else:\n                        cost += distance_matrix_3[temp_solution[k-1], temp_solution[k]]\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Apply the best found position\n            if best_pos != start:\n                temp_solution = np.concatenate([\n                    new_solution[:start],\n                    new_solution[start+segment_size:best_pos],\n                    segment,\n                    new_solution[best_pos:]\n                ])\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 147,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in at least one objective\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and 3-opt\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt first\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then apply 3-opt for further improvement\n    if n >= 4:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != i and l != j:\n            # Apply 3-opt by reversing segments\n            if k < l:\n                new_solution[k:l] = new_solution[k:l][::-1]\n            else:\n                new_solution[l:k] = new_solution[l:k][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7235189824532514,
            1.0277714133262634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in at least one objective\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and 3-opt\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt first\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then apply 3-opt for further improvement\n    if n >= 4:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != i and l != j:\n            # Apply 3-opt by reversing segments\n            if k < l:\n                new_solution[k:l] = new_solution[k:l][::-1]\n            else:\n                new_solution[l:k] = new_solution[l:k][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 148,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated but not too good)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-aware swaps to improve all three objectives\n    for _ in range(2):  # Perform a few swaps\n        # Calculate current costs\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n\n        # Find a pair of nodes to swap that improves at least one objective\n        improved = False\n        for _ in range(5):  # Try a few random swaps\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n            # Create temporary solution\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n                sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n                sum(distance_matrix_3[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n            ]\n\n            # Check if at least one objective is improved\n            if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n                new_solution = temp_solution\n                improved = True\n                break\n\n        if not improved:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7553720761904443,
            1.436154305934906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated but not too good)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-aware swaps to improve all three objectives\n    for _ in range(2):  # Perform a few swaps\n        # Calculate current costs\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n\n        # Find a pair of nodes to swap that improves at least one objective\n        improved = False\n        for _ in range(5):  # Try a few random swaps\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n            # Create temporary solution\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n            # Calculate new costs\n            new_costs = [\n                sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n                sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n                sum(distance_matrix_3[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n            ]\n\n            # Check if at least one objective is improved\n            if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n                new_solution = temp_solution\n                improved = True\n                break\n\n        if not improved:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 149,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher total distance)\n    objectives = np.array([obj for _, obj in archive])\n    total_distances = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(total_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Randomly select a segment to reverse (2-opt)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a 3-opt move for better multi-objective optimization\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        # Create a new segment by rearranging the selected nodes\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # 3. Check for improvement in all objectives and revert if not\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        obj1 += distance_matrix_1[solution[-1], solution[0]]  # complete the tour\n        obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        obj2 += distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1))\n        obj3 += distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = archive[selected_idx][1]\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is not better in all objectives, revert to 2-opt only\n    if not all(new_o <= curr_o for new_o, curr_o in zip(new_obj, current_obj)):\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6341556353181679,
            0.9766891241073609
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher total distance)\n    objectives = np.array([obj for _, obj in archive])\n    total_distances = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(total_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Randomly select a segment to reverse (2-opt)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a 3-opt move for better multi-objective optimization\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        # Create a new segment by rearranging the selected nodes\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # 3. Check for improvement in all objectives and revert if not\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        obj1 += distance_matrix_1[solution[-1], solution[0]]  # complete the tour\n        obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        obj2 += distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1))\n        obj3 += distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = archive[selected_idx][1]\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is not better in all objectives, revert to 2-opt only\n    if not all(new_o <= curr_o for new_o, curr_o in zip(new_obj, current_obj)):\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 150,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective perturbation\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective perturbation: choose a segment and rotate it based on the worst objective\n    if np.random.rand() < 0.5:  # 50% chance to apply the perturbation\n        segment_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Calculate the worst objective for the segment\n        costs = [\n            sum(distance_matrix_1[segment[k], segment[(k+1)%segment_size]] for k in range(segment_size)),\n            sum(distance_matrix_2[segment[k], segment[(k+1)%segment_size]] for k in range(segment_size)),\n            sum(distance_matrix_3[segment[k], segment[(k+1)%segment_size]] for k in range(segment_size))\n        ]\n        worst_obj = np.argmax(costs)\n\n        # Rotate the segment to improve the worst objective\n        if worst_obj == 0:\n            # For first objective, try to minimize by rotating\n            segment = np.roll(segment, np.random.randint(1, segment_size))\n        elif worst_obj == 1:\n            # For second objective, reverse the segment\n            segment = segment[::-1]\n        else:\n            # For third objective, try to find a better permutation\n            segment = np.random.permutation(segment)\n\n        new_solution[start:start+segment_size] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7058439804179126,
            0.9040627956390381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective perturbation\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective perturbation: choose a segment and rotate it based on the worst objective\n    if np.random.rand() < 0.5:  # 50% chance to apply the perturbation\n        segment_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Calculate the worst objective for the segment\n        costs = [\n            sum(distance_matrix_1[segment[k], segment[(k+1)%segment_size]] for k in range(segment_size)),\n            sum(distance_matrix_2[segment[k], segment[(k+1)%segment_size]] for k in range(segment_size)),\n            sum(distance_matrix_3[segment[k], segment[(k+1)%segment_size]] for k in range(segment_size))\n        ]\n        worst_obj = np.argmax(costs)\n\n        # Rotate the segment to improve the worst objective\n        if worst_obj == 0:\n            # For first objective, try to minimize by rotating\n            segment = np.roll(segment, np.random.randint(1, segment_size))\n        elif worst_obj == 1:\n            # For second objective, reverse the segment\n            segment = segment[::-1]\n        else:\n            # For third objective, try to find a better permutation\n            segment = np.random.permutation(segment)\n\n        new_solution[start:start+segment_size] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 151,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    candidate_indices = []\n    for i, (sol, obj) in enumerate(archive):\n        # Check if the solution is not already optimal in all objectives (simplified criterion)\n        if not all(obj[j] <= min(archive[k][1][j] for k in range(len(archive))) for j in range(3)):\n            candidate_indices.append(i)\n\n    if not candidate_indices:\n        # If all solutions are optimal in all objectives, pick a random one\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        # Select a candidate with high potential for improvement\n        selected_idx = np.random.choice(candidate_indices)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply a combination of 2-opt and edge insertion\n        # Step 1: 2-opt on the worst objective dimension\n        obj = archive[selected_idx][1]\n        worst_dim = np.argmax(obj)  # Find the objective with the highest value\n\n        # Select a random segment to optimize\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Reverse the segment if it improves the worst objective\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate the change in the worst objective\n        original_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) if worst_dim == 0 else \\\n                        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) if worst_dim == 1 else \\\n                        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        reversed_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) if worst_dim == 0 else \\\n                        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) if worst_dim == 1 else \\\n                        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Revert if not better\n        if reversed_cost >= original_cost:\n            new_solution[a:b+1] = segment\n\n        # Step 2: Edge insertion to improve other objectives\n        # Select two random nodes and insert one before the other\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7775672012149174,
            1.7518237829208374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    candidate_indices = []\n    for i, (sol, obj) in enumerate(archive):\n        # Check if the solution is not already optimal in all objectives (simplified criterion)\n        if not all(obj[j] <= min(archive[k][1][j] for k in range(len(archive))) for j in range(3)):\n            candidate_indices.append(i)\n\n    if not candidate_indices:\n        # If all solutions are optimal in all objectives, pick a random one\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        # Select a candidate with high potential for improvement\n        selected_idx = np.random.choice(candidate_indices)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply a combination of 2-opt and edge insertion\n        # Step 1: 2-opt on the worst objective dimension\n        obj = archive[selected_idx][1]\n        worst_dim = np.argmax(obj)  # Find the objective with the highest value\n\n        # Select a random segment to optimize\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Reverse the segment if it improves the worst objective\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate the change in the worst objective\n        original_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) if worst_dim == 0 else \\\n                        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) if worst_dim == 1 else \\\n                        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        reversed_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) if worst_dim == 0 else \\\n                        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) if worst_dim == 1 else \\\n                        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Revert if not better\n        if reversed_cost >= original_cost:\n            new_solution[a:b+1] = segment\n\n        # Step 2: Edge insertion to improve other objectives\n        # Select two random nodes and insert one before the other\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 152,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the best average objective)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=1)\n    selected_idx = np.argmin(avg_objectives)  # Select the solution with the lowest average objective\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Perform 2-opt to improve the worst objective\n    worst_obj_idx = np.argmax(archive[selected_idx][1])\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    max_edge_cost = -1\n    i, j = 0, 0\n    for idx in range(n_nodes):\n        current = new_solution[idx]\n        next_node = new_solution[(idx + 1) % n_nodes]\n        edge_cost = dist_matrix[current, next_node]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            i = idx\n            j = (idx + 1) % n_nodes\n\n    # Try to improve by reversing the segment between i and j\n    if i < j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        # Handle the wrap-around case\n        reversed_segment = np.concatenate((new_solution[j+1:], new_solution[:i+1]))[::-1]\n        new_solution = np.concatenate((reversed_segment[:n_nodes-(j+1)], new_solution[j+1:i+1], reversed_segment[n_nodes-(j+1):]))\n\n    # Additional objective-aware edge swaps\n    for _ in range(3):  # Perform 3 random edge swaps biased towards improving the worst objective\n        # Select two random edges\n        a, b = np.random.choice(n_nodes, size=2, replace=False)\n        c, d = np.random.choice(n_nodes, size=2, replace=False)\n\n        # Calculate the change in all objectives\n        delta_obj1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                      distance_matrix_1[new_solution[c], new_solution[d]]) - \\\n                     (distance_matrix_1[new_solution[a], new_solution[c]] +\n                      distance_matrix_1[new_solution[b], new_solution[d]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[a], new_solution[b]] +\n                      distance_matrix_2[new_solution[c], new_solution[d]]) - \\\n                     (distance_matrix_2[new_solution[a], new_solution[c]] +\n                      distance_matrix_2[new_solution[b], new_solution[d]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[a], new_solution[b]] +\n                      distance_matrix_3[new_solution[c], new_solution[d]]) - \\\n                     (distance_matrix_3[new_solution[a], new_solution[c]] +\n                      distance_matrix_3[new_solution[b], new_solution[d]])\n\n        # Accept if it improves the worst objective\n        if (worst_obj_idx == 0 and delta_obj1 < 0) or \\\n           (worst_obj_idx == 1 and delta_obj2 < 0) or \\\n           (worst_obj_idx == 2 and delta_obj3 < 0):\n            # Perform the swap\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8245710959831947,
            1.2338097929954528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the best average objective)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=1)\n    selected_idx = np.argmin(avg_objectives)  # Select the solution with the lowest average objective\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Perform 2-opt to improve the worst objective\n    worst_obj_idx = np.argmax(archive[selected_idx][1])\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    max_edge_cost = -1\n    i, j = 0, 0\n    for idx in range(n_nodes):\n        current = new_solution[idx]\n        next_node = new_solution[(idx + 1) % n_nodes]\n        edge_cost = dist_matrix[current, next_node]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            i = idx\n            j = (idx + 1) % n_nodes\n\n    # Try to improve by reversing the segment between i and j\n    if i < j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        # Handle the wrap-around case\n        reversed_segment = np.concatenate((new_solution[j+1:], new_solution[:i+1]))[::-1]\n        new_solution = np.concatenate((reversed_segment[:n_nodes-(j+1)], new_solution[j+1:i+1], reversed_segment[n_nodes-(j+1):]))\n\n    # Additional objective-aware edge swaps\n    for _ in range(3):  # Perform 3 random edge swaps biased towards improving the worst objective\n        # Select two random edges\n        a, b = np.random.choice(n_nodes, size=2, replace=False)\n        c, d = np.random.choice(n_nodes, size=2, replace=False)\n\n        # Calculate the change in all objectives\n        delta_obj1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                      distance_matrix_1[new_solution[c], new_solution[d]]) - \\\n                     (distance_matrix_1[new_solution[a], new_solution[c]] +\n                      distance_matrix_1[new_solution[b], new_solution[d]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[a], new_solution[b]] +\n                      distance_matrix_2[new_solution[c], new_solution[d]]) - \\\n                     (distance_matrix_2[new_solution[a], new_solution[c]] +\n                      distance_matrix_2[new_solution[b], new_solution[d]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[a], new_solution[b]] +\n                      distance_matrix_3[new_solution[c], new_solution[d]]) - \\\n                     (distance_matrix_3[new_solution[a], new_solution[c]] +\n                      distance_matrix_3[new_solution[b], new_solution[d]])\n\n        # Accept if it improves the worst objective\n        if (worst_obj_idx == 0 and delta_obj1 < 0) or \\\n           (worst_obj_idx == 1 and delta_obj2 < 0) or \\\n           (worst_obj_idx == 2 and delta_obj3 < 0):\n            # Perform the swap\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 153,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., high crowding distance or low objective values)\n    selected_index = np.random.choice(len(archive))\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of 2-opt and multi-objective edge swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Ensure i < j for simplicity\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move (swap edges between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the new solution across all three objectives\n    def evaluate(solution):\n        total_cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        total_cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        total_cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (total_cost1, total_cost2, total_cost3)\n\n    new_cost = evaluate(new_solution)\n\n    # If the new solution is dominated by the original, revert to a different local search\n    original_cost = archive[selected_index][1]\n    if (new_cost[0] >= original_cost[0] and new_cost[1] >= original_cost[1] and new_cost[2] >= original_cost[2]) and not (new_cost == original_cost):\n        # Apply a multi-objective edge swap: prioritize improving the objective with the highest current cost\n        max_obj = np.argmax(original_cost)\n        if max_obj == 0:\n            # Improve the first objective by swapping edges that reduce cost1\n            for _ in range(10):  # Limit the number of attempts\n                a, b = np.random.choice(n, size=2, replace=False)\n                if a > b:\n                    a, b = b, a\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                temp_cost = evaluate(temp_solution)\n                if temp_cost[0] < new_cost[0]:\n                    new_solution = temp_solution\n                    new_cost = temp_cost\n                    break\n        elif max_obj == 1:\n            # Improve the second objective by swapping edges that reduce cost2\n            for _ in range(10):\n                a, b = np.random.choice(n, size=2, replace=False)\n                if a > b:\n                    a, b = b, a\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                temp_cost = evaluate(temp_solution)\n                if temp_cost[1] < new_cost[1]:\n                    new_solution = temp_solution\n                    new_cost = temp_cost\n                    break\n        else:\n            # Improve the third objective by swapping edges that reduce cost3\n            for _ in range(10):\n                a, b = np.random.choice(n, size=2, replace=False)\n                if a > b:\n                    a, b = b, a\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                temp_cost = evaluate(temp_solution)\n                if temp_cost[2] < new_cost[2]:\n                    new_solution = temp_solution\n                    new_cost = temp_cost\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7899394679287368,
            0.8497530102729798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., high crowding distance or low objective values)\n    selected_index = np.random.choice(len(archive))\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of 2-opt and multi-objective edge swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Ensure i < j for simplicity\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move (swap edges between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the new solution across all three objectives\n    def evaluate(solution):\n        total_cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        total_cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        total_cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (total_cost1, total_cost2, total_cost3)\n\n    new_cost = evaluate(new_solution)\n\n    # If the new solution is dominated by the original, revert to a different local search\n    original_cost = archive[selected_index][1]\n    if (new_cost[0] >= original_cost[0] and new_cost[1] >= original_cost[1] and new_cost[2] >= original_cost[2]) and not (new_cost == original_cost):\n        # Apply a multi-objective edge swap: prioritize improving the objective with the highest current cost\n        max_obj = np.argmax(original_cost)\n        if max_obj == 0:\n            # Improve the first objective by swapping edges that reduce cost1\n            for _ in range(10):  # Limit the number of attempts\n                a, b = np.random.choice(n, size=2, replace=False)\n                if a > b:\n                    a, b = b, a\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                temp_cost = evaluate(temp_solution)\n                if temp_cost[0] < new_cost[0]:\n                    new_solution = temp_solution\n                    new_cost = temp_cost\n                    break\n        elif max_obj == 1:\n            # Improve the second objective by swapping edges that reduce cost2\n            for _ in range(10):\n                a, b = np.random.choice(n, size=2, replace=False)\n                if a > b:\n                    a, b = b, a\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                temp_cost = evaluate(temp_solution)\n                if temp_cost[1] < new_cost[1]:\n                    new_solution = temp_solution\n                    new_cost = temp_cost\n                    break\n        else:\n            # Improve the third objective by swapping edges that reduce cost3\n            for _ in range(10):\n                a, b = np.random.choice(n, size=2, replace=False)\n                if a > b:\n                    a, b = b, a\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                temp_cost = evaluate(temp_solution)\n                if temp_cost[2] < new_cost[2]:\n                    new_solution = temp_solution\n                    new_cost = temp_cost\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 154,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of objectives (promising for improvement)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    sum_objectives = [sum(obj) for obj in archive_objectives]\n\n    # Select top 30% solutions with the lowest sum of objectives\n    top_indices = np.argsort(sum_objectives)[:max(1, len(sum_objectives) // 3)]\n    selected_solutions = [archive_solutions[i] for i in top_indices]\n\n    # Randomly select one solution from the top candidates\n    base_solution = random.choice(selected_solutions).copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with the objective that has the highest relative improvement potential\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and new costs for all three objectives\n        current_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[j-1]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j-1]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j-1]]\n        )\n\n        # Calculate improvement for each objective\n        improvements = [\n            current_costs[k] - new_costs[k] for k in range(3)\n        ]\n\n        # If any objective improves, perform the swap\n        if any(imp > 0 for imp in improvements):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a small perturbation to escape local optima\n    if random.random() < 0.1:  # 10% chance of perturbation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7847567442393657,
            1.1910185933113098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of objectives (promising for improvement)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    sum_objectives = [sum(obj) for obj in archive_objectives]\n\n    # Select top 30% solutions with the lowest sum of objectives\n    top_indices = np.argsort(sum_objectives)[:max(1, len(sum_objectives) // 3)]\n    selected_solutions = [archive_solutions[i] for i in top_indices]\n\n    # Randomly select one solution from the top candidates\n    base_solution = random.choice(selected_solutions).copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with the objective that has the highest relative improvement potential\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and new costs for all three objectives\n        current_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[j-1]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j-1]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j-1]]\n        )\n\n        # Calculate improvement for each objective\n        improvements = [\n            current_costs[k] - new_costs[k] for k in range(3)\n        ]\n\n        # If any objective improves, perform the swap\n        if any(imp > 0 for imp in improvements):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a small perturbation to escape local optima\n    if random.random() < 0.1:  # 10% chance of perturbation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 155,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives (using a simple weighted sum)\n    weights = [0.33, 0.33, 0.34]  # Equal weights for simplicity\n    best_idx = 0\n    best_score = sum(w * obj for w, obj in zip(weights, archive[0][1]))\n\n    for i, (_, obj) in enumerate(archive[1:]):\n        current_score = sum(w * o for w, o in zip(weights, obj))\n        if current_score < best_score:\n            best_score = current_score\n            best_idx = i + 1\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt + random swap\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Randomly choose between 2-opt and random swap\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a valid solution if invalid\n        new_solution = np.random.permutation(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7106899055557026,
            1.131379747390747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives (using a simple weighted sum)\n    weights = [0.33, 0.33, 0.34]  # Equal weights for simplicity\n    best_idx = 0\n    best_score = sum(w * obj for w, obj in zip(weights, archive[0][1]))\n\n    for i, (_, obj) in enumerate(archive[1:]):\n        current_score = sum(w * o for w, o in zip(weights, obj))\n        if current_score < best_score:\n            best_score = current_score\n            best_idx = i + 1\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt + random swap\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Randomly choose between 2-opt and random swap\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a valid solution if invalid\n        new_solution = np.random.permutation(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 156,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a segment\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Choose between 2-opt or node insertion based on objective diversity\n        if np.random.random() < 0.5:\n            # 2-opt: reverse a segment\n            i, j = np.random.choice(n, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion: move a node to a different position\n            i = np.random.randint(n)\n            j = np.random.randint(n)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8304856869678348,
            0.8785683393478394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a segment\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Choose between 2-opt or node insertion based on objective diversity\n        if np.random.random() < 0.5:\n            # 2-opt: reverse a segment\n            i, j = np.random.choice(n, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion: move a node to a different position\n            i = np.random.randint(n)\n            j = np.random.randint(n)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 157,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best trade-off between objectives (using Pareto dominance)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and other_obj[2] <= obj[2] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1] or other_obj[2] < obj[2])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select a base solution with probability proportional to its potential for improvement\n    base_sol, base_obj = random.choices(\n        non_dominated,\n        weights=[1 / (1 + sum(base_obj)) for _, base_obj in non_dominated],\n        k=1\n    )[0]\n\n    new_solution = base_sol.copy()\n\n    # Hybrid local search strategy combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Select a random node to relocate using insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution is valid\n    assert len(new_solution) == len(base_sol) and len(np.unique(new_solution)) == len(base_sol), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7042940278654232,
            1.4929463386535644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best trade-off between objectives (using Pareto dominance)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and other_obj[2] <= obj[2] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1] or other_obj[2] < obj[2])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select a base solution with probability proportional to its potential for improvement\n    base_sol, base_obj = random.choices(\n        non_dominated,\n        weights=[1 / (1 + sum(base_obj)) for _, base_obj in non_dominated],\n        k=1\n    )[0]\n\n    new_solution = base_sol.copy()\n\n    # Hybrid local search strategy combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Select a random node to relocate using insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution is valid\n    assert len(new_solution) == len(base_sol) and len(np.unique(new_solution)) == len(base_sol), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 158,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of all objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Select two distinct edges based on their potential for improvement\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the current and potential objective changes\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j-1], new_solution[i])\n        ]\n\n        # Calculate the change in each objective\n        delta_obj1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]]) - \\\n                     (distance_matrix_1[current_edges[0]] + distance_matrix_1[current_edges[1]])\n        delta_obj2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]]) - \\\n                     (distance_matrix_2[current_edges[0]] + distance_matrix_2[current_edges[1]])\n        delta_obj3 = (distance_matrix_3[new_edges[0]] + distance_matrix_3[new_edges[1]]) - \\\n                     (distance_matrix_3[current_edges[0]] + distance_matrix_3[current_edges[1]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7328447614369595,
            0.6021892428398132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of all objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Select two distinct edges based on their potential for improvement\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the current and potential objective changes\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j-1], new_solution[i])\n        ]\n\n        # Calculate the change in each objective\n        delta_obj1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]]) - \\\n                     (distance_matrix_1[current_edges[0]] + distance_matrix_1[current_edges[1]])\n        delta_obj2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]]) - \\\n                     (distance_matrix_2[current_edges[0]] + distance_matrix_2[current_edges[1]])\n        delta_obj3 = (distance_matrix_3[new_edges[0]] + distance_matrix_3[new_edges[1]]) - \\\n                     (distance_matrix_3[current_edges[0]] + distance_matrix_3[current_edges[1]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 159,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node swap\n    n = len(new_solution)\n    if n < 4:\n        # If too small, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or node swap based on random selection\n        if random.random() < 0.5:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node swap move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates (shouldn't happen with proper moves)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if something went wrong\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7924476100609356,
            0.8063153982162475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node swap\n    n = len(new_solution)\n    if n < 4:\n        # If too small, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or node swap based on random selection\n        if random.random() < 0.5:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node swap move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates (shouldn't happen with proper moves)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if something went wrong\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 160,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-6)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-6)  # Inverse of total normalized objectives\n    weights /= weights.sum()  # Normalize weights\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of 2-opt and random insertion\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Apply 2-opt with a probability of 0.7\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(n_nodes, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply random insertion with a probability of 0.5\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n_nodes, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n_nodes, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.6834524935005758,
            1.4033228754997253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-6)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-6)  # Inverse of total normalized objectives\n    weights /= weights.sum()  # Normalize weights\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of 2-opt and random insertion\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Apply 2-opt with a probability of 0.7\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(n_nodes, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply random insertion with a probability of 0.5\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n_nodes, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n_nodes, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 161,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with higher potential for improvement\n    # We prioritize solutions with higher average objective values (indicating room for improvement)\n    avg_objectives = [sum(obj) / 3 for _, obj in archive]\n    probabilities = np.array(avg_objectives) / sum(avg_objectives)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    operator = random.choice(['2opt', '3opt', 'multi_obj_edge_swap'])\n\n    if operator == '2opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # multi_obj_edge_swap\n        # Novel multi-objective edge swap strategy\n        # Select edges that are problematic in at least two objective spaces\n        # and swap them to potentially improve multiple objectives simultaneously\n\n        # Calculate edge costs in all three objectives\n        edge_costs = []\n        for i in range(n):\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            cost1 = distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, b]\n            cost3 = distance_matrix_3[a, b]\n            edge_costs.append((cost1 + cost2 + cost3, i))\n\n        # Sort edges by total cost (descending) to identify problematic edges\n        edge_costs.sort(reverse=True, key=lambda x: x[0])\n\n        # Select top 3 problematic edges\n        selected_edges = [idx for _, idx in edge_costs[:3]]\n\n        # Perform edge swaps that improve multiple objectives\n        for i in selected_edges:\n            j = (i + 1) % n\n            # Try to find a better swap that improves at least two objectives\n            for k in range(n):\n                if k == i or k == j or (k+1)%n == i or (k+1)%n == j:\n                    continue\n                # Evaluate the swap\n                a, b = new_solution[i], new_solution[j]\n                c, d = new_solution[k], new_solution[(k+1)%n]\n\n                # Calculate original and new costs\n                original_costs = [\n                    distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b],\n                    distance_matrix_1[c, d] + distance_matrix_2[c, d] + distance_matrix_3[c, d]\n                ]\n                new_costs = [\n                    distance_matrix_1[a, c] + distance_matrix_2[a, c] + distance_matrix_3[a, c],\n                    distance_matrix_1[b, d] + distance_matrix_2[b, d] + distance_matrix_3[b, d]\n                ]\n\n                # Count how many objectives are improved\n                improvements = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n\n                if improvements >= 2:  # If at least two objectives are improved\n                    # Perform the swap\n                    new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8198571415072182,
            1.3944727540016175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with higher potential for improvement\n    # We prioritize solutions with higher average objective values (indicating room for improvement)\n    avg_objectives = [sum(obj) / 3 for _, obj in archive]\n    probabilities = np.array(avg_objectives) / sum(avg_objectives)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    operator = random.choice(['2opt', '3opt', 'multi_obj_edge_swap'])\n\n    if operator == '2opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # multi_obj_edge_swap\n        # Novel multi-objective edge swap strategy\n        # Select edges that are problematic in at least two objective spaces\n        # and swap them to potentially improve multiple objectives simultaneously\n\n        # Calculate edge costs in all three objectives\n        edge_costs = []\n        for i in range(n):\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            cost1 = distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, b]\n            cost3 = distance_matrix_3[a, b]\n            edge_costs.append((cost1 + cost2 + cost3, i))\n\n        # Sort edges by total cost (descending) to identify problematic edges\n        edge_costs.sort(reverse=True, key=lambda x: x[0])\n\n        # Select top 3 problematic edges\n        selected_edges = [idx for _, idx in edge_costs[:3]]\n\n        # Perform edge swaps that improve multiple objectives\n        for i in selected_edges:\n            j = (i + 1) % n\n            # Try to find a better swap that improves at least two objectives\n            for k in range(n):\n                if k == i or k == j or (k+1)%n == i or (k+1)%n == j:\n                    continue\n                # Evaluate the swap\n                a, b = new_solution[i], new_solution[j]\n                c, d = new_solution[k], new_solution[(k+1)%n]\n\n                # Calculate original and new costs\n                original_costs = [\n                    distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b],\n                    distance_matrix_1[c, d] + distance_matrix_2[c, d] + distance_matrix_3[c, d]\n                ]\n                new_costs = [\n                    distance_matrix_1[a, c] + distance_matrix_2[a, c] + distance_matrix_3[a, c],\n                    distance_matrix_1[b, d] + distance_matrix_2[b, d] + distance_matrix_3[b, d]\n                ]\n\n                # Count how many objectives are improved\n                improvements = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n\n                if improvements >= 2:  # If at least two objectives are improved\n                    # Perform the swap\n                    new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 162,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low improvement potential\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify the worst edge in any objective space\n        worst_edge = -1\n        max_cost = -1\n        for k in range(n):\n            node1 = base_solution[k]\n            node2 = base_solution[(k+1)%n]\n            cost = (distance_matrix_1[node1, node2] +\n                    distance_matrix_2[node1, node2] +\n                    distance_matrix_3[node1, node2])\n            if cost > max_cost:\n                max_cost = cost\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Swap nodes to potentially improve all objectives\n            new_solution[worst_edge], new_solution[(worst_edge+1)%n] = new_solution[(worst_edge+1)%n], new_solution[worst_edge]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6143508939101405,
            1.8383861899375915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low improvement potential\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify the worst edge in any objective space\n        worst_edge = -1\n        max_cost = -1\n        for k in range(n):\n            node1 = base_solution[k]\n            node2 = base_solution[(k+1)%n]\n            cost = (distance_matrix_1[node1, node2] +\n                    distance_matrix_2[node1, node2] +\n                    distance_matrix_3[node1, node2])\n            if cost > max_cost:\n                max_cost = cost\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Swap nodes to potentially improve all objectives\n            new_solution[worst_edge], new_solution[(worst_edge+1)%n] = new_solution[(worst_edge+1)%n], new_solution[worst_edge]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 163,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap for the most critical objective (lowest value)\n    obj_values = archive[selected_idx][1]\n    critical_obj = np.argmin(obj_values)\n\n    if critical_obj == 0:\n        # Apply 2-opt in space 1\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif critical_obj == 1:\n        # Apply 2-opt in space 2\n        if distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] < \\\n           distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply 2-opt in space 3\n        if distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] < \\\n           distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform additional swap to diversify the solution\n    if k != i and k != j and l != i and l != j:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7021129758702342,
            0.9441702365875244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap for the most critical objective (lowest value)\n    obj_values = archive[selected_idx][1]\n    critical_obj = np.argmin(obj_values)\n\n    if critical_obj == 0:\n        # Apply 2-opt in space 1\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif critical_obj == 1:\n        # Apply 2-opt in space 2\n        if distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] < \\\n           distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply 2-opt in space 3\n        if distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] < \\\n           distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform additional swap to diversify the solution\n    if k != i and k != j and l != i and l != j:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 164,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest diversity in objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the most critical objective (highest diversity)\n    critical_obj = np.argmax(diversity)\n    if critical_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif critical_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    worst_edge_idx = -1\n    max_edge_cost = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_cost = dist_matrix[u, v]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            worst_edge_idx = i\n\n    if worst_edge_idx != -1:\n        # Find the best possible replacement\n        best_gain = 0\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i + 2, n):\n                u1 = new_solution[i]\n                v1 = new_solution[(i + 1) % n]\n                u2 = new_solution[j]\n                v2 = new_solution[(j + 1) % n]\n\n                # Calculate potential gain\n                gain = (dist_matrix[u1, v1] + dist_matrix[u2, v2]) - (dist_matrix[u1, u2] + dist_matrix[v1, v2])\n                if gain > best_gain:\n                    best_gain = gain\n                    best_i, best_j = i, j\n\n        if best_i != -1 and best_j != -1:\n            # Apply 2-opt\n            new_solution[best_i + 1:best_j + 1] = new_solution[best_i + 1:best_j + 1][::-1]\n\n    # Edge insertion for the other objectives\n    for obj_idx in range(3):\n        if obj_idx == critical_obj:\n            continue\n\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst node to remove and best position to insert\n        worst_node = -1\n        max_node_cost = -1\n        for i in range(n):\n            u = new_solution[i]\n            prev = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            node_cost = dist_matrix[prev, u] + dist_matrix[u, next_node] - dist_matrix[prev, next_node]\n            if node_cost > max_node_cost:\n                max_node_cost = node_cost\n                worst_node = i\n\n        if worst_node != -1:\n            # Remove the worst node\n            removed_node = new_solution[worst_node]\n            new_solution = np.delete(new_solution, worst_node)\n\n            # Find best insertion position\n            best_pos = -1\n            best_insert_cost = float('inf')\n            for i in range(n - 1):\n                prev = new_solution[i]\n                next_node = new_solution[(i + 1) % (n - 1)]\n                insert_cost = dist_matrix[prev, removed_node] + dist_matrix[removed_node, next_node] - dist_matrix[prev, next_node]\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_pos = i + 1\n\n            if best_pos != -1:\n                new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    return new_solution\n\n",
        "score": [
            -0.6669127688604651,
            3.4348458886146545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest diversity in objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the most critical objective (highest diversity)\n    critical_obj = np.argmax(diversity)\n    if critical_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif critical_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    worst_edge_idx = -1\n    max_edge_cost = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_cost = dist_matrix[u, v]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            worst_edge_idx = i\n\n    if worst_edge_idx != -1:\n        # Find the best possible replacement\n        best_gain = 0\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i + 2, n):\n                u1 = new_solution[i]\n                v1 = new_solution[(i + 1) % n]\n                u2 = new_solution[j]\n                v2 = new_solution[(j + 1) % n]\n\n                # Calculate potential gain\n                gain = (dist_matrix[u1, v1] + dist_matrix[u2, v2]) - (dist_matrix[u1, u2] + dist_matrix[v1, v2])\n                if gain > best_gain:\n                    best_gain = gain\n                    best_i, best_j = i, j\n\n        if best_i != -1 and best_j != -1:\n            # Apply 2-opt\n            new_solution[best_i + 1:best_j + 1] = new_solution[best_i + 1:best_j + 1][::-1]\n\n    # Edge insertion for the other objectives\n    for obj_idx in range(3):\n        if obj_idx == critical_obj:\n            continue\n\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst node to remove and best position to insert\n        worst_node = -1\n        max_node_cost = -1\n        for i in range(n):\n            u = new_solution[i]\n            prev = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            node_cost = dist_matrix[prev, u] + dist_matrix[u, next_node] - dist_matrix[prev, next_node]\n            if node_cost > max_node_cost:\n                max_node_cost = node_cost\n                worst_node = i\n\n        if worst_node != -1:\n            # Remove the worst node\n            removed_node = new_solution[worst_node]\n            new_solution = np.delete(new_solution, worst_node)\n\n            # Find best insertion position\n            best_pos = -1\n            best_insert_cost = float('inf')\n            for i in range(n - 1):\n                prev = new_solution[i]\n                next_node = new_solution[(i + 1) % (n - 1)]\n                insert_cost = dist_matrix[prev, removed_node] + dist_matrix[removed_node, next_node] - dist_matrix[prev, next_node]\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_pos = i + 1\n\n            if best_pos != -1:\n                new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 165,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to find less dominated solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of the archive\n        selection_pool = archive_sorted[:max(1, len(archive) // 3)]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between standard 2-opt or objective-aware swap\n        if random.random() < 0.7:  # 70% chance for standard 2-opt\n            # Standard 2-opt\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware edge swap\n            # Find edges that are long in at least one objective space\n            obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            obj3_cost = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n            # Find the worst edges in any objective\n            worst_edges = []\n            for i in range(n):\n                d1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                d2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                d3 = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                if d1 > obj1_cost/n * 1.2 or d2 > obj2_cost/n * 1.2 or d3 > obj3_cost/n * 1.2:\n                    worst_edges.append(i)\n\n            if worst_edges:\n                # Replace one of the worst edges with a better alternative\n                i = random.choice(worst_edges)\n                j = random.choice([x for x in range(n) if x != i and x != (i+1)%n and x != (i-1)%n])\n\n                # Create a new edge that might improve at least one objective\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Fall back to standard 2-opt if no bad edges found\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7241985031594506,
            1.1086400747299194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to find less dominated solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of the archive\n        selection_pool = archive_sorted[:max(1, len(archive) // 3)]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between standard 2-opt or objective-aware swap\n        if random.random() < 0.7:  # 70% chance for standard 2-opt\n            # Standard 2-opt\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware edge swap\n            # Find edges that are long in at least one objective space\n            obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            obj3_cost = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n            # Find the worst edges in any objective\n            worst_edges = []\n            for i in range(n):\n                d1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                d2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                d3 = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                if d1 > obj1_cost/n * 1.2 or d2 > obj2_cost/n * 1.2 or d3 > obj3_cost/n * 1.2:\n                    worst_edges.append(i)\n\n            if worst_edges:\n                # Replace one of the worst edges with a better alternative\n                i = random.choice(worst_edges)\n                j = random.choice([x for x in range(n) if x != i and x != (i+1)%n and x != (i-1)%n])\n\n                # Create a new edge that might improve at least one objective\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Fall back to standard 2-opt if no bad edges found\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 166,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swaps: swap edges that improve the worst objective\n    for _ in range(3):  # Try a few swaps\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Calculate current and new costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        # Accept swap if at least one objective improves\n        if any(new < current for new, current in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6126529326758078,
            1.1481638431549073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swaps: swap edges that improve the worst objective\n    for _ in range(3):  # Try a few swaps\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Calculate current and new costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        # Accept swap if at least one objective improves\n        if any(new < current for new, current in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 167,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (could be replaced with a more sophisticated metric)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is not the best but has potential for improvement\n        selection_index = min(1, len(archive) - 1)  # Ensure we don't go out of bounds\n        base_solution = archive_sorted[selection_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining multiple operators\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize based on current solution's performance\n        current_obj = archive[np.where([np.array_equal(sol[0], base_solution) for sol in archive])[0][0]][1]\n        obj_weights = [1.0 / (1.0 + val) for val in current_obj]  # Higher weight for worse objectives\n        obj_to_improve = np.random.choice([0, 1, 2], p=np.array(obj_weights)/sum(obj_weights))\n\n        # Apply different operators based on the selected objective\n        if obj_to_improve == 0:\n            # 2-opt for the first objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif obj_to_improve == 1:\n            # Or-opt for the second objective\n            i, j, k = np.random.choice(n, 3, replace=False)\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:k], [node], new_solution[k:]])\n        else:\n            # Swap for the third objective\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Additional operator: sometimes apply a 2-opt even if not selected\n        if np.random.rand() < 0.3:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.735589883100711,
            1.1859357833862305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (could be replaced with a more sophisticated metric)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is not the best but has potential for improvement\n        selection_index = min(1, len(archive) - 1)  # Ensure we don't go out of bounds\n        base_solution = archive_sorted[selection_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining multiple operators\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize based on current solution's performance\n        current_obj = archive[np.where([np.array_equal(sol[0], base_solution) for sol in archive])[0][0]][1]\n        obj_weights = [1.0 / (1.0 + val) for val in current_obj]  # Higher weight for worse objectives\n        obj_to_improve = np.random.choice([0, 1, 2], p=np.array(obj_weights)/sum(obj_weights))\n\n        # Apply different operators based on the selected objective\n        if obj_to_improve == 0:\n            # 2-opt for the first objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif obj_to_improve == 1:\n            # Or-opt for the second objective\n            i, j, k = np.random.choice(n, 3, replace=False)\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:k], [node], new_solution[k:]])\n        else:\n            # Swap for the third objective\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Additional operator: sometimes apply a 2-opt even if not selected\n        if np.random.rand() < 0.3:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 168,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform a 2-opt move in the objective space with the highest improvement\n    # 2. If no improvement, perform a random 2-opt move\n    # 3. If still no improvement, perform a 3-opt move\n\n    n = len(new_solution)\n    improved = False\n\n    # Calculate current objectives\n    def calculate_objectives(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(base_solution)\n\n    # Try 2-opt moves in each objective space\n    for obj_idx in range(3):\n        if improved:\n            break\n\n        # Select the distance matrix based on the current objective\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Try all possible 2-opt moves\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if j - i == 1:\n                    continue  # Skip adjacent nodes\n\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                candidate[i:j+1] = candidate[i:j+1][::-1]\n\n                # Check if the candidate is better in the current objective\n                candidate_obj = calculate_objectives(candidate)\n                if candidate_obj[obj_idx] < current_obj[obj_idx]:\n                    new_solution = candidate\n                    current_obj = candidate_obj\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # If no improvement with 2-opt, try a random 2-opt move\n    if not improved:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n        if j - i > 1:\n            new_solution = new_solution.copy()\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            improved = True\n\n    # If still no improvement, perform a 3-opt move\n    if not improved:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        if j - i > 1 and k - j > 1:\n            candidate1 = new_solution.copy()\n            candidate1[i:j+1] = candidate1[i:j+1][::-1]\n\n            candidate2 = new_solution.copy()\n            candidate2[j:k+1] = candidate2[j:k+1][::-1]\n\n            candidate3 = new_solution.copy()\n            candidate3[i:k+1] = candidate3[i:k+1][::-1]\n\n            # Select the best candidate based on the sum of objectives\n            candidates = [candidate1, candidate2, candidate3]\n            best_candidate = min(candidates, key=lambda x: sum(calculate_objectives(x)))\n            new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.5867673239388226,
            2.7807188868522643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform a 2-opt move in the objective space with the highest improvement\n    # 2. If no improvement, perform a random 2-opt move\n    # 3. If still no improvement, perform a 3-opt move\n\n    n = len(new_solution)\n    improved = False\n\n    # Calculate current objectives\n    def calculate_objectives(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(base_solution)\n\n    # Try 2-opt moves in each objective space\n    for obj_idx in range(3):\n        if improved:\n            break\n\n        # Select the distance matrix based on the current objective\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Try all possible 2-opt moves\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if j - i == 1:\n                    continue  # Skip adjacent nodes\n\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                candidate[i:j+1] = candidate[i:j+1][::-1]\n\n                # Check if the candidate is better in the current objective\n                candidate_obj = calculate_objectives(candidate)\n                if candidate_obj[obj_idx] < current_obj[obj_idx]:\n                    new_solution = candidate\n                    current_obj = candidate_obj\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # If no improvement with 2-opt, try a random 2-opt move\n    if not improved:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n        if j - i > 1:\n            new_solution = new_solution.copy()\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            improved = True\n\n    # If still no improvement, perform a 3-opt move\n    if not improved:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        if j - i > 1 and k - j > 1:\n            candidate1 = new_solution.copy()\n            candidate1[i:j+1] = candidate1[i:j+1][::-1]\n\n            candidate2 = new_solution.copy()\n            candidate2[j:k+1] = candidate2[j:k+1][::-1]\n\n            candidate3 = new_solution.copy()\n            candidate3[i:k+1] = candidate3[i:k+1][::-1]\n\n            # Select the best candidate based on the sum of objectives\n            candidates = [candidate1, candidate2, candidate3]\n            best_candidate = min(candidates, key=lambda x: sum(calculate_objectives(x)))\n            new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 169,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest crowding distance (promising for further improvement)\n    def crowding_distance(solutions, objectives):\n        n = len(solutions)\n        distances = np.zeros(n)\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort([obj[m] for _, obj in solutions])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, n-1):\n                distances[sorted_idx[i]] += (solutions[sorted_idx[i+1]][1][m] - solutions[sorted_idx[i-1]][1][m])\n        return distances\n\n    distances = crowding_distance(archive, [obj for _, obj in archive])\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware selection\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Evaluate the swap in all three objectives\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional objective-aware 2-opt pass\n    for _ in range(5):\n        # Select edges based on the objective with the highest improvement potential\n        obj_weights = np.array([obj for _, obj in archive]).mean(axis=0)\n        selected_obj = np.argmax(obj_weights)\n\n        if selected_obj == 0:\n            dm = distance_matrix_1\n        elif selected_obj == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        worst_edge = None\n        worst_cost = -np.inf\n        for i in range(n):\n            cost = dm[new_solution[i-1], new_solution[i]]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = i\n\n        if worst_edge is not None:\n            # Try to replace this edge with a better one\n            best_improvement = 0\n            best_swap = None\n            for j in range(n):\n                if j == worst_edge or j == (worst_edge - 1) % n:\n                    continue\n                improvement = (dm[new_solution[worst_edge-1], new_solution[worst_edge]] +\n                              dm[new_solution[j-1], new_solution[j]]) - \\\n                             (dm[new_solution[worst_edge-1], new_solution[j]] +\n                              dm[new_solution[j-1], new_solution[worst_edge]])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = j\n\n            if best_swap is not None:\n                # Perform the swap\n                if worst_edge < best_swap:\n                    new_solution[worst_edge:best_swap+1] = new_solution[worst_edge:best_swap+1][::-1]\n                else:\n                    new_solution[best_swap:worst_edge+1] = new_solution[best_swap:worst_edge+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7572464254999901,
            2.2118608355522156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest crowding distance (promising for further improvement)\n    def crowding_distance(solutions, objectives):\n        n = len(solutions)\n        distances = np.zeros(n)\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort([obj[m] for _, obj in solutions])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, n-1):\n                distances[sorted_idx[i]] += (solutions[sorted_idx[i+1]][1][m] - solutions[sorted_idx[i-1]][1][m])\n        return distances\n\n    distances = crowding_distance(archive, [obj for _, obj in archive])\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware selection\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Evaluate the swap in all three objectives\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional objective-aware 2-opt pass\n    for _ in range(5):\n        # Select edges based on the objective with the highest improvement potential\n        obj_weights = np.array([obj for _, obj in archive]).mean(axis=0)\n        selected_obj = np.argmax(obj_weights)\n\n        if selected_obj == 0:\n            dm = distance_matrix_1\n        elif selected_obj == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        worst_edge = None\n        worst_cost = -np.inf\n        for i in range(n):\n            cost = dm[new_solution[i-1], new_solution[i]]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = i\n\n        if worst_edge is not None:\n            # Try to replace this edge with a better one\n            best_improvement = 0\n            best_swap = None\n            for j in range(n):\n                if j == worst_edge or j == (worst_edge - 1) % n:\n                    continue\n                improvement = (dm[new_solution[worst_edge-1], new_solution[worst_edge]] +\n                              dm[new_solution[j-1], new_solution[j]]) - \\\n                             (dm[new_solution[worst_edge-1], new_solution[j]] +\n                              dm[new_solution[j-1], new_solution[worst_edge]])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = j\n\n            if best_swap is not None:\n                # Perform the swap\n                if worst_edge < best_swap:\n                    new_solution[worst_edge:best_swap+1] = new_solution[worst_edge:best_swap+1][::-1]\n                else:\n                    new_solution[best_swap:worst_edge+1] = new_solution[best_swap:worst_edge+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 170,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    candidates = []\n    for sol, obj in archive:\n        # Calculate a score based on objective values and diversity\n        obj_score = sum(obj)  # Lower objectives are better\n        diversity_score = len(set(sol))  # Higher diversity is better\n        candidates.append((sol, obj_score, diversity_score))\n\n    # Sort by objective score (lower is better) and diversity score (higher is better)\n    candidates.sort(key=lambda x: (x[1], -x[2]))\n    selected_sol = candidates[0][0].copy()\n\n    # Apply hybrid local search: a combination of 2-opt and segment inversion\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Choose a local search operator based on random selection\n    operator = random.choice(['2opt', 'segment_inversion', 'swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator == 'segment_inversion':\n        # Invert a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator == 'swap':\n        # Swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_sol.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7152638309069369,
            2.007461357116699
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    candidates = []\n    for sol, obj in archive:\n        # Calculate a score based on objective values and diversity\n        obj_score = sum(obj)  # Lower objectives are better\n        diversity_score = len(set(sol))  # Higher diversity is better\n        candidates.append((sol, obj_score, diversity_score))\n\n    # Sort by objective score (lower is better) and diversity score (higher is better)\n    candidates.sort(key=lambda x: (x[1], -x[2]))\n    selected_sol = candidates[0][0].copy()\n\n    # Apply hybrid local search: a combination of 2-opt and segment inversion\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Choose a local search operator based on random selection\n    operator = random.choice(['2opt', 'segment_inversion', 'swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator == 'segment_inversion':\n        # Invert a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator == 'swap':\n        # Swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_sol.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 171,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move (local improvement)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps based on the worst objective\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n\n    # Choose the distance matrix based on the worst objective\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the pair of nodes that would most improve the worst objective\n    current_cost = sum(distance_matrix[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    best_improvement = 0\n    best_swap = None\n\n    for a in range(n):\n        for b in range(a+1, n):\n            # Calculate the change in cost if we swap nodes a and b\n            delta = (distance_matrix[new_solution[a-1], new_solution[b]] +\n                     distance_matrix[new_solution[b], new_solution[(a+1)%n]] +\n                     distance_matrix[new_solution[b-1], new_solution[a]] +\n                     distance_matrix[new_solution[a], new_solution[(b+1)%n]]) - \\\n                    (distance_matrix[new_solution[a-1], new_solution[a]] +\n                     distance_matrix[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix[new_solution[b-1], new_solution[b]] +\n                     distance_matrix[new_solution[b], new_solution[(b+1)%n]])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7279696667905939,
            2.2817869663238524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move (local improvement)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps based on the worst objective\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n\n    # Choose the distance matrix based on the worst objective\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the pair of nodes that would most improve the worst objective\n    current_cost = sum(distance_matrix[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    best_improvement = 0\n    best_swap = None\n\n    for a in range(n):\n        for b in range(a+1, n):\n            # Calculate the change in cost if we swap nodes a and b\n            delta = (distance_matrix[new_solution[a-1], new_solution[b]] +\n                     distance_matrix[new_solution[b], new_solution[(a+1)%n]] +\n                     distance_matrix[new_solution[b-1], new_solution[a]] +\n                     distance_matrix[new_solution[a], new_solution[(b+1)%n]]) - \\\n                    (distance_matrix[new_solution[a-1], new_solution[a]] +\n                     distance_matrix[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix[new_solution[b-1], new_solution[b]] +\n                     distance_matrix[new_solution[b], new_solution[(b+1)%n]])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 172,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with higher objective values (worse solutions) that might be improved\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just do a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 2-opt move with objective-aware selection\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Evaluate potential moves in both directions\n        def evaluate_move(sol, a, b, c, d):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[sol[a], sol[b]] + distance_matrix_1[sol[c], sol[d]] -\n                      distance_matrix_1[sol[a], sol[c]] - distance_matrix_1[sol[b], sol[d]])\n            delta2 = (distance_matrix_2[sol[a], sol[b]] + distance_matrix_2[sol[c], sol[d]] -\n                      distance_matrix_2[sol[a], sol[c]] - distance_matrix_2[sol[b], sol[d]])\n            delta3 = (distance_matrix_3[sol[a], sol[b]] + distance_matrix_3[sol[c], sol[d]] -\n                      distance_matrix_3[sol[a], sol[c]] - distance_matrix_3[sol[b], sol[d]])\n            return (delta1, delta2, delta3)\n\n        # Consider both possible 2-opt moves (i,j and k,l)\n        delta1 = evaluate_move(new_solution, i, (i+1)%n, j, (j+1)%n)\n        delta2 = evaluate_move(new_solution, k, (k+1)%n, l, (l+1)%n)\n\n        # Choose the move that improves the most in the most objectives\n        if sum(delta1) < sum(delta2):\n            # Perform the first 2-opt move\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # Perform the second 2-opt move\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n        # Additional objective-aware swap to further improve\n        # Find the pair of nodes that, when swapped, improves the most objectives\n        best_improvement = (0, 0, 0)\n        best_pair = (0, 0)\n\n        for a in range(n):\n            for b in range(a+1, n):\n                delta = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] -\n                        distance_matrix_1[new_solution[a], new_solution[b]] - distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n                delta1 = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] -\n                         distance_matrix_1[new_solution[a], new_solution[b]] - distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] -\n                         distance_matrix_2[new_solution[a], new_solution[b]] - distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n                delta3 = (distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]] -\n                         distance_matrix_3[new_solution[a], new_solution[b]] - distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n\n                if (delta1, delta2, delta3) > best_improvement:\n                    best_improvement = (delta1, delta2, delta3)\n                    best_pair = (a, b)\n\n        if best_improvement != (0, 0, 0):\n            a, b = best_pair\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6992685516359171,
            3.8609255194664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with higher objective values (worse solutions) that might be improved\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just do a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 2-opt move with objective-aware selection\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Evaluate potential moves in both directions\n        def evaluate_move(sol, a, b, c, d):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[sol[a], sol[b]] + distance_matrix_1[sol[c], sol[d]] -\n                      distance_matrix_1[sol[a], sol[c]] - distance_matrix_1[sol[b], sol[d]])\n            delta2 = (distance_matrix_2[sol[a], sol[b]] + distance_matrix_2[sol[c], sol[d]] -\n                      distance_matrix_2[sol[a], sol[c]] - distance_matrix_2[sol[b], sol[d]])\n            delta3 = (distance_matrix_3[sol[a], sol[b]] + distance_matrix_3[sol[c], sol[d]] -\n                      distance_matrix_3[sol[a], sol[c]] - distance_matrix_3[sol[b], sol[d]])\n            return (delta1, delta2, delta3)\n\n        # Consider both possible 2-opt moves (i,j and k,l)\n        delta1 = evaluate_move(new_solution, i, (i+1)%n, j, (j+1)%n)\n        delta2 = evaluate_move(new_solution, k, (k+1)%n, l, (l+1)%n)\n\n        # Choose the move that improves the most in the most objectives\n        if sum(delta1) < sum(delta2):\n            # Perform the first 2-opt move\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # Perform the second 2-opt move\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n        # Additional objective-aware swap to further improve\n        # Find the pair of nodes that, when swapped, improves the most objectives\n        best_improvement = (0, 0, 0)\n        best_pair = (0, 0)\n\n        for a in range(n):\n            for b in range(a+1, n):\n                delta = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] -\n                        distance_matrix_1[new_solution[a], new_solution[b]] - distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n                delta1 = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] -\n                         distance_matrix_1[new_solution[a], new_solution[b]] - distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] -\n                         distance_matrix_2[new_solution[a], new_solution[b]] - distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n                delta3 = (distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]] -\n                         distance_matrix_3[new_solution[a], new_solution[b]] - distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n\n                if (delta1, delta2, delta3) > best_improvement:\n                    best_improvement = (delta1, delta2, delta3)\n                    best_pair = (a, b)\n\n        if best_improvement != (0, 0, 0):\n            a, b = best_pair\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 173,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n_nodes = len(new_solution)\n    if n_nodes < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, apply a more sophisticated operator\n        operator = random.choice(['2opt', 'oropt', 'swap', 'inversion'])\n\n        if operator == '2opt':\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif operator == 'oropt':\n            # Or-opt local search\n            i = random.randint(0, n_nodes - 3)\n            j = random.randint(i + 2, min(i + 4, n_nodes - 1))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n        elif operator == 'swap':\n            # Swap two segments\n            i = random.randint(0, n_nodes - 2)\n            j = random.randint(i + 1, n_nodes - 1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif operator == 'inversion':\n            # Inversion of a segment\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5878063538244392,
            1.3453614711761475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n_nodes = len(new_solution)\n    if n_nodes < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, apply a more sophisticated operator\n        operator = random.choice(['2opt', 'oropt', 'swap', 'inversion'])\n\n        if operator == '2opt':\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif operator == 'oropt':\n            # Or-opt local search\n            i = random.randint(0, n_nodes - 3)\n            j = random.randint(i + 2, min(i + 4, n_nodes - 1))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n        elif operator == 'swap':\n            # Swap two segments\n            i = random.randint(0, n_nodes - 2)\n            j = random.randint(i + 1, n_nodes - 1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif operator == 'inversion':\n            # Inversion of a segment\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 174,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    objective_variance = np.var(norm_objectives, axis=1)\n    selected_idx = np.argmax(objective_variance)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # 1. 2-opt local search (for one objective)\n        i, j = np.random.choice(N, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # 2. Edge insertion (for another objective)\n        k = np.random.randint(0, N)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # 3. Multi-objective edge exchange (novel heuristic)\n        # Select edges that are critical in at least two objectives\n        for _ in range(2):\n            a, b = np.random.choice(N, 2, replace=False)\n            if a > b:\n                a, b = b, a\n            # Check if swapping these edges improves any two objectives\n            cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_3[new_solution[a-1], new_solution[a]])\n            cost2 = (distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_3[new_solution[b-1], new_solution[b]])\n            if cost1 + cost2 > 0:  # If current edges are costly in multiple objectives\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates)\n    assert len(np.unique(new_solution)) == N, \"Generated solution is invalid\"\n    return new_solution\n\n",
        "score": [
            -0.7621713519163319,
            1.523484742641449
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    objective_variance = np.var(norm_objectives, axis=1)\n    selected_idx = np.argmax(objective_variance)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # 1. 2-opt local search (for one objective)\n        i, j = np.random.choice(N, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # 2. Edge insertion (for another objective)\n        k = np.random.randint(0, N)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # 3. Multi-objective edge exchange (novel heuristic)\n        # Select edges that are critical in at least two objectives\n        for _ in range(2):\n            a, b = np.random.choice(N, 2, replace=False)\n            if a > b:\n                a, b = b, a\n            # Check if swapping these edges improves any two objectives\n            cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_3[new_solution[a-1], new_solution[a]])\n            cost2 = (distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_3[new_solution[b-1], new_solution[b]])\n            if cost1 + cost2 > 0:  # If current edges are costly in multiple objectives\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates)\n    assert len(np.unique(new_solution)) == N, \"Generated solution is invalid\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 175,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a combination of objectives\n    # Here we use a simple approach: select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate the current cost for each objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for a, b in zip(solution, np.roll(solution, -1)):\n            cost += distance_matrix[a, b]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    current_cost3 = calculate_cost(new_solution, distance_matrix_3)\n\n    # Try swapping nodes that are \"critical\" in one objective but not in others\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Create a temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new costs\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n        new_cost3 = calculate_cost(temp_solution, distance_matrix_3)\n\n        # Accept the swap if it improves at least one objective while not worsening others too much\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or new_cost3 < current_cost3) and \\\n           not (new_cost1 > current_cost1 * 1.1 or new_cost2 > current_cost2 * 1.1 or new_cost3 > current_cost3 * 1.1):\n            new_solution = temp_solution\n            current_cost1, current_cost2, current_cost3 = new_cost1, new_cost2, new_cost3\n            break  # Accept the first improvement\n\n    return new_solution\n\n",
        "score": [
            -0.7230242102471847,
            2.2602384090423584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a combination of objectives\n    # Here we use a simple approach: select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate the current cost for each objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for a, b in zip(solution, np.roll(solution, -1)):\n            cost += distance_matrix[a, b]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    current_cost3 = calculate_cost(new_solution, distance_matrix_3)\n\n    # Try swapping nodes that are \"critical\" in one objective but not in others\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Create a temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new costs\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n        new_cost3 = calculate_cost(temp_solution, distance_matrix_3)\n\n        # Accept the swap if it improves at least one objective while not worsening others too much\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or new_cost3 < current_cost3) and \\\n           not (new_cost1 > current_cost1 * 1.1 or new_cost2 > current_cost2 * 1.1 or new_cost3 > current_cost3 * 1.1):\n            new_solution = temp_solution\n            current_cost1, current_cost2, current_cost3 = new_cost1, new_cost2, new_cost3\n            break  # Accept the first improvement\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 176,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions in the archive\n        crowding_distances = []\n        objectives = np.array([obj for (sol, obj) in archive])\n        for i in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            sorted_obj = objectives[sorted_idx, i]\n            crowding = np.zeros(len(archive))\n            crowding[0] = crowding[-1] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] = (sorted_obj[j+1] - sorted_obj[j-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n            crowding_distances.append(crowding)\n        crowding_distances = np.sum(crowding_distances, axis=0)\n        # Select a solution with high crowding distance (potential for improvement)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and random swap\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on the solution\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for random swap\n        # Perform a random swap\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6061591031487735,
            1.7680338978767396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions in the archive\n        crowding_distances = []\n        objectives = np.array([obj for (sol, obj) in archive])\n        for i in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            sorted_obj = objectives[sorted_idx, i]\n            crowding = np.zeros(len(archive))\n            crowding[0] = crowding[-1] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] = (sorted_obj[j+1] - sorted_obj[j-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n            crowding_distances.append(crowding)\n        crowding_distances = np.sum(crowding_distances, axis=0)\n        # Select a solution with high crowding distance (potential for improvement)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and random swap\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on the solution\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for random swap\n        # Perform a random swap\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 177,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Calculate improvement potential based on average distance reduction\n    improvement_potential = []\n    for i in range(len(archive)):\n        sol, obj = archive[i]\n        avg_dist = (obj[0] + obj[1] + obj[2]) / 3\n        improvement_potential.append(avg_dist)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge swapping\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two non-adjacent edges to swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure we don't select adjacent edges\n        if abs(i - j) > 1 and abs(k - l) > 1:\n            # Perform a double-bridge move (more complex than 2-opt)\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[j:k+1],\n                new_solution[i:j],\n                new_solution[l+1:],\n                new_solution[k+1:l+1]\n            ])\n\n            # Verify feasibility (no duplicates and all nodes visited)\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # If no improvement found, perform a simpler 2-opt move\n    if _ == 9:  # If loop completed without improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and abs(i - j) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.69467072689852,
            0.4555209279060364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Calculate improvement potential based on average distance reduction\n    improvement_potential = []\n    for i in range(len(archive)):\n        sol, obj = archive[i]\n        avg_dist = (obj[0] + obj[1] + obj[2]) / 3\n        improvement_potential.append(avg_dist)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge swapping\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two non-adjacent edges to swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure we don't select adjacent edges\n        if abs(i - j) > 1 and abs(k - l) > 1:\n            # Perform a double-bridge move (more complex than 2-opt)\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[j:k+1],\n                new_solution[i:j],\n                new_solution[l+1:],\n                new_solution[k+1:l+1]\n            ])\n\n            # Verify feasibility (no duplicates and all nodes visited)\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # If no improvement found, perform a simpler 2-opt move\n    if _ == 9:  # If loop completed without improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and abs(i - j) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 177,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Calculate improvement potential based on average distance reduction\n    improvement_potential = []\n    for i in range(len(archive)):\n        sol, obj = archive[i]\n        avg_dist = (obj[0] + obj[1] + obj[2]) / 3\n        improvement_potential.append(avg_dist)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge swapping\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two non-adjacent edges to swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure we don't select adjacent edges\n        if abs(i - j) > 1 and abs(k - l) > 1:\n            # Perform a double-bridge move (more complex than 2-opt)\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[j:k+1],\n                new_solution[i:j],\n                new_solution[l+1:],\n                new_solution[k+1:l+1]\n            ])\n\n            # Verify feasibility (no duplicates and all nodes visited)\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # If no improvement found, perform a simpler 2-opt move\n    if _ == 9:  # If loop completed without improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and abs(i - j) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.69467072689852,
            0.4555209279060364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Calculate improvement potential based on average distance reduction\n    improvement_potential = []\n    for i in range(len(archive)):\n        sol, obj = archive[i]\n        avg_dist = (obj[0] + obj[1] + obj[2]) / 3\n        improvement_potential.append(avg_dist)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge swapping\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two non-adjacent edges to swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure we don't select adjacent edges\n        if abs(i - j) > 1 and abs(k - l) > 1:\n            # Perform a double-bridge move (more complex than 2-opt)\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[j:k+1],\n                new_solution[i:j],\n                new_solution[l+1:],\n                new_solution[k+1:l+1]\n            ])\n\n            # Verify feasibility (no duplicates and all nodes visited)\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # If no improvement found, perform a simpler 2-opt move\n    if _ == 9:  # If loop completed without improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and abs(i - j) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 178,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 10% of solutions with highest objective sums\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 10)]\n        # Randomly select one of the top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with a probability of 0.7\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply node insertion with a probability of 0.3\n    else:\n        i = random.randint(0, len(new_solution)-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # 3. Occasionally apply a 3-opt move for diversification (10% probability)\n    if random.random() < 0.1:\n        a, b, c = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution[a:c+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.55537845220288,
            0.9476100087165833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 10% of solutions with highest objective sums\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 10)]\n        # Randomly select one of the top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with a probability of 0.7\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply node insertion with a probability of 0.3\n    else:\n        i = random.randint(0, len(new_solution)-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # 3. Occasionally apply a 3-opt move for diversification (10% probability)\n    if random.random() < 0.1:\n        a, b, c = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution[a:c+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 179,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest total distance in any objective)\n    objectives = [obj for _, obj in archive]\n    max_distances = [max(obj) for obj in objectives]\n    selected_idx = np.argmax(max_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # If the swap improves at least one objective, apply it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n            new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    return new_solution\n\n",
        "score": [
            -0.6958345282395584,
            1.4227543592453002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest total distance in any objective)\n    objectives = [obj for _, obj in archive]\n    max_distances = [max(obj) for obj in objectives]\n    selected_idx = np.argmax(max_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # If the swap improves at least one objective, apply it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n            new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 180,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and random swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Perform 2-opt on the worst objective space\n    objectives = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                  sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                  sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        dm = distance_matrix_1\n    elif worst_obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    # Find the worst edge in the worst objective space\n    max_gain = 0\n    best_i, best_j = 0, 0\n    for i in range(n):\n        for j in range(i+2, n):\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n            gain = dm[a, b] + dm[c, d] - dm[a, c] - dm[b, d]\n            if gain > max_gain:\n                max_gain = gain\n                best_i, best_j = i, j\n\n    if max_gain > 0:\n        # Perform 2-opt\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n    else:\n        # If no improvement, perform a random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5929855764031225,
            1.27584867477417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and random swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Perform 2-opt on the worst objective space\n    objectives = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                  sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                  sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        dm = distance_matrix_1\n    elif worst_obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    # Find the worst edge in the worst objective space\n    max_gain = 0\n    best_i, best_j = 0, 0\n    for i in range(n):\n        for j in range(i+2, n):\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n            gain = dm[a, b] + dm[c, d] - dm[a, c] - dm[b, d]\n            if gain > max_gain:\n                max_gain = gain\n                best_i, best_j = i, j\n\n    if max_gain > 0:\n        # Perform 2-opt\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n    else:\n        # If no improvement, perform a random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 181,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (1 + normalized_objectives.sum(axis=1))  # Higher weights for worse solutions (more room for improvement)\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly choose between 2-opt and node insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node insertion\n        i, j = random.sample(range(n_nodes), 2)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = np.random.randint(0, n_nodes - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates and all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        missing_nodes = np.setdiff1d(np.arange(n_nodes), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, n_nodes)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7793581426238371,
            1.2934807777404784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (1 + normalized_objectives.sum(axis=1))  # Higher weights for worse solutions (more room for improvement)\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly choose between 2-opt and node insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node insertion\n        i, j = random.sample(range(n_nodes), 2)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = np.random.randint(0, n_nodes - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates and all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        missing_nodes = np.setdiff1d(np.arange(n_nodes), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, n_nodes)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 182,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a probability based on the solution's potential\n    if random.random() < 0.7:  # Higher probability for better solutions\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation: swap nodes based on their contribution to each objective\n    if random.random() < 0.3:  # Lower probability for diversification\n        # Calculate node contributions to each objective\n        contributions = np.zeros(n)\n        for k in range(n-1):\n            a, b = new_solution[k], new_solution[k+1]\n            contributions[a] += distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]\n            contributions[b] += distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]\n\n        # Identify nodes with high contribution (potential for improvement)\n        high_contrib_nodes = np.argsort(contributions)[-max(2, n//5):]\n\n        # Swap nodes to reduce high contributions\n        if len(high_contrib_nodes) >= 2:\n            a, b = random.sample(list(high_contrib_nodes), 2)\n            idx_a = np.where(new_solution == a)[0][0]\n            idx_b = np.where(new_solution == b)[0][0]\n            new_solution[idx_a], new_solution[idx_b] = new_solution[idx_b], new_solution[idx_a]\n\n    return new_solution\n\n",
        "score": [
            -0.6502643201419525,
            1.5315411686897278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a probability based on the solution's potential\n    if random.random() < 0.7:  # Higher probability for better solutions\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation: swap nodes based on their contribution to each objective\n    if random.random() < 0.3:  # Lower probability for diversification\n        # Calculate node contributions to each objective\n        contributions = np.zeros(n)\n        for k in range(n-1):\n            a, b = new_solution[k], new_solution[k+1]\n            contributions[a] += distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]\n            contributions[b] += distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]\n\n        # Identify nodes with high contribution (potential for improvement)\n        high_contrib_nodes = np.argsort(contributions)[-max(2, n//5):]\n\n        # Swap nodes to reduce high contributions\n        if len(high_contrib_nodes) >= 2:\n            a, b = random.sample(list(high_contrib_nodes), 2)\n            idx_a = np.where(new_solution == a)[0][0]\n            idx_b = np.where(new_solution == b)[0][0]\n            new_solution[idx_a], new_solution[idx_b] = new_solution[idx_b], new_solution[idx_a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 183,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potentials = 1 - normalized_objectives.mean(axis=1)\n    probabilities = improvement_potentials / improvement_potentials.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select one of three specialized operators\n    operator = random.choice(['2-opt', '3-opt', 'multi-objective_swap'])\n\n    if operator == '2-opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(len(base_solution)), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = np.flip(new_solution[i:j])\n    elif operator == '3-opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(len(base_solution)), 3))\n        segment1 = base_solution[i:j]\n        segment2 = base_solution[j:k]\n        new_solution = np.concatenate([base_solution[:i], segment2, segment1, base_solution[k:]])\n    else:\n        # Multi-objective aware swap operator\n        # Select nodes that are critical in at least one objective\n        critical_nodes = set()\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                distances = distance_matrix_1\n            elif obj_idx == 1:\n                distances = distance_matrix_2\n            else:\n                distances = distance_matrix_3\n\n            # Find nodes with high contribution to total distance\n            total_dist = 0\n            node_contributions = np.zeros(len(base_solution))\n            for i in range(len(base_solution)-1):\n                u = base_solution[i]\n                v = base_solution[i+1]\n                dist = distances[u, v]\n                total_dist += dist\n                node_contributions[u] += dist\n                node_contributions[v] += dist\n\n            # Select nodes that contribute more than average\n            avg_contribution = total_dist / len(base_solution)\n            critical_nodes.update(np.where(node_contributions > avg_contribution)[0])\n\n        if len(critical_nodes) >= 2:\n            # Perform swap between critical nodes\n            critical_list = list(critical_nodes)\n            i, j = random.sample(critical_list, 2)\n            new_solution = base_solution.copy()\n            pos_i = np.where(new_solution == i)[0][0]\n            pos_j = np.where(new_solution == j)[0][0]\n            new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n        else:\n            # Fall back to random swap if no critical nodes found\n            i, j = random.sample(range(len(base_solution)), 2)\n            new_solution = base_solution.copy()\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8413481609328878,
            1.1518761396408081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potentials = 1 - normalized_objectives.mean(axis=1)\n    probabilities = improvement_potentials / improvement_potentials.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select one of three specialized operators\n    operator = random.choice(['2-opt', '3-opt', 'multi-objective_swap'])\n\n    if operator == '2-opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(len(base_solution)), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = np.flip(new_solution[i:j])\n    elif operator == '3-opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(len(base_solution)), 3))\n        segment1 = base_solution[i:j]\n        segment2 = base_solution[j:k]\n        new_solution = np.concatenate([base_solution[:i], segment2, segment1, base_solution[k:]])\n    else:\n        # Multi-objective aware swap operator\n        # Select nodes that are critical in at least one objective\n        critical_nodes = set()\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                distances = distance_matrix_1\n            elif obj_idx == 1:\n                distances = distance_matrix_2\n            else:\n                distances = distance_matrix_3\n\n            # Find nodes with high contribution to total distance\n            total_dist = 0\n            node_contributions = np.zeros(len(base_solution))\n            for i in range(len(base_solution)-1):\n                u = base_solution[i]\n                v = base_solution[i+1]\n                dist = distances[u, v]\n                total_dist += dist\n                node_contributions[u] += dist\n                node_contributions[v] += dist\n\n            # Select nodes that contribute more than average\n            avg_contribution = total_dist / len(base_solution)\n            critical_nodes.update(np.where(node_contributions > avg_contribution)[0])\n\n        if len(critical_nodes) >= 2:\n            # Perform swap between critical nodes\n            critical_list = list(critical_nodes)\n            i, j = random.sample(critical_list, 2)\n            new_solution = base_solution.copy()\n            pos_i = np.where(new_solution == i)[0][0]\n            pos_j = np.where(new_solution == j)[0][0]\n            new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n        else:\n            # Fall back to random swap if no critical nodes found\n            i, j = random.sample(range(len(base_solution)), 2)\n            new_solution = base_solution.copy()\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 183,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potentials = 1 - normalized_objectives.mean(axis=1)\n    probabilities = improvement_potentials / improvement_potentials.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select one of three specialized operators\n    operator = random.choice(['2-opt', '3-opt', 'multi-objective_swap'])\n\n    if operator == '2-opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(len(base_solution)), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = np.flip(new_solution[i:j])\n    elif operator == '3-opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(len(base_solution)), 3))\n        segment1 = base_solution[i:j]\n        segment2 = base_solution[j:k]\n        new_solution = np.concatenate([base_solution[:i], segment2, segment1, base_solution[k:]])\n    else:\n        # Multi-objective aware swap operator\n        # Select nodes that are critical in at least one objective\n        critical_nodes = set()\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                distances = distance_matrix_1\n            elif obj_idx == 1:\n                distances = distance_matrix_2\n            else:\n                distances = distance_matrix_3\n\n            # Find nodes with high contribution to total distance\n            total_dist = 0\n            node_contributions = np.zeros(len(base_solution))\n            for i in range(len(base_solution)-1):\n                u = base_solution[i]\n                v = base_solution[i+1]\n                dist = distances[u, v]\n                total_dist += dist\n                node_contributions[u] += dist\n                node_contributions[v] += dist\n\n            # Select nodes that contribute more than average\n            avg_contribution = total_dist / len(base_solution)\n            critical_nodes.update(np.where(node_contributions > avg_contribution)[0])\n\n        if len(critical_nodes) >= 2:\n            # Perform swap between critical nodes\n            critical_list = list(critical_nodes)\n            i, j = random.sample(critical_list, 2)\n            new_solution = base_solution.copy()\n            pos_i = np.where(new_solution == i)[0][0]\n            pos_j = np.where(new_solution == j)[0][0]\n            new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n        else:\n            # Fall back to random swap if no critical nodes found\n            i, j = random.sample(range(len(base_solution)), 2)\n            new_solution = base_solution.copy()\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8413481609328878,
            1.1518761396408081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potentials = 1 - normalized_objectives.mean(axis=1)\n    probabilities = improvement_potentials / improvement_potentials.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select one of three specialized operators\n    operator = random.choice(['2-opt', '3-opt', 'multi-objective_swap'])\n\n    if operator == '2-opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(len(base_solution)), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = np.flip(new_solution[i:j])\n    elif operator == '3-opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(len(base_solution)), 3))\n        segment1 = base_solution[i:j]\n        segment2 = base_solution[j:k]\n        new_solution = np.concatenate([base_solution[:i], segment2, segment1, base_solution[k:]])\n    else:\n        # Multi-objective aware swap operator\n        # Select nodes that are critical in at least one objective\n        critical_nodes = set()\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                distances = distance_matrix_1\n            elif obj_idx == 1:\n                distances = distance_matrix_2\n            else:\n                distances = distance_matrix_3\n\n            # Find nodes with high contribution to total distance\n            total_dist = 0\n            node_contributions = np.zeros(len(base_solution))\n            for i in range(len(base_solution)-1):\n                u = base_solution[i]\n                v = base_solution[i+1]\n                dist = distances[u, v]\n                total_dist += dist\n                node_contributions[u] += dist\n                node_contributions[v] += dist\n\n            # Select nodes that contribute more than average\n            avg_contribution = total_dist / len(base_solution)\n            critical_nodes.update(np.where(node_contributions > avg_contribution)[0])\n\n        if len(critical_nodes) >= 2:\n            # Perform swap between critical nodes\n            critical_list = list(critical_nodes)\n            i, j = random.sample(critical_list, 2)\n            new_solution = base_solution.copy()\n            pos_i = np.where(new_solution == i)[0][0]\n            pos_j = np.where(new_solution == j)[0][0]\n            new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n        else:\n            # Fall back to random swap if no critical nodes found\n            i, j = random.sample(range(len(base_solution)), 2)\n            new_solution = base_solution.copy()\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 184,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best objective value in the most crowded objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 2-opt move with objective-aware selection\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        k, l = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Evaluate the move in all three objectives\n        def evaluate_move(sol):\n            total_1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            total_2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            total_3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n            return total_1, total_2, total_3\n\n        original_cost = evaluate_move(new_solution)\n\n        # Try both possible 2-opt moves and select the better one based on Pareto dominance\n        temp_sol = new_solution.copy()\n        temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n        cost_2opt = evaluate_move(temp_sol)\n\n        temp_sol = new_solution.copy()\n        temp_sol[k:l+1] = temp_sol[k:l+1][::-1]\n        cost_2opt_alt = evaluate_move(temp_sol)\n\n        # Compare moves using Pareto dominance\n        def dominates(a, b):\n            return all(x <= y for x, y in zip(a, b)) and any(x < y for x, y in zip(a, b))\n\n        if dominates(cost_2opt, original_cost) and (not dominates(cost_2opt_alt, cost_2opt)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif dominates(cost_2opt_alt, original_cost) and (not dominates(cost_2opt, cost_2opt_alt)):\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            # If no move dominates, randomly select one\n            if np.random.rand() < 0.5 and dominates(cost_2opt, original_cost):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif dominates(cost_2opt_alt, original_cost):\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Perform an insertion move with objective-aware selection\n        if n > 3:\n            pos = np.random.randint(0, n)\n            node = new_solution[pos]\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7824635897402277,
            1.0150890946388245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best objective value in the most crowded objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 2-opt move with objective-aware selection\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        k, l = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Evaluate the move in all three objectives\n        def evaluate_move(sol):\n            total_1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            total_2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            total_3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n            return total_1, total_2, total_3\n\n        original_cost = evaluate_move(new_solution)\n\n        # Try both possible 2-opt moves and select the better one based on Pareto dominance\n        temp_sol = new_solution.copy()\n        temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n        cost_2opt = evaluate_move(temp_sol)\n\n        temp_sol = new_solution.copy()\n        temp_sol[k:l+1] = temp_sol[k:l+1][::-1]\n        cost_2opt_alt = evaluate_move(temp_sol)\n\n        # Compare moves using Pareto dominance\n        def dominates(a, b):\n            return all(x <= y for x, y in zip(a, b)) and any(x < y for x, y in zip(a, b))\n\n        if dominates(cost_2opt, original_cost) and (not dominates(cost_2opt_alt, cost_2opt)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif dominates(cost_2opt_alt, original_cost) and (not dominates(cost_2opt, cost_2opt_alt)):\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            # If no move dominates, randomly select one\n            if np.random.rand() < 0.5 and dominates(cost_2opt, original_cost):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif dominates(cost_2opt_alt, original_cost):\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Perform an insertion move with objective-aware selection\n        if n > 3:\n            pos = np.random.randint(0, n)\n            node = new_solution[pos]\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 185,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in any objective)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential: solutions with lower objectives are more promising\n    objectives_array = np.array(archive_objectives)\n    normalized_objectives = (objectives_array - np.min(objectives_array, axis=0)) / (np.max(objectives_array, axis=0) - np.min(objectives_array, axis=0) + 1e-10)\n    improvement_scores = np.sum(normalized_objectives, axis=1)\n    top_indices = np.argsort(improvement_scores)[:max(1, len(archive) // 5)]  # Top 20% or at least 1\n\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_length = np.random.randint(2, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment (2-opt move)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply a 3-opt move for further perturbation\n    if n >= 6:\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.742220705300577,
            0.7742461085319519
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in any objective)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential: solutions with lower objectives are more promising\n    objectives_array = np.array(archive_objectives)\n    normalized_objectives = (objectives_array - np.min(objectives_array, axis=0)) / (np.max(objectives_array, axis=0) - np.min(objectives_array, axis=0) + 1e-10)\n    improvement_scores = np.sum(normalized_objectives, axis=1)\n    top_indices = np.argsort(improvement_scores)[:max(1, len(archive) // 5)]  # Top 20% or at least 1\n\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_length = np.random.randint(2, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment (2-opt move)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply a 3-opt move for further perturbation\n    if n >= 6:\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 186,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    # Here, we sort solutions by the sum of their objectives and pick the top 30% as candidates\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = int(0.3 * len(sorted_archive))\n    candidates = [sol[0] for sol in sorted_archive[:candidate_indices]]\n\n    if not candidates:\n        candidates = [sol[0] for sol in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, use swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Decide between 2-opt and 3-opt based on the current solution's characteristics\n        use_3opt = random.random() < 0.3  # 30% chance for 3-opt\n\n        if use_3opt and n >= 4:\n            # 3-opt move: select three distinct edges and reconnect them\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Create all possible reconnections\n            reconnections = [\n                (i, j, k),\n                (i, k, j),\n                (j, i, k),\n                (j, k, i),\n                (k, i, j),\n                (k, j, i)\n            ]\n            # Evaluate each reconnection based on the sum of all three objectives\n            best_reconnection = None\n            min_cost = float('inf')\n\n            for recon in reconnections:\n                temp_sol = new_solution.copy()\n                # Apply the reconnection\n                temp_sol[recon[0]], temp_sol[recon[1]], temp_sol[recon[2]] = \\\n                    temp_sol[recon[1]], temp_sol[recon[2]], temp_sol[recon[0]]\n\n                # Calculate total cost across all three objectives\n                cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                cost3 = sum(distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                total_cost = cost1 + cost2 + cost3\n\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_reconnection = recon\n\n            if best_reconnection:\n                new_solution[best_reconnection[0]], new_solution[best_reconnection[1]], new_solution[best_reconnection[2]] = \\\n                    new_solution[best_reconnection[1]], new_solution[best_reconnection[2]], new_solution[best_reconnection[0]]\n        else:\n            # 2-opt move: select two edges and flip the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6308254173190581,
            0.6172352313995362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    # Here, we sort solutions by the sum of their objectives and pick the top 30% as candidates\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = int(0.3 * len(sorted_archive))\n    candidates = [sol[0] for sol in sorted_archive[:candidate_indices]]\n\n    if not candidates:\n        candidates = [sol[0] for sol in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, use swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Decide between 2-opt and 3-opt based on the current solution's characteristics\n        use_3opt = random.random() < 0.3  # 30% chance for 3-opt\n\n        if use_3opt and n >= 4:\n            # 3-opt move: select three distinct edges and reconnect them\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Create all possible reconnections\n            reconnections = [\n                (i, j, k),\n                (i, k, j),\n                (j, i, k),\n                (j, k, i),\n                (k, i, j),\n                (k, j, i)\n            ]\n            # Evaluate each reconnection based on the sum of all three objectives\n            best_reconnection = None\n            min_cost = float('inf')\n\n            for recon in reconnections:\n                temp_sol = new_solution.copy()\n                # Apply the reconnection\n                temp_sol[recon[0]], temp_sol[recon[1]], temp_sol[recon[2]] = \\\n                    temp_sol[recon[1]], temp_sol[recon[2]], temp_sol[recon[0]]\n\n                # Calculate total cost across all three objectives\n                cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                cost3 = sum(distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                total_cost = cost1 + cost2 + cost3\n\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_reconnection = recon\n\n            if best_reconnection:\n                new_solution[best_reconnection[0]], new_solution[best_reconnection[1]], new_solution[best_reconnection[2]] = \\\n                    new_solution[best_reconnection[1]], new_solution[best_reconnection[2]], new_solution[best_reconnection[0]]\n        else:\n            # 2-opt move: select two edges and flip the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 187,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total distance across objectives)\n    total_distances = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(total_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest current cost\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective\n    worst_edge = -1\n    max_dist = -1\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        if dist_matrix[u, v] > max_dist:\n            max_dist = dist_matrix[u, v]\n            worst_edge = i\n\n    # Perform 2-opt on the worst edge\n    if worst_edge != -1:\n        i = worst_edge\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Try reversing the segment between i+1 and j\n        temp_solution = new_solution.copy()\n        temp_solution[i+1:j+1] = new_solution[j:i:-1]\n\n        # Check if the new solution is better in the worst objective\n        new_dist = sum(dist_matrix[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        old_dist = sum(dist_matrix[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if new_dist < old_dist:\n            new_solution = temp_solution\n\n    # Perform edge exchange to improve other objectives\n    for _ in range(5):  # Limit the number of exchanges to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Try swapping edges (i,i+1) and (j,j+1)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check if the new solution is better in at least one objective\n        improved = False\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                dm = distance_matrix_1\n            elif obj_idx == 1:\n                dm = distance_matrix_2\n            else:\n                dm = distance_matrix_3\n\n            new_dist = sum(dm[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            old_dist = sum(dm[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if new_dist < old_dist:\n                improved = True\n                break\n\n        if improved:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7411998433541893,
            1.7784982323646545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total distance across objectives)\n    total_distances = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(total_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest current cost\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective\n    worst_edge = -1\n    max_dist = -1\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        if dist_matrix[u, v] > max_dist:\n            max_dist = dist_matrix[u, v]\n            worst_edge = i\n\n    # Perform 2-opt on the worst edge\n    if worst_edge != -1:\n        i = worst_edge\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Try reversing the segment between i+1 and j\n        temp_solution = new_solution.copy()\n        temp_solution[i+1:j+1] = new_solution[j:i:-1]\n\n        # Check if the new solution is better in the worst objective\n        new_dist = sum(dist_matrix[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        old_dist = sum(dist_matrix[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if new_dist < old_dist:\n            new_solution = temp_solution\n\n    # Perform edge exchange to improve other objectives\n    for _ in range(5):  # Limit the number of exchanges to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Try swapping edges (i,i+1) and (j,j+1)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check if the new solution is better in at least one objective\n        improved = False\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                dm = distance_matrix_1\n            elif obj_idx == 1:\n                dm = distance_matrix_2\n            else:\n                dm = distance_matrix_3\n\n            new_dist = sum(dm[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            old_dist = sum(dm[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if new_dist < old_dist:\n                improved = True\n                break\n\n        if improved:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 188,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current and potential costs for each objective\n    current_costs = [sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n                     sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n                     sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))]\n\n    # Find the objective with the highest current cost\n    worst_obj = np.argmax(current_costs)\n\n    # Perform a swap that might improve the worst objective\n    if worst_obj == 0:\n        # For objective 1, find edges with highest distance\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_1[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n    elif worst_obj == 1:\n        # For objective 2\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_2[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n    else:\n        # For objective 3\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_3[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n\n    # Perform a 2-opt on the worst edge\n    i, j = worst_edge\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8600683739832302,
            1.1966476440429688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current and potential costs for each objective\n    current_costs = [sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n                     sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n                     sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))]\n\n    # Find the objective with the highest current cost\n    worst_obj = np.argmax(current_costs)\n\n    # Perform a swap that might improve the worst objective\n    if worst_obj == 0:\n        # For objective 1, find edges with highest distance\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_1[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n    elif worst_obj == 1:\n        # For objective 2\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_2[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n    else:\n        # For objective 3\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_3[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n\n    # Perform a 2-opt on the worst edge\n    i, j = worst_edge\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 188,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current and potential costs for each objective\n    current_costs = [sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n                     sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n                     sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))]\n\n    # Find the objective with the highest current cost\n    worst_obj = np.argmax(current_costs)\n\n    # Perform a swap that might improve the worst objective\n    if worst_obj == 0:\n        # For objective 1, find edges with highest distance\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_1[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n    elif worst_obj == 1:\n        # For objective 2\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_2[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n    else:\n        # For objective 3\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_3[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n\n    # Perform a 2-opt on the worst edge\n    i, j = worst_edge\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8600683739832302,
            1.1966476440429688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current and potential costs for each objective\n    current_costs = [sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n                     sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n                     sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))]\n\n    # Find the objective with the highest current cost\n    worst_obj = np.argmax(current_costs)\n\n    # Perform a swap that might improve the worst objective\n    if worst_obj == 0:\n        # For objective 1, find edges with highest distance\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_1[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n    elif worst_obj == 1:\n        # For objective 2\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_2[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n    else:\n        # For objective 3\n        edges = [(k, (k+1)%n) for k in range(n)]\n        edge_costs = [distance_matrix_3[new_solution[e[0]], new_solution[e[1]]] for e in edges]\n        worst_edge = edges[np.argmax(edge_costs)]\n\n    # Perform a 2-opt on the worst edge\n    i, j = worst_edge\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 189,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + np.sum(obj)) for _, obj in archive]  # Prefer solutions with lower total cost\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-specific swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between 2-opt and objective-specific move\n    if random.random() < 0.7:  # Higher chance for 2-opt\n        # Perform 2-opt move (standard for TSP)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-specific move: swap segments to improve one objective\n        objective = archive[selected_idx][1]\n        worst_obj_idx = np.argmax(objective)  # Identify the worst objective\n\n        # Choose a segment to swap based on the worst objective\n        if worst_obj_idx == 0:\n            # Improve first objective: find the worst edge in this objective\n            worst_edge = None\n            max_dist = -1\n            for i in range(n):\n                u, v = new_solution[i], new_solution[(i+1)%n]\n                dist = distance_matrix_1[u, v]\n                if dist > max_dist:\n                    max_dist = dist\n                    worst_edge = i\n            # Perform a 2-opt move around the worst edge\n            if worst_edge is not None:\n                i = worst_edge\n                j = (i + 1) % n\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif worst_obj_idx == 1:\n            # Improve second objective: similar approach\n            worst_edge = None\n            max_dist = -1\n            for i in range(n):\n                u, v = new_solution[i], new_solution[(i+1)%n]\n                dist = distance_matrix_2[u, v]\n                if dist > max_dist:\n                    max_dist = dist\n                    worst_edge = i\n            if worst_edge is not None:\n                i = worst_edge\n                j = (i + 1) % n\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Improve third objective\n            worst_edge = None\n            max_dist = -1\n            for i in range(n):\n                u, v = new_solution[i], new_solution[(i+1)%n]\n                dist = distance_matrix_3[u, v]\n                if dist > max_dist:\n                    max_dist = dist\n                    worst_edge = i\n            if worst_edge is not None:\n                i = worst_edge\n                j = (i + 1) % n\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7592434515465091,
            2.0626155614852903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + np.sum(obj)) for _, obj in archive]  # Prefer solutions with lower total cost\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-specific swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between 2-opt and objective-specific move\n    if random.random() < 0.7:  # Higher chance for 2-opt\n        # Perform 2-opt move (standard for TSP)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-specific move: swap segments to improve one objective\n        objective = archive[selected_idx][1]\n        worst_obj_idx = np.argmax(objective)  # Identify the worst objective\n\n        # Choose a segment to swap based on the worst objective\n        if worst_obj_idx == 0:\n            # Improve first objective: find the worst edge in this objective\n            worst_edge = None\n            max_dist = -1\n            for i in range(n):\n                u, v = new_solution[i], new_solution[(i+1)%n]\n                dist = distance_matrix_1[u, v]\n                if dist > max_dist:\n                    max_dist = dist\n                    worst_edge = i\n            # Perform a 2-opt move around the worst edge\n            if worst_edge is not None:\n                i = worst_edge\n                j = (i + 1) % n\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif worst_obj_idx == 1:\n            # Improve second objective: similar approach\n            worst_edge = None\n            max_dist = -1\n            for i in range(n):\n                u, v = new_solution[i], new_solution[(i+1)%n]\n                dist = distance_matrix_2[u, v]\n                if dist > max_dist:\n                    max_dist = dist\n                    worst_edge = i\n            if worst_edge is not None:\n                i = worst_edge\n                j = (i + 1) % n\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Improve third objective\n            worst_edge = None\n            max_dist = -1\n            for i in range(n):\n                u, v = new_solution[i], new_solution[(i+1)%n]\n                dist = distance_matrix_3[u, v]\n                if dist > max_dist:\n                    max_dist = dist\n                    worst_edge = i\n            if worst_edge is not None:\n                i = worst_edge\n                j = (i + 1) % n\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 190,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    for sol, obj in archive:\n        # Check if the solution is not already optimal in all objectives\n        if not (obj[0] == 0 and obj[1] == 0 and obj[2] == 0):\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with multi-objective awareness\n    n_nodes = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform a random 2-opt or 3-opt move based on multi-objective improvement potential\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt move\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move (more disruptive)\n        i, j, k = sorted(random.sample(range(n_nodes), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Verify the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6876741044472634,
            0.6821465969085694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    for sol, obj in archive:\n        # Check if the solution is not already optimal in all objectives\n        if not (obj[0] == 0 and obj[1] == 0 and obj[2] == 0):\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with multi-objective awareness\n    n_nodes = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform a random 2-opt or 3-opt move based on multi-objective improvement potential\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt move\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move (more disruptive)\n        i, j, k = sorted(random.sample(range(n_nodes), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Verify the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 191,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with higher objective values are less likely to be selected\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)  # Higher weights for better solutions\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective-aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, apply a multi-objective-aware perturbation\n    # Select a segment and move it to a different position, considering all three objectives\n    k, l = sorted(random.sample(range(n), 2))\n    segment = new_solution[k:l]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8263427817664578,
            1.4225786924362183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with higher objective values are less likely to be selected\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)  # Higher weights for better solutions\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective-aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, apply a multi-objective-aware perturbation\n    # Select a segment and move it to a different position, considering all three objectives\n    k, l = sorted(random.sample(range(n), 2))\n    segment = new_solution[k:l]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 192,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a weighted sum of objectives (can be replaced with other selection criteria)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one from the top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and multi-objective edge swapping\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Multi-objective edge swapping: try to improve in at least one objective\n        for _ in range(3):  # Try multiple times\n            a, b = random.sample(range(n), 2)\n            if a > b:\n                a, b = b, a\n\n            # Calculate current and potential costs\n            current_cost = (\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            )\n\n            potential_cost = (\n                distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                distance_matrix_3[new_solution[b-1], new_solution[a]]\n            )\n\n            # Accept if at least one objective improves\n            if potential_cost < current_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6886590429653106,
            1.7264618158340455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a weighted sum of objectives (can be replaced with other selection criteria)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one from the top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and multi-objective edge swapping\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Multi-objective edge swapping: try to improve in at least one objective\n        for _ in range(3):  # Try multiple times\n            a, b = random.sample(range(n), 2)\n            if a > b:\n                a, b = b, a\n\n            # Calculate current and potential costs\n            current_cost = (\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            )\n\n            potential_cost = (\n                distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                distance_matrix_3[new_solution[b-1], new_solution[a]]\n            )\n\n            # Accept if at least one objective improves\n            if potential_cost < current_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 193,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (promising for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt to improve the solution\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective perturbation: randomly select one objective space and apply a small 2-opt in that space\n    obj_space = np.random.choice([0, 1, 2])\n    if obj_space == 0:\n        # Find the worst edge in the first objective space\n        max_dist = -1\n        worst_i, worst_j = 0, 0\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix_1[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_i, worst_j = k, (k+1)%n\n        # Apply 2-opt on the worst edge\n        new_solution[worst_i:worst_j+1] = new_solution[worst_i:worst_j+1][::-1]\n    elif obj_space == 1:\n        # Find the worst edge in the second objective space\n        max_dist = -1\n        worst_i, worst_j = 0, 0\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix_2[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_i, worst_j = k, (k+1)%n\n        # Apply 2-opt on the worst edge\n        new_solution[worst_i:worst_j+1] = new_solution[worst_i:worst_j+1][::-1]\n    else:\n        # Find the worst edge in the third objective space\n        max_dist = -1\n        worst_i, worst_j = 0, 0\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix_3[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_i, worst_j = k, (k+1)%n\n        # Apply 2-opt on the worst edge\n        new_solution[worst_i:worst_j+1] = new_solution[worst_i:worst_j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8277308587557737,
            1.1742089867591858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (promising for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt to improve the solution\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective perturbation: randomly select one objective space and apply a small 2-opt in that space\n    obj_space = np.random.choice([0, 1, 2])\n    if obj_space == 0:\n        # Find the worst edge in the first objective space\n        max_dist = -1\n        worst_i, worst_j = 0, 0\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix_1[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_i, worst_j = k, (k+1)%n\n        # Apply 2-opt on the worst edge\n        new_solution[worst_i:worst_j+1] = new_solution[worst_i:worst_j+1][::-1]\n    elif obj_space == 1:\n        # Find the worst edge in the second objective space\n        max_dist = -1\n        worst_i, worst_j = 0, 0\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix_2[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_i, worst_j = k, (k+1)%n\n        # Apply 2-opt on the worst edge\n        new_solution[worst_i:worst_j+1] = new_solution[worst_i:worst_j+1][::-1]\n    else:\n        # Find the worst edge in the third objective space\n        max_dist = -1\n        worst_i, worst_j = 0, 0\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix_3[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_i, worst_j = k, (k+1)%n\n        # Apply 2-opt on the worst edge\n        new_solution[worst_i:worst_j+1] = new_solution[worst_i:worst_j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 194,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a random swap\n        i, j = np.random.choice(n, 2, replace=False)\n    else:\n        # For larger instances, perform 2-opt with objective-aware selection\n        # Select two edges to swap based on the objective with the highest variance\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        variances = [np.var([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n                    np.var([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n                    np.var([distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])]\n        objective_to_improve = np.argmax(variances)\n\n        # Perform 2-opt on the objective with highest variance\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if objective_to_improve == 0:\n            # Check if swapping i and j improves the first objective\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif objective_to_improve == 1:\n            # Check if swapping i and j improves the second objective\n            current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Check if swapping i and j improves the third objective\n            current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional refinement: try a random 2-opt if the previous didn't improve\n    if np.array_equal(new_solution, base_solution):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8446678750828684,
            1.5772701382637024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a random swap\n        i, j = np.random.choice(n, 2, replace=False)\n    else:\n        # For larger instances, perform 2-opt with objective-aware selection\n        # Select two edges to swap based on the objective with the highest variance\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        variances = [np.var([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n                    np.var([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n                    np.var([distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])]\n        objective_to_improve = np.argmax(variances)\n\n        # Perform 2-opt on the objective with highest variance\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if objective_to_improve == 0:\n            # Check if swapping i and j improves the first objective\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif objective_to_improve == 1:\n            # Check if swapping i and j improves the second objective\n            current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Check if swapping i and j improves the third objective\n            current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional refinement: try a random 2-opt if the previous didn't improve\n    if np.array_equal(new_solution, base_solution):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 195,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the variance of objectives across the archive\n        objectives = np.array([obj for _, obj in archive])\n        obj_variance = np.var(objectives, axis=0)\n        # Select the solution with the highest variance in any objective\n        selected_idx = np.argmax(np.max(obj_variance))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel 3-way edge swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform 3-way edge swap (novel operator)\n    if k < i or k >= j:\n        # Ensure the swap is valid (no duplicate nodes)\n        temp = new_solution.copy()\n        temp[i], temp[j], temp[k] = temp[j], temp[k], temp[i]\n        # Check if the new solution is valid (no duplicates)\n        if len(np.unique(temp)) == n:\n            new_solution = temp\n\n    # Evaluate the new solution's objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    # If the new solution is not dominated by the original, keep it\n    original_obj = evaluate(base_solution)\n    new_obj = evaluate(new_solution)\n\n    # Check dominance (simplified for this example)\n    if not (all(n <= o for n, o in zip(new_obj, original_obj)) and any(n < o for n, o in zip(new_obj, original_obj))):\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6887381061026563,
            1.5662009716033936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the variance of objectives across the archive\n        objectives = np.array([obj for _, obj in archive])\n        obj_variance = np.var(objectives, axis=0)\n        # Select the solution with the highest variance in any objective\n        selected_idx = np.argmax(np.max(obj_variance))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel 3-way edge swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform 3-way edge swap (novel operator)\n    if k < i or k >= j:\n        # Ensure the swap is valid (no duplicate nodes)\n        temp = new_solution.copy()\n        temp[i], temp[j], temp[k] = temp[j], temp[k], temp[i]\n        # Check if the new solution is valid (no duplicates)\n        if len(np.unique(temp)) == n:\n            new_solution = temp\n\n    # Evaluate the new solution's objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    # If the new solution is not dominated by the original, keep it\n    original_obj = evaluate(base_solution)\n    new_obj = evaluate(new_solution)\n\n    # Check dominance (simplified for this example)\n    if not (all(n <= o for n, o in zip(new_obj, original_obj)) and any(n < o for n, o in zip(new_obj, original_obj))):\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 196,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, min(5, len(archive)-1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    N = len(new_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(N), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an edge exchange between two random segments\n    k, l = sorted(random.sample(range(N), 2))\n    if k != i and l != j:  # Ensure we don't undo the 2-opt\n        # Swap segments [k:l] and [i:j]\n        segment1 = new_solution[k:l+1]\n        segment2 = new_solution[i:j+1]\n        new_solution = np.concatenate([\n            new_solution[:i],\n            segment1,\n            new_solution[j+1:k],\n            segment2,\n            new_solution[l+1:]\n        ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to original solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7066690142884557,
            0.38076297044754026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, min(5, len(archive)-1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    N = len(new_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(N), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an edge exchange between two random segments\n    k, l = sorted(random.sample(range(N), 2))\n    if k != i and l != j:  # Ensure we don't undo the 2-opt\n        # Swap segments [k:l] and [i:j]\n        segment1 = new_solution[k:l+1]\n        segment2 = new_solution[i:j+1]\n        new_solution = np.concatenate([\n            new_solution[:i],\n            segment1,\n            new_solution[j+1:k],\n            segment2,\n            new_solution[l+1:]\n        ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to original solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 196,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, min(5, len(archive)-1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    N = len(new_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(N), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an edge exchange between two random segments\n    k, l = sorted(random.sample(range(N), 2))\n    if k != i and l != j:  # Ensure we don't undo the 2-opt\n        # Swap segments [k:l] and [i:j]\n        segment1 = new_solution[k:l+1]\n        segment2 = new_solution[i:j+1]\n        new_solution = np.concatenate([\n            new_solution[:i],\n            segment1,\n            new_solution[j+1:k],\n            segment2,\n            new_solution[l+1:]\n        ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to original solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7066690142884557,
            0.38076297044754026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, min(5, len(archive)-1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    N = len(new_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(N), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an edge exchange between two random segments\n    k, l = sorted(random.sample(range(N), 2))\n    if k != i and l != j:  # Ensure we don't undo the 2-opt\n        # Swap segments [k:l] and [i:j]\n        segment1 = new_solution[k:l+1]\n        segment2 = new_solution[i:j+1]\n        new_solution = np.concatenate([\n            new_solution[:i],\n            segment1,\n            new_solution[j+1:k],\n            segment2,\n            new_solution[l+1:]\n        ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to original solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 197,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to make them comparable\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.mean(normalized_objectives, axis=1)\n    probabilities = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Choose between 2-opt or 3-opt based on a random decision\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # Perform 2-opt (swap two edges)\n        i, j = sorted(random.sample(range(1, len(new_solution) - 1), 2))\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n    else:\n        # Perform 3-opt (rearrange three edges)\n        i, j, k = sorted(random.sample(range(1, len(new_solution) - 1), 3))\n        # Rearrange the segment between i, j, k\n        segment = new_solution[i:j+1]\n        new_segment = np.concatenate([segment[:k-i], segment[k-i:][::-1]])\n        new_solution[i:j+1] = new_segment\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to 2-opt if 3-opt causes issues\n        i, j = sorted(random.sample(range(1, len(new_solution) - 1), 2))\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.73202920573898,
            1.5616546988487243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to make them comparable\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.mean(normalized_objectives, axis=1)\n    probabilities = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Choose between 2-opt or 3-opt based on a random decision\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # Perform 2-opt (swap two edges)\n        i, j = sorted(random.sample(range(1, len(new_solution) - 1), 2))\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n    else:\n        # Perform 3-opt (rearrange three edges)\n        i, j, k = sorted(random.sample(range(1, len(new_solution) - 1), 3))\n        # Rearrange the segment between i, j, k\n        segment = new_solution[i:j+1]\n        new_segment = np.concatenate([segment[:k-i], segment[k-i:][::-1]])\n        new_solution[i:j+1] = new_segment\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to 2-opt if 3-opt causes issues\n        i, j = sorted(random.sample(range(1, len(new_solution) - 1), 2))\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 198,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values (higher diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)  # Higher weight for solutions with lower total cost\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 2-opt swap (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: select edges that are critical in any of the three objectives\n    if random.random() < 0.5:  # 50% chance to apply objective-aware swap\n        # Identify edges with high cost in any objective\n        edge_costs = np.zeros(n)\n        for k in range(n):\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            edge_costs[k] = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n        # Find the worst edge (highest average cost)\n        worst_edge_idx = np.argmax(edge_costs)\n        a, b = new_solution[worst_edge_idx], new_solution[(worst_edge_idx+1)%n]\n\n        # Find the best possible replacement edge\n        best_replacement = None\n        min_cost = float('inf')\n\n        for i in range(n):\n            for j in range(i+1, n):\n                x, y = new_solution[i], new_solution[j]\n                cost = (distance_matrix_1[x, y] + distance_matrix_2[x, y] + distance_matrix_3[x, y]) / 3\n                if cost < min_cost:\n                    min_cost = cost\n                    best_replacement = (i, j)\n\n        if best_replacement:\n            i, j = best_replacement\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7482133734323125,
            1.1857928037643433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values (higher diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)  # Higher weight for solutions with lower total cost\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 2-opt swap (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: select edges that are critical in any of the three objectives\n    if random.random() < 0.5:  # 50% chance to apply objective-aware swap\n        # Identify edges with high cost in any objective\n        edge_costs = np.zeros(n)\n        for k in range(n):\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            edge_costs[k] = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n        # Find the worst edge (highest average cost)\n        worst_edge_idx = np.argmax(edge_costs)\n        a, b = new_solution[worst_edge_idx], new_solution[(worst_edge_idx+1)%n]\n\n        # Find the best possible replacement edge\n        best_replacement = None\n        min_cost = float('inf')\n\n        for i in range(n):\n            for j in range(i+1, n):\n                x, y = new_solution[i], new_solution[j]\n                cost = (distance_matrix_1[x, y] + distance_matrix_2[x, y] + distance_matrix_3[x, y]) / 3\n                if cost < min_cost:\n                    min_cost = cost\n                    best_replacement = (i, j)\n\n        if best_replacement:\n            i, j = best_replacement\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 199,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the first segment\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion to the second segment\n    if k < l and j < n:\n        inserted = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:j], inserted, new_solution[j:k], new_solution[l:]])\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6888299089844423,
            0.47011326551437377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the first segment\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion to the second segment\n    if k < l and j < n:\n        inserted = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:j], inserted, new_solution[j:k], new_solution[l:]])\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 200,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across all three objectives using hypervolume contribution\n    def hypervolume_contribution(solution, objectives):\n        # Simplified hypervolume contribution: sum of normalized objectives\n        normalized = np.array([(obj - min_obj) / (max_obj - min_obj + 1e-10) for obj, min_obj, max_obj in zip(objectives, min_objectives, max_objectives)])\n        return np.sum(normalized)\n\n    objectives = [obj for _, obj in archive]\n    min_objectives = np.min(objectives, axis=0)\n    max_objectives = np.max(objectives, axis=0)\n\n    # Rank solutions by hypervolume contribution\n    ranked_solutions = sorted(archive, key=lambda x: hypervolume_contribution(x[0], x[1]), reverse=True)\n    base_solution, _ = ranked_solutions[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for small tours\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select the worst edge in terms of total distance across all objectives\n        worst_edge = -1\n        worst_edge_value = -float('inf')\n\n        for i in range(n):\n            j = (i + 1) % n\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            total_dist = (distance_matrix_1[node_i, node_j] +\n                          distance_matrix_2[node_i, node_j] +\n                          distance_matrix_3[node_i, node_j])\n\n            if total_dist > worst_edge_value:\n                worst_edge_value = total_dist\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Perform 2-opt on the worst edge\n            i = worst_edge\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            # Try to reconnect the path with better edges\n            best_improvement = 0\n            best_k = -1\n\n            for candidate_k in range(n):\n                if candidate_k == i or candidate_k == j or candidate_k == k:\n                    continue\n\n                # Calculate potential improvement\n                current_dist = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                               distance_matrix_2[new_solution[i], new_solution[j]] +\n                               distance_matrix_3[new_solution[i], new_solution[j]])\n\n                new_dist = (distance_matrix_1[new_solution[i], new_solution[candidate_k]] +\n                            distance_matrix_2[new_solution[i], new_solution[candidate_k]] +\n                            distance_matrix_3[new_solution[i], new_solution[candidate_k]])\n\n                improvement = current_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_k = candidate_k\n\n            if best_k != -1:\n                # Perform the edge insertion\n                if i < j:\n                    new_solution = np.concatenate([new_solution[:i+1], [new_solution[best_k]], new_solution[i+1:best_k], new_solution[best_k+1:]])\n                else:\n                    new_solution = np.concatenate([new_solution[:best_k], new_solution[i+1:], [new_solution[best_k]], new_solution[:i]])\n\n    return new_solution\n\n",
        "score": [
            -0.7406268997225451,
            1.8922033309936523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across all three objectives using hypervolume contribution\n    def hypervolume_contribution(solution, objectives):\n        # Simplified hypervolume contribution: sum of normalized objectives\n        normalized = np.array([(obj - min_obj) / (max_obj - min_obj + 1e-10) for obj, min_obj, max_obj in zip(objectives, min_objectives, max_objectives)])\n        return np.sum(normalized)\n\n    objectives = [obj for _, obj in archive]\n    min_objectives = np.min(objectives, axis=0)\n    max_objectives = np.max(objectives, axis=0)\n\n    # Rank solutions by hypervolume contribution\n    ranked_solutions = sorted(archive, key=lambda x: hypervolume_contribution(x[0], x[1]), reverse=True)\n    base_solution, _ = ranked_solutions[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for small tours\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select the worst edge in terms of total distance across all objectives\n        worst_edge = -1\n        worst_edge_value = -float('inf')\n\n        for i in range(n):\n            j = (i + 1) % n\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            total_dist = (distance_matrix_1[node_i, node_j] +\n                          distance_matrix_2[node_i, node_j] +\n                          distance_matrix_3[node_i, node_j])\n\n            if total_dist > worst_edge_value:\n                worst_edge_value = total_dist\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Perform 2-opt on the worst edge\n            i = worst_edge\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            # Try to reconnect the path with better edges\n            best_improvement = 0\n            best_k = -1\n\n            for candidate_k in range(n):\n                if candidate_k == i or candidate_k == j or candidate_k == k:\n                    continue\n\n                # Calculate potential improvement\n                current_dist = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                               distance_matrix_2[new_solution[i], new_solution[j]] +\n                               distance_matrix_3[new_solution[i], new_solution[j]])\n\n                new_dist = (distance_matrix_1[new_solution[i], new_solution[candidate_k]] +\n                            distance_matrix_2[new_solution[i], new_solution[candidate_k]] +\n                            distance_matrix_3[new_solution[i], new_solution[candidate_k]])\n\n                improvement = current_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_k = candidate_k\n\n            if best_k != -1:\n                # Perform the edge insertion\n                if i < j:\n                    new_solution = np.concatenate([new_solution[:i+1], [new_solution[best_k]], new_solution[i+1:best_k], new_solution[best_k+1:]])\n                else:\n                    new_solution = np.concatenate([new_solution[:best_k], new_solution[i+1:], [new_solution[best_k]], new_solution[:i]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 201,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform objective-aware swap\n    obj1 = archive[selected_idx][1]\n    if np.random.rand() < 0.5:  # 50% chance to perform swap\n        # Calculate potential improvement for each objective\n        delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                  distance_matrix_1[new_solution[k], new_solution[l-1]]) - \\\n                 (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                  distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                  distance_matrix_2[new_solution[k], new_solution[l-1]]) - \\\n                 (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                  distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        delta3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                  distance_matrix_3[new_solution[k], new_solution[l-1]]) - \\\n                 (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                  distance_matrix_3[new_solution[l-1], new_solution[l]])\n\n        # Only perform swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7331041045473573,
            1.078423309326172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform objective-aware swap\n    obj1 = archive[selected_idx][1]\n    if np.random.rand() < 0.5:  # 50% chance to perform swap\n        # Calculate potential improvement for each objective\n        delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                  distance_matrix_1[new_solution[k], new_solution[l-1]]) - \\\n                 (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                  distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                  distance_matrix_2[new_solution[k], new_solution[l-1]]) - \\\n                 (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                  distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        delta3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                  distance_matrix_3[new_solution[k], new_solution[l-1]]) - \\\n                 (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                  distance_matrix_3[new_solution[l-1], new_solution[l]])\n\n        # Only perform swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 202,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.max(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 - normalized_objectives.mean(axis=1)  # Higher weight for solutions with worse objectives\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: combination of 2-opt and segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Choose between 2-opt or segment inversion based on current solution quality\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion with objective-aware segment selection\n        # Select a segment that has high potential for improvement in any of the objectives\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate the segment's contribution to each objective\n        segment = new_solution[start:end]\n        segment_costs = [\n            sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n            sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n            sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        ]\n\n        # Invert the segment if it's a high-cost segment in any objective\n        if max(segment_costs) > np.percentile([obj[i] for _, obj in archive for i in range(3)], 75):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7813820976953049,
            1.673455047607422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.max(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 - normalized_objectives.mean(axis=1)  # Higher weight for solutions with worse objectives\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: combination of 2-opt and segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Choose between 2-opt or segment inversion based on current solution quality\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion with objective-aware segment selection\n        # Select a segment that has high potential for improvement in any of the objectives\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate the segment's contribution to each objective\n        segment = new_solution[start:end]\n        segment_costs = [\n            sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n            sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n            sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        ]\n\n        # Invert the segment if it's a high-cost segment in any objective\n        if max(segment_costs) > np.percentile([obj[i] for _, obj in archive for i in range(3)], 75):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 203,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.mean(axis=1) + 1e-10)  # Higher weight for worse solutions\n    weights = weights / weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and relocate operations\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose between 2-opt and relocate\n    if random.random() < 0.5:\n        # 2-opt: swap two edges\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Relocate: move a node to a different position\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution is valid (no duplicates)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7681173605241529,
            0.8024282336235047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.mean(axis=1) + 1e-10)  # Higher weight for worse solutions\n    weights = weights / weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and relocate operations\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose between 2-opt and relocate\n    if random.random() < 0.5:\n        # 2-opt: swap two edges\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Relocate: move a node to a different position\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution is valid (no duplicates)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 204,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (to find underperforming ones)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle 60% to avoid extremes\n        selection_pool = archive_sorted[int(len(archive) * 0.2):int(len(archive) * 0.8)]\n        # Randomly select one from the pool\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (reverse a segment)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: select a node to swap with based on worst objective\n    if random.random() < 0.5:  # 50% chance to apply objective-aware swap\n        # Calculate the contribution of each node to each objective\n        node_contributions = []\n        for k in range(n):\n            prev_node = new_solution[k-1]\n            curr_node = new_solution[k]\n            next_node = new_solution[(k+1) % n]\n            # Calculate the cost for each objective\n            cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n            cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n            cost3 = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n            node_contributions.append((cost1 + cost2 + cost3, k))\n\n        # Sort nodes by their total contribution (descending)\n        node_contributions.sort(reverse=True, key=lambda x: x[0])\n        # Select the worst node to swap\n        worst_node = node_contributions[0][1]\n        # Find a random node to swap with\n        swap_with = random.choice([k for k in range(n) if k != worst_node])\n        # Perform the swap\n        new_solution[worst_node], new_solution[swap_with] = new_solution[swap_with], new_solution[worst_node]\n\n    return new_solution\n\n",
        "score": [
            -0.7271799869518412,
            1.1114369630813599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (to find underperforming ones)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle 60% to avoid extremes\n        selection_pool = archive_sorted[int(len(archive) * 0.2):int(len(archive) * 0.8)]\n        # Randomly select one from the pool\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (reverse a segment)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: select a node to swap with based on worst objective\n    if random.random() < 0.5:  # 50% chance to apply objective-aware swap\n        # Calculate the contribution of each node to each objective\n        node_contributions = []\n        for k in range(n):\n            prev_node = new_solution[k-1]\n            curr_node = new_solution[k]\n            next_node = new_solution[(k+1) % n]\n            # Calculate the cost for each objective\n            cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n            cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n            cost3 = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n            node_contributions.append((cost1 + cost2 + cost3, k))\n\n        # Sort nodes by their total contribution (descending)\n        node_contributions.sort(reverse=True, key=lambda x: x[0])\n        # Select the worst node to swap\n        worst_node = node_contributions[0][1]\n        # Find a random node to swap with\n        swap_with = random.choice([k for k in range(n) if k != worst_node])\n        # Perform the swap\n        new_solution[worst_node], new_solution[swap_with] = new_solution[swap_with], new_solution[worst_node]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 205,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion moves tailored for multi-objective TSP\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        # Randomly choose between 2-opt and insertion\n        if np.random.rand() < 0.7:  # 70% chance for 2-opt\n            # 2-opt move with objective-aware selection\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            # Evaluate 2-opt move across all objectives\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j-1]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[j-1]])\n\n            if new_cost < original_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # Insertion move\n            # Select a random segment and reinsert it elsewhere\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j].copy()\n            remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n            k = np.random.randint(len(remaining))\n            new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7267715943340081,
            1.328114402294159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion moves tailored for multi-objective TSP\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        # Randomly choose between 2-opt and insertion\n        if np.random.rand() < 0.7:  # 70% chance for 2-opt\n            # 2-opt move with objective-aware selection\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            # Evaluate 2-opt move across all objectives\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j-1]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[j-1]])\n\n            if new_cost < original_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # Insertion move\n            # Select a random segment and reinsert it elsewhere\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j].copy()\n            remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n            k = np.random.randint(len(remaining))\n            new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 206,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and 3-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt or 3-opt with probability based on solution quality\n    if random.random() < 0.7:  # Higher probability for 2-opt (faster but good for multi-objective)\n        # 2-opt with objective-aware selection\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate potential improvement in all three objectives\n        orig_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < orig_cost:  # Simple improvement check across all objectives\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt with objective-aware selection\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try all possible 3-opt moves and select the best one\n        best_move = None\n        best_improvement = 0\n\n        # Generate all possible 3-opt moves and evaluate their impact on all objectives\n        for a, b, c in [(i, j, k), (i, k, j)]:\n            # Original cost\n            orig_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n            # New cost after move\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[c], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[c]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[c], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[c], new_solution[a]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[c]])\n\n            improvement = orig_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = (a, b, c)\n\n        if best_move is not None:\n            a, b, c = best_move\n            # Apply the best move\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.695755989200101,
            2.0447267413139345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and 3-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt or 3-opt with probability based on solution quality\n    if random.random() < 0.7:  # Higher probability for 2-opt (faster but good for multi-objective)\n        # 2-opt with objective-aware selection\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate potential improvement in all three objectives\n        orig_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < orig_cost:  # Simple improvement check across all objectives\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt with objective-aware selection\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try all possible 3-opt moves and select the best one\n        best_move = None\n        best_improvement = 0\n\n        # Generate all possible 3-opt moves and evaluate their impact on all objectives\n        for a, b, c in [(i, j, k), (i, k, j)]:\n            # Original cost\n            orig_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n            # New cost after move\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[c], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[c]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[c], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[c], new_solution[a]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[c]])\n\n            improvement = orig_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = (a, b, c)\n\n        if best_move is not None:\n            a, b, c = best_move\n            # Apply the best move\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 207,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 20% of the archive)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective aware swap: identify the worst edge in any objective\n    worst_edge = -1\n    max_edge_cost = -1\n\n    for k in range(n):\n        node_a = new_solution[k]\n        node_b = new_solution[(k + 1) % n]\n\n        # Calculate edge cost across all three objectives\n        cost1 = distance_matrix_1[node_a, node_b]\n        cost2 = distance_matrix_2[node_a, node_b]\n        cost3 = distance_matrix_3[node_a, node_b]\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost > max_edge_cost:\n            max_edge_cost = total_cost\n            worst_edge = k\n\n    if worst_edge != -1:\n        # Perform a swap that improves the worst edge\n        a, b = worst_edge, (worst_edge + 1) % n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6962932796236841,
            1.2338396430015564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 20% of the archive)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective aware swap: identify the worst edge in any objective\n    worst_edge = -1\n    max_edge_cost = -1\n\n    for k in range(n):\n        node_a = new_solution[k]\n        node_b = new_solution[(k + 1) % n]\n\n        # Calculate edge cost across all three objectives\n        cost1 = distance_matrix_1[node_a, node_b]\n        cost2 = distance_matrix_2[node_a, node_b]\n        cost3 = distance_matrix_3[node_a, node_b]\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost > max_edge_cost:\n            max_edge_cost = total_cost\n            worst_edge = k\n\n    if worst_edge != -1:\n        # Perform a swap that improves the worst edge\n        a, b = worst_edge, (worst_edge + 1) % n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 208,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with the highest potential for improvement\n    # Here, we select the solution with the highest average objective value (most \"dominated\" in at least one space)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    # First, perform a standard 2-opt swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap to further optimize\n    # Select two edges that are \"bad\" in at least one objective space\n    obj1 = distance_matrix_1[np.roll(new_solution, -1)][np.arange(n), new_solution]\n    obj2 = distance_matrix_2[np.roll(new_solution, -1)][np.arange(n), new_solution]\n    obj3 = distance_matrix_3[np.roll(new_solution, -1)][np.arange(n), new_solution]\n\n    # Find edges that are above median in any objective\n    bad_edges = np.where((obj1 > np.median(obj1)) | (obj2 > np.median(obj2)) | (obj3 > np.median(obj3)))[0]\n\n    if len(bad_edges) >= 2:\n        a, b = sorted(np.random.choice(bad_edges, 2, replace=False))\n        # Swap the nodes at positions a and b\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5396919498650342,
            1.4792750477790833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with the highest potential for improvement\n    # Here, we select the solution with the highest average objective value (most \"dominated\" in at least one space)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    # First, perform a standard 2-opt swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap to further optimize\n    # Select two edges that are \"bad\" in at least one objective space\n    obj1 = distance_matrix_1[np.roll(new_solution, -1)][np.arange(n), new_solution]\n    obj2 = distance_matrix_2[np.roll(new_solution, -1)][np.arange(n), new_solution]\n    obj3 = distance_matrix_3[np.roll(new_solution, -1)][np.arange(n), new_solution]\n\n    # Find edges that are above median in any objective\n    bad_edges = np.where((obj1 > np.median(obj1)) | (obj2 > np.median(obj2)) | (obj3 > np.median(obj3)))[0]\n\n    if len(bad_edges) >= 2:\n        a, b = sorted(np.random.choice(bad_edges, 2, replace=False))\n        # Swap the nodes at positions a and b\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 209,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the best)\n    candidates = []\n    for solution, _ in archive:\n        # Calculate diversity score (distance from the first solution in archive)\n        diversity = np.sum(solution != archive[0][0])\n        candidates.append((solution, diversity))\n\n    # Sort by diversity and select the most diverse solution\n    candidates.sort(key=lambda x: -x[1])\n    base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    for _ in range(5):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge swap (choose the best swap based on all three objectives)\n        best_swap = None\n        best_improvement = 0\n\n        for k in range(i, j+1):\n            for l in range(k+1, j+1):\n                # Calculate current and new edge costs for all three objectives\n                current_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n                current_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n                current_cost3 = (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n                new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_1[new_solution[k], new_solution[(l+1)%n]])\n                new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_2[new_solution[k], new_solution[(l+1)%n]])\n                new_cost3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_3[new_solution[k], new_solution[(l+1)%n]])\n\n                # Calculate improvement (sum of improvements across all objectives)\n                improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2) + (current_cost3 - new_cost3)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (k, l)\n\n        if best_swap is not None:\n            k, l = best_swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7776949001906719,
            3.6016080021858214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the best)\n    candidates = []\n    for solution, _ in archive:\n        # Calculate diversity score (distance from the first solution in archive)\n        diversity = np.sum(solution != archive[0][0])\n        candidates.append((solution, diversity))\n\n    # Sort by diversity and select the most diverse solution\n    candidates.sort(key=lambda x: -x[1])\n    base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    for _ in range(5):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge swap (choose the best swap based on all three objectives)\n        best_swap = None\n        best_improvement = 0\n\n        for k in range(i, j+1):\n            for l in range(k+1, j+1):\n                # Calculate current and new edge costs for all three objectives\n                current_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n                current_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n                current_cost3 = (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n                new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_1[new_solution[k], new_solution[(l+1)%n]])\n                new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_2[new_solution[k], new_solution[(l+1)%n]])\n                new_cost3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_3[new_solution[k], new_solution[(l+1)%n]])\n\n                # Calculate improvement (sum of improvements across all objectives)\n                improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2) + (current_cost3 - new_cost3)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (k, l)\n\n        if best_swap is not None:\n            k, l = best_swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 210,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: identify nodes with high contribution to any objective and swap them\n    # Calculate the contribution of each node to each objective\n    contributions = []\n    for k in range(n):\n        prev_node = new_solution[k-1]\n        next_node = new_solution[(k+1)%n]\n        contrib1 = distance_matrix_1[prev_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n        contrib2 = distance_matrix_2[prev_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n        contrib3 = distance_matrix_3[prev_node, new_solution[k]] + distance_matrix_3[new_solution[k], next_node]\n        contributions.append((contrib1 + contrib2 + contrib3, k))\n\n    # Sort nodes by their contribution (highest first)\n    contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top contributing nodes and perform swaps\n    top_nodes = [idx for (contrib, idx) in contributions[:min(5, n)]]\n    if len(top_nodes) >= 2:\n        a, b = np.random.choice(top_nodes, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7939340181510759,
            0.7348868370056152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: identify nodes with high contribution to any objective and swap them\n    # Calculate the contribution of each node to each objective\n    contributions = []\n    for k in range(n):\n        prev_node = new_solution[k-1]\n        next_node = new_solution[(k+1)%n]\n        contrib1 = distance_matrix_1[prev_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n        contrib2 = distance_matrix_2[prev_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n        contrib3 = distance_matrix_3[prev_node, new_solution[k]] + distance_matrix_3[new_solution[k], next_node]\n        contributions.append((contrib1 + contrib2 + contrib3, k))\n\n    # Sort nodes by their contribution (highest first)\n    contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top contributing nodes and perform swaps\n    top_nodes = [idx for (contrib, idx) in contributions[:min(5, n)]]\n    if len(top_nodes) >= 2:\n        a, b = np.random.choice(top_nodes, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 211,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (with high potential for improvement)\n    # We prioritize solutions that are non-dominated but with relatively high objective values\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    std_objectives = np.std(objectives, axis=0)\n\n    # Calculate a \"potential\" score for each solution\n    potentials = []\n    for sol, obj in archive:\n        # Solutions with objectives above average in at least one objective\n        # and within reasonable bounds (not too extreme)\n        potential = sum((o > avg - 0.5*std) and (o < avg + 1.5*std)\n                       for o, avg, std in zip(obj, avg_objectives, std_objectives))\n        potentials.append(potential)\n\n    # Select top 30% of solutions by potential\n    top_indices = np.argsort(potentials)[-max(1, len(archive)//3):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply 2-opt local search with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select edges to consider for 2-opt\n    # We prioritize edges that are \"critical\" in any objective space\n    critical_edges = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        # Calculate edge importance in each objective space\n        importance = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n        critical_edges.append((importance, i))\n\n    # Sort edges by importance (descending)\n    critical_edges.sort(reverse=True, key=lambda x: x[0])\n\n    # Try up to 5 most critical edges\n    for importance, i in critical_edges[:5]:\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Try reversing the segment between i and j\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check if this improves any objective\n        old_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[temp_solution[i], temp_solution[j]] + distance_matrix_1[temp_solution[j], temp_solution[k]]\n\n        old_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[temp_solution[i], temp_solution[j]] + distance_matrix_2[temp_solution[j], temp_solution[k]]\n\n        old_cost3 = distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[k]]\n        new_cost3 = distance_matrix_3[temp_solution[i], temp_solution[j]] + distance_matrix_3[temp_solution[j], temp_solution[k]]\n\n        # If improvement in at least one objective, accept\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            new_solution = temp_solution\n            break\n\n    # Step 3: Apply novel multi-objective edge swap heuristic\n    # Select a random segment and try to improve it across all objectives\n    if n > 4:\n        # Select a middle segment (not too small, not too large)\n        seg_start = random.randint(1, n//2)\n        seg_length = random.randint(2, min(5, n//3))\n\n        # Extract the segment\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Try different permutations of the segment\n        best_segment = segment.copy()\n        best_improvement = 0\n\n        # Generate all possible permutations (for small segments)\n        if seg_length <= 4:\n            for perm in np.random.permutation(np.arange(seg_length)).reshape(-1, seg_length):\n                temp_segment = segment[perm]\n\n                # Calculate total cost for this permutation\n                total_cost = 0\n                for k in range(seg_length):\n                    u = temp_segment[k]\n                    v = temp_segment[(k+1)%seg_length]\n                    total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n\n                # Compare with original segment\n                original_cost = 0\n                for k in range(seg_length):\n                    u = segment[k]\n                    v = segment[(k+1)%seg_length]\n                    original_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n\n                improvement = original_cost - total_cost\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_segment = temp_segment.copy()\n\n        # Apply the best found segment\n        new_solution[seg_start:seg_start+seg_length] = best_segment\n\n    return new_solution\n\n",
        "score": [
            -0.6580760791978187,
            3.985187840461731
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (with high potential for improvement)\n    # We prioritize solutions that are non-dominated but with relatively high objective values\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    std_objectives = np.std(objectives, axis=0)\n\n    # Calculate a \"potential\" score for each solution\n    potentials = []\n    for sol, obj in archive:\n        # Solutions with objectives above average in at least one objective\n        # and within reasonable bounds (not too extreme)\n        potential = sum((o > avg - 0.5*std) and (o < avg + 1.5*std)\n                       for o, avg, std in zip(obj, avg_objectives, std_objectives))\n        potentials.append(potential)\n\n    # Select top 30% of solutions by potential\n    top_indices = np.argsort(potentials)[-max(1, len(archive)//3):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply 2-opt local search with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select edges to consider for 2-opt\n    # We prioritize edges that are \"critical\" in any objective space\n    critical_edges = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        # Calculate edge importance in each objective space\n        importance = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n        critical_edges.append((importance, i))\n\n    # Sort edges by importance (descending)\n    critical_edges.sort(reverse=True, key=lambda x: x[0])\n\n    # Try up to 5 most critical edges\n    for importance, i in critical_edges[:5]:\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Try reversing the segment between i and j\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check if this improves any objective\n        old_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[temp_solution[i], temp_solution[j]] + distance_matrix_1[temp_solution[j], temp_solution[k]]\n\n        old_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[temp_solution[i], temp_solution[j]] + distance_matrix_2[temp_solution[j], temp_solution[k]]\n\n        old_cost3 = distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[k]]\n        new_cost3 = distance_matrix_3[temp_solution[i], temp_solution[j]] + distance_matrix_3[temp_solution[j], temp_solution[k]]\n\n        # If improvement in at least one objective, accept\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            new_solution = temp_solution\n            break\n\n    # Step 3: Apply novel multi-objective edge swap heuristic\n    # Select a random segment and try to improve it across all objectives\n    if n > 4:\n        # Select a middle segment (not too small, not too large)\n        seg_start = random.randint(1, n//2)\n        seg_length = random.randint(2, min(5, n//3))\n\n        # Extract the segment\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Try different permutations of the segment\n        best_segment = segment.copy()\n        best_improvement = 0\n\n        # Generate all possible permutations (for small segments)\n        if seg_length <= 4:\n            for perm in np.random.permutation(np.arange(seg_length)).reshape(-1, seg_length):\n                temp_segment = segment[perm]\n\n                # Calculate total cost for this permutation\n                total_cost = 0\n                for k in range(seg_length):\n                    u = temp_segment[k]\n                    v = temp_segment[(k+1)%seg_length]\n                    total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n\n                # Compare with original segment\n                original_cost = 0\n                for k in range(seg_length):\n                    u = segment[k]\n                    v = segment[(k+1)%seg_length]\n                    original_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n\n                improvement = original_cost - total_cost\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_segment = temp_segment.copy()\n\n        # Apply the best found segment\n        new_solution[seg_start:seg_start+seg_length] = best_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 212,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = []\n    for sol, obj in archive:\n        # Simple heuristic: solutions with higher total distance in any objective are more likely to improve\n        total_distance = sum(obj)\n        candidates.append((sol, total_distance))\n\n    # Sort candidates by total distance (descending) to prioritize more promising solutions\n    candidates.sort(key=lambda x: -x[1])\n    selected_sol = candidates[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-aware edge swaps\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt swap to improve tour structure\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware edge swaps\n    for _ in range(3):  # Perform 3 edge swaps\n        # Select a random edge to modify\n        k = random.randint(0, n-1)\n        l = (k + 1) % n\n\n        # Find the best candidate node to swap with\n        best_node = None\n        best_improvement = 0\n\n        for m in range(n):\n            if m == k or m == l or m == (k-1)%n or m == (l+1)%n:\n                continue\n\n            # Calculate improvement for each objective\n            old_edges = [\n                distance_matrix_1[new_solution[k], new_solution[l]],\n                distance_matrix_2[new_solution[k], new_solution[l]],\n                distance_matrix_3[new_solution[k], new_solution[l]]\n            ]\n\n            new_edges = [\n                distance_matrix_1[new_solution[k], new_solution[m]],\n                distance_matrix_2[new_solution[k], new_solution[m]],\n                distance_matrix_3[new_solution[k], new_solution[m]]\n            ]\n\n            improvement = sum(new_edges) - sum(old_edges)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_node = m\n\n        if best_node is not None:\n            # Perform the swap\n            new_solution[k], new_solution[best_node] = new_solution[best_node], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6854309740225644,
            1.1141581892967225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = []\n    for sol, obj in archive:\n        # Simple heuristic: solutions with higher total distance in any objective are more likely to improve\n        total_distance = sum(obj)\n        candidates.append((sol, total_distance))\n\n    # Sort candidates by total distance (descending) to prioritize more promising solutions\n    candidates.sort(key=lambda x: -x[1])\n    selected_sol = candidates[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-aware edge swaps\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt swap to improve tour structure\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware edge swaps\n    for _ in range(3):  # Perform 3 edge swaps\n        # Select a random edge to modify\n        k = random.randint(0, n-1)\n        l = (k + 1) % n\n\n        # Find the best candidate node to swap with\n        best_node = None\n        best_improvement = 0\n\n        for m in range(n):\n            if m == k or m == l or m == (k-1)%n or m == (l+1)%n:\n                continue\n\n            # Calculate improvement for each objective\n            old_edges = [\n                distance_matrix_1[new_solution[k], new_solution[l]],\n                distance_matrix_2[new_solution[k], new_solution[l]],\n                distance_matrix_3[new_solution[k], new_solution[l]]\n            ]\n\n            new_edges = [\n                distance_matrix_1[new_solution[k], new_solution[m]],\n                distance_matrix_2[new_solution[k], new_solution[m]],\n                distance_matrix_3[new_solution[k], new_solution[m]]\n            ]\n\n            improvement = sum(new_edges) - sum(old_edges)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_node = m\n\n        if best_node is not None:\n            # Perform the swap\n            new_solution[k], new_solution[best_node] = new_solution[best_node], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 213,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions with the lowest objectives\n        top_candidates = sorted_archive[:max(1, int(0.2 * len(archive)))]\n        # Randomly select one from the top candidates\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, apply a more sophisticated operator\n        operator = random.choice(['swap', 'reverse', 'insert', 'cross_exchange'])\n\n        if operator == 'swap':\n            # Swap two random nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operator == 'reverse':\n            # Reverse a random segment\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == 'insert':\n            # Move a random node to a different position\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        elif operator == 'cross_exchange':\n            # Cross-exchange operator (more sophisticated for TSP)\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            # Perform cross-exchange between segments [i,j] and [k,l]\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n            new_solution = np.concatenate([\n                new_solution[:i],\n                segment2,\n                new_solution[j+1:k],\n                segment1,\n                new_solution[l+1:]\n            ])\n\n    # Ensure the solution remains feasible (all nodes visited exactly once)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7130498967333585,
            0.7849987030029297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions with the lowest objectives\n        top_candidates = sorted_archive[:max(1, int(0.2 * len(archive)))]\n        # Randomly select one from the top candidates\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, apply a more sophisticated operator\n        operator = random.choice(['swap', 'reverse', 'insert', 'cross_exchange'])\n\n        if operator == 'swap':\n            # Swap two random nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operator == 'reverse':\n            # Reverse a random segment\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == 'insert':\n            # Move a random node to a different position\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        elif operator == 'cross_exchange':\n            # Cross-exchange operator (more sophisticated for TSP)\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            # Perform cross-exchange between segments [i,j] and [k,l]\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n            new_solution = np.concatenate([\n                new_solution[:i],\n                segment2,\n                new_solution[j+1:k],\n                segment1,\n                new_solution[l+1:]\n            ])\n\n    # Ensure the solution remains feasible (all nodes visited exactly once)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 214,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each objective\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices, i]\n\n        # Assign infinite crowding distance to boundary solutions\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        # Calculate crowding distance for intermediate solutions\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (sorted_objectives[j+1] - sorted_objectives[j-1]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-10)\n\n    # Select solutions with high crowding distance (promising for further improvement)\n    candidate_indices = np.argsort(-crowding_distances)[:max(1, len(archive)//3)]\n    selected_idx = random.choice(candidate_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform an objective-aware 2-opt move\n    # Calculate the current cost in all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return cost1, cost2, cost3\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try to improve by considering all three objectives\n    best_neighbor = new_solution.copy()\n    best_cost = current_cost\n\n    for _ in range(5):  # Limited number of attempts\n        i, j = sorted(random.sample(range(n), 2))\n        neighbor = new_solution.copy()\n        neighbor[i:j+1] = neighbor[i:j+1][::-1]\n\n        # Calculate the new cost\n        new_cost = calculate_cost(neighbor)\n\n        # Accept if it improves at least one objective\n        if any(new_cost[k] < best_cost[k] for k in range(3)):\n            best_neighbor = neighbor.copy()\n            best_cost = new_cost\n\n    # If no improvement, try a different operator: swap nodes based on worst objective\n    if np.array_equal(best_neighbor, new_solution):\n        # Identify the worst objective\n        worst_obj = np.argmax(current_cost)\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the pair of nodes whose swap most improves the worst objective\n        best_improvement = 0\n        best_pair = None\n\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(i-j) > 1:  # Don't consider adjacent nodes\n                    # Calculate the current and new edge costs\n                    current_edges = [\n                        (new_solution[i-1], new_solution[i], new_solution[(i+1)%n]),\n                        (new_solution[j-1], new_solution[j], new_solution[(j+1)%n])\n                    ]\n                    new_edges = [\n                        (new_solution[i-1], new_solution[j], new_solution[(i+1)%n]),\n                        (new_solution[j-1], new_solution[i], new_solution[(j+1)%n])\n                    ]\n\n                    current_cost = sum(dist_matrix[a][b] + dist_matrix[b][c] for a, b, c in current_edges)\n                    new_cost = sum(dist_matrix[a][b] + dist_matrix[b][c] for a, b, c in new_edges)\n\n                    improvement = current_cost - new_cost\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pair = (i, j)\n\n        if best_pair is not None:\n            i, j = best_pair\n            best_neighbor[i], best_neighbor[j] = best_neighbor[j], best_neighbor[i]\n\n    return best_neighbor\n\n",
        "score": [
            -0.6917094137417822,
            1.9139087200164795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each objective\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices, i]\n\n        # Assign infinite crowding distance to boundary solutions\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        # Calculate crowding distance for intermediate solutions\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (sorted_objectives[j+1] - sorted_objectives[j-1]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-10)\n\n    # Select solutions with high crowding distance (promising for further improvement)\n    candidate_indices = np.argsort(-crowding_distances)[:max(1, len(archive)//3)]\n    selected_idx = random.choice(candidate_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform an objective-aware 2-opt move\n    # Calculate the current cost in all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return cost1, cost2, cost3\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try to improve by considering all three objectives\n    best_neighbor = new_solution.copy()\n    best_cost = current_cost\n\n    for _ in range(5):  # Limited number of attempts\n        i, j = sorted(random.sample(range(n), 2))\n        neighbor = new_solution.copy()\n        neighbor[i:j+1] = neighbor[i:j+1][::-1]\n\n        # Calculate the new cost\n        new_cost = calculate_cost(neighbor)\n\n        # Accept if it improves at least one objective\n        if any(new_cost[k] < best_cost[k] for k in range(3)):\n            best_neighbor = neighbor.copy()\n            best_cost = new_cost\n\n    # If no improvement, try a different operator: swap nodes based on worst objective\n    if np.array_equal(best_neighbor, new_solution):\n        # Identify the worst objective\n        worst_obj = np.argmax(current_cost)\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the pair of nodes whose swap most improves the worst objective\n        best_improvement = 0\n        best_pair = None\n\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(i-j) > 1:  # Don't consider adjacent nodes\n                    # Calculate the current and new edge costs\n                    current_edges = [\n                        (new_solution[i-1], new_solution[i], new_solution[(i+1)%n]),\n                        (new_solution[j-1], new_solution[j], new_solution[(j+1)%n])\n                    ]\n                    new_edges = [\n                        (new_solution[i-1], new_solution[j], new_solution[(i+1)%n]),\n                        (new_solution[j-1], new_solution[i], new_solution[(j+1)%n])\n                    ]\n\n                    current_cost = sum(dist_matrix[a][b] + dist_matrix[b][c] for a, b, c in current_edges)\n                    new_cost = sum(dist_matrix[a][b] + dist_matrix[b][c] for a, b, c in new_edges)\n\n                    improvement = current_cost - new_cost\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pair = (i, j)\n\n        if best_pair is not None:\n            i, j = best_pair\n            best_neighbor[i], best_neighbor[j] = best_neighbor[j], best_neighbor[i]\n\n    return best_neighbor\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 215,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Select two random edges that are not adjacent\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        while abs(i - j) <= 1:\n            i, j = sorted(random.sample(range(1, n-1), 2))\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[j+1]]) - \\\n                (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[j+1]]) - \\\n                (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[j+1]]) - \\\n                (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n        # Accept the move if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 2-opt pass with objective-aware edge selection\n    for _ in range(3):\n        # Select edges based on their contribution to the worst-performing objective\n        worst_obj = np.argmax(archive[selected_idx][1])\n        if worst_obj == 0:\n            current_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            current_matrix = distance_matrix_2\n        else:\n            current_matrix = distance_matrix_3\n\n        # Find the worst edge in the current tour\n        max_edge = -1\n        max_edge_value = -1\n        for k in range(n-1):\n            edge_value = current_matrix[new_solution[k], new_solution[k+1]]\n            if edge_value > max_edge_value:\n                max_edge_value = edge_value\n                max_edge = k\n\n        # Perform 2-opt on the worst edge\n        if max_edge != -1:\n            i, j = max_edge, max_edge + 1\n            if i > 0 and j < n-1:\n                # Check if reversing this segment improves the worst objective\n                delta = (current_matrix[new_solution[i-1], new_solution[j]] +\n                        current_matrix[new_solution[i], new_solution[j+1]]) - \\\n                       (current_matrix[new_solution[i-1], new_solution[i]] +\n                        current_matrix[new_solution[j], new_solution[j+1]])\n                if delta < 0:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7045878377396652,
            0.7687507033348083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Select two random edges that are not adjacent\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        while abs(i - j) <= 1:\n            i, j = sorted(random.sample(range(1, n-1), 2))\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[j+1]]) - \\\n                (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[j+1]]) - \\\n                (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[j+1]]) - \\\n                (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n        # Accept the move if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 2-opt pass with objective-aware edge selection\n    for _ in range(3):\n        # Select edges based on their contribution to the worst-performing objective\n        worst_obj = np.argmax(archive[selected_idx][1])\n        if worst_obj == 0:\n            current_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            current_matrix = distance_matrix_2\n        else:\n            current_matrix = distance_matrix_3\n\n        # Find the worst edge in the current tour\n        max_edge = -1\n        max_edge_value = -1\n        for k in range(n-1):\n            edge_value = current_matrix[new_solution[k], new_solution[k+1]]\n            if edge_value > max_edge_value:\n                max_edge_value = edge_value\n                max_edge = k\n\n        # Perform 2-opt on the worst edge\n        if max_edge != -1:\n            i, j = max_edge, max_edge + 1\n            if i > 0 and j < n-1:\n                # Check if reversing this segment improves the worst objective\n                delta = (current_matrix[new_solution[i-1], new_solution[j]] +\n                        current_matrix[new_solution[i], new_solution[j+1]]) - \\\n                       (current_matrix[new_solution[i-1], new_solution[i]] +\n                        current_matrix[new_solution[j], new_solution[j+1]])\n                if delta < 0:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 216,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [(sol, obj) for sol, obj in archive if not all(obj[i] == min(o[i] for _, o in archive) for i in range(3))]\n    if not candidates:\n        candidates = archive\n\n    # Randomly select a promising solution (weighted by objective diversity)\n    weights = [sum(1 for i in range(3) if obj[i] > min(o[i] for _, o in archive)) for sol, obj in candidates]\n    selected_idx = np.random.choice(len(candidates), p=np.array(weights)/sum(weights))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware selection\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate potential swap in all three objectives\n        original_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j-1]]\n        )\n\n        # Accept swap if it improves at least one objective without worsening others too much\n        if any(new_costs[k] < original_costs[k] for k in range(3)) and \\\n           all(new_costs[k] <= 1.1 * original_costs[k] for k in range(3)):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional edge swap based on objective diversity\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Evaluate potential edge swap in all objectives\n        original_edges = (\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j])\n        )\n        new_edges = (\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j-1], new_solution[i])\n        )\n\n        original_costs = (\n            sum(distance_matrix_1[e[0], e[1]] for e in original_edges),\n            sum(distance_matrix_2[e[0], e[1]] for e in original_edges),\n            sum(distance_matrix_3[e[0], e[1]] for e in original_edges)\n        )\n\n        new_costs = (\n            sum(distance_matrix_1[e[0], e[1]] for e in new_edges),\n            sum(distance_matrix_2[e[0], e[1]] for e in new_edges),\n            sum(distance_matrix_3[e[0], e[1]] for e in new_edges)\n        )\n\n        # Accept swap if it improves at least one objective\n        if any(new_costs[k] < original_costs[k] for k in range(3)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7845101002095702,
            2.6309531569480895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [(sol, obj) for sol, obj in archive if not all(obj[i] == min(o[i] for _, o in archive) for i in range(3))]\n    if not candidates:\n        candidates = archive\n\n    # Randomly select a promising solution (weighted by objective diversity)\n    weights = [sum(1 for i in range(3) if obj[i] > min(o[i] for _, o in archive)) for sol, obj in candidates]\n    selected_idx = np.random.choice(len(candidates), p=np.array(weights)/sum(weights))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware selection\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate potential swap in all three objectives\n        original_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j-1]]\n        )\n\n        # Accept swap if it improves at least one objective without worsening others too much\n        if any(new_costs[k] < original_costs[k] for k in range(3)) and \\\n           all(new_costs[k] <= 1.1 * original_costs[k] for k in range(3)):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional edge swap based on objective diversity\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Evaluate potential edge swap in all objectives\n        original_edges = (\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j])\n        )\n        new_edges = (\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j-1], new_solution[i])\n        )\n\n        original_costs = (\n            sum(distance_matrix_1[e[0], e[1]] for e in original_edges),\n            sum(distance_matrix_2[e[0], e[1]] for e in original_edges),\n            sum(distance_matrix_3[e[0], e[1]] for e in original_edges)\n        )\n\n        new_costs = (\n            sum(distance_matrix_1[e[0], e[1]] for e in new_edges),\n            sum(distance_matrix_2[e[0], e[1]] for e in new_edges),\n            sum(distance_matrix_3[e[0], e[1]] for e in new_edges)\n        )\n\n        # Accept swap if it improves at least one objective\n        if any(new_costs[k] < original_costs[k] for k in range(3)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 217,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total distance across all objectives (promising for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Objective-aware edge selection: prefer edges that are critical in any of the three objectives\n    # Calculate the improvement in all three objectives\n    def calculate_improvement(sol, i, j):\n        # Original edges\n        orig_edges = [\n            (sol[i-1], sol[i]),\n            (sol[i], sol[j]),\n            (sol[j], sol[j+1] if j+1 < n else sol[0]),\n            (sol[j], sol[i])\n        ]\n\n        # New edges\n        new_edges = [\n            (sol[i-1], sol[j]),\n            (sol[j], sol[i]),\n            (sol[i], sol[j+1] if j+1 < n else sol[0])\n        ]\n\n        # Calculate improvement in each objective\n        orig_cost = [\n            sum(distance_matrix_1[e[0], e[1]] for e in orig_edges),\n            sum(distance_matrix_2[e[0], e[1]] for e in orig_edges),\n            sum(distance_matrix_3[e[0], e[1]] for e in orig_edges)\n        ]\n\n        new_cost = [\n            sum(distance_matrix_1[e[0], e[1]] for e in new_edges),\n            sum(distance_matrix_2[e[0], e[1]] for e in new_edges),\n            sum(distance_matrix_3[e[0], e[1]] for e in new_edges)\n        ]\n\n        improvement = [orig_cost[k] - new_cost[k] for k in range(3)]\n        return improvement\n\n    improvement = calculate_improvement(new_solution, i, j)\n\n    # If improvement is positive in at least one objective, perform the swap\n    if any(imp > 0 for imp in improvement):\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # If no improvement, try a different operator: relocate a node based on objective diversity\n    else:\n        # Select a node to relocate\n        k = np.random.randint(0, n)\n\n        # Calculate potential insertion points and their impact on objectives\n        best_pos = -1\n        best_improvement = [0, 0, 0]\n\n        for pos in range(n):\n            if pos == k or pos == (k-1) % n:\n                continue\n\n            # Try inserting node k before position pos\n            temp_sol = new_solution.copy()\n            node = temp_sol[k]\n            temp_sol = np.delete(temp_sol, k)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            # Calculate improvement\n            current_improvement = [\n                sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n)) -\n                sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n)) -\n                sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n)) -\n                sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            ]\n\n            # If this insertion improves any objective, keep it\n            if any(imp < 0 for imp in current_improvement):\n                best_pos = pos\n                best_improvement = current_improvement\n                break\n\n        # Perform the best relocation if found\n        if best_pos != -1:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6415560961023277,
            1.2324526190757752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total distance across all objectives (promising for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Objective-aware edge selection: prefer edges that are critical in any of the three objectives\n    # Calculate the improvement in all three objectives\n    def calculate_improvement(sol, i, j):\n        # Original edges\n        orig_edges = [\n            (sol[i-1], sol[i]),\n            (sol[i], sol[j]),\n            (sol[j], sol[j+1] if j+1 < n else sol[0]),\n            (sol[j], sol[i])\n        ]\n\n        # New edges\n        new_edges = [\n            (sol[i-1], sol[j]),\n            (sol[j], sol[i]),\n            (sol[i], sol[j+1] if j+1 < n else sol[0])\n        ]\n\n        # Calculate improvement in each objective\n        orig_cost = [\n            sum(distance_matrix_1[e[0], e[1]] for e in orig_edges),\n            sum(distance_matrix_2[e[0], e[1]] for e in orig_edges),\n            sum(distance_matrix_3[e[0], e[1]] for e in orig_edges)\n        ]\n\n        new_cost = [\n            sum(distance_matrix_1[e[0], e[1]] for e in new_edges),\n            sum(distance_matrix_2[e[0], e[1]] for e in new_edges),\n            sum(distance_matrix_3[e[0], e[1]] for e in new_edges)\n        ]\n\n        improvement = [orig_cost[k] - new_cost[k] for k in range(3)]\n        return improvement\n\n    improvement = calculate_improvement(new_solution, i, j)\n\n    # If improvement is positive in at least one objective, perform the swap\n    if any(imp > 0 for imp in improvement):\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # If no improvement, try a different operator: relocate a node based on objective diversity\n    else:\n        # Select a node to relocate\n        k = np.random.randint(0, n)\n\n        # Calculate potential insertion points and their impact on objectives\n        best_pos = -1\n        best_improvement = [0, 0, 0]\n\n        for pos in range(n):\n            if pos == k or pos == (k-1) % n:\n                continue\n\n            # Try inserting node k before position pos\n            temp_sol = new_solution.copy()\n            node = temp_sol[k]\n            temp_sol = np.delete(temp_sol, k)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            # Calculate improvement\n            current_improvement = [\n                sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n)) -\n                sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n)) -\n                sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n)) -\n                sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            ]\n\n            # If this insertion improves any objective, keep it\n            if any(imp < 0 for imp in current_improvement):\n                best_pos = pos\n                best_improvement = current_improvement\n                break\n\n        # Perform the best relocation if found\n        if best_pos != -1:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 218,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with the best combined objective values\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and objective-specific swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and objective-specific local search\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-specific local search: identify the worst objective and improve it\n        objectives = archive[0][1]\n        worst_obj = np.argmax(objectives)\n\n        if worst_obj == 0:\n            # Focus on improving the first objective\n            for _ in range(5):  # Try a few swaps\n                a, b = np.random.choice(n, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Calculate current and potential costs\n                current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                               distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n                if new_cost < current_cost:\n                    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                    break\n        elif worst_obj == 1:\n            # Focus on improving the second objective\n            for _ in range(5):\n                a, b = np.random.choice(n, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                current_cost = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                               distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                new_cost = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n                if new_cost < current_cost:\n                    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                    break\n        else:\n            # Focus on improving the third objective\n            for _ in range(5):\n                a, b = np.random.choice(n, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                current_cost = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                               distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n                new_cost = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n                if new_cost < current_cost:\n                    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7053719095552224,
            1.339012897014618
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with the best combined objective values\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and objective-specific swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and objective-specific local search\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-specific local search: identify the worst objective and improve it\n        objectives = archive[0][1]\n        worst_obj = np.argmax(objectives)\n\n        if worst_obj == 0:\n            # Focus on improving the first objective\n            for _ in range(5):  # Try a few swaps\n                a, b = np.random.choice(n, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Calculate current and potential costs\n                current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                               distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n                if new_cost < current_cost:\n                    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                    break\n        elif worst_obj == 1:\n            # Focus on improving the second objective\n            for _ in range(5):\n                a, b = np.random.choice(n, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                current_cost = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                               distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                new_cost = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n                if new_cost < current_cost:\n                    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                    break\n        else:\n            # Focus on improving the third objective\n            for _ in range(5):\n                a, b = np.random.choice(n, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                current_cost = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                               distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n                new_cost = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n                if new_cost < current_cost:\n                    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 219,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, apply a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform objective-aware swaps to improve multiple objectives\n    for _ in range(3):  # Number of swaps to attempt\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential objective values\n        current_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        potential_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(potential_cost, current_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.670015915567953,
            0.9292657494544982
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, apply a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform objective-aware swaps to improve multiple objectives\n    for _ in range(3):  # Number of swaps to attempt\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential objective values\n        current_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        potential_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(potential_cost, current_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 220,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (promising for local improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes for meaningful local search\n\n    # Objective-aware selection: choose the worst objective to improve\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Perform 2-opt or 3-opt based on the worst objective\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt with objective-aware edge selection\n        i, j = sorted(random.sample(range(n), 2))\n        if worst_obj == 0:\n            # Prefer edges that are long in the worst objective space\n            if distance_matrix_1[new_solution[i], new_solution[j]] > np.median(distance_matrix_1):\n                new_solution[i:j] = new_solution[i:j][::-1]\n        elif worst_obj == 1:\n            if distance_matrix_2[new_solution[i], new_solution[j]] > np.median(distance_matrix_2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            if distance_matrix_3[new_solution[i], new_solution[j]] > np.median(distance_matrix_3):\n                new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for 3-opt\n        # 3-opt with objective-aware selection\n        i, j, k = sorted(random.sample(range(n), 3))\n        if worst_obj == 0:\n            # Prefer segments that are long in the worst objective space\n            if (distance_matrix_1[new_solution[i], new_solution[j]] +\n                distance_matrix_1[new_solution[j], new_solution[k]]) > np.median(distance_matrix_1):\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n        elif worst_obj == 1:\n            if (distance_matrix_2[new_solution[i], new_solution[j]] +\n                distance_matrix_2[new_solution[j], new_solution[k]]) > np.median(distance_matrix_2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            if (distance_matrix_3[new_solution[i], new_solution[j]] +\n                distance_matrix_3[new_solution[j], new_solution[k]]) > np.median(distance_matrix_3):\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7622874218892199,
            0.8390724182128906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (promising for local improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes for meaningful local search\n\n    # Objective-aware selection: choose the worst objective to improve\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Perform 2-opt or 3-opt based on the worst objective\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt with objective-aware edge selection\n        i, j = sorted(random.sample(range(n), 2))\n        if worst_obj == 0:\n            # Prefer edges that are long in the worst objective space\n            if distance_matrix_1[new_solution[i], new_solution[j]] > np.median(distance_matrix_1):\n                new_solution[i:j] = new_solution[i:j][::-1]\n        elif worst_obj == 1:\n            if distance_matrix_2[new_solution[i], new_solution[j]] > np.median(distance_matrix_2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            if distance_matrix_3[new_solution[i], new_solution[j]] > np.median(distance_matrix_3):\n                new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for 3-opt\n        # 3-opt with objective-aware selection\n        i, j, k = sorted(random.sample(range(n), 3))\n        if worst_obj == 0:\n            # Prefer segments that are long in the worst objective space\n            if (distance_matrix_1[new_solution[i], new_solution[j]] +\n                distance_matrix_1[new_solution[j], new_solution[k]]) > np.median(distance_matrix_1):\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n        elif worst_obj == 1:\n            if (distance_matrix_2[new_solution[i], new_solution[j]] +\n                distance_matrix_2[new_solution[j], new_solution[k]]) > np.median(distance_matrix_2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            if (distance_matrix_3[new_solution[i], new_solution[j]] +\n                distance_matrix_3[new_solution[j], new_solution[k]]) > np.median(distance_matrix_3):\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 221,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% with higher probability\n        top_30_percent = int(len(sorted_solutions) * 0.3)\n        if top_30_percent == 0:\n            top_30_percent = 1\n        selected_index = random.randint(0, top_30_percent - 1)\n        base_solution = sorted_solutions[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on the solution\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for a more complex move\n        # Perform a combination of 2-opt and node insertion\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # 2-opt\n        # Node insertion\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.744874629997464,
            0.6659919619560242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% with higher probability\n        top_30_percent = int(len(sorted_solutions) * 0.3)\n        if top_30_percent == 0:\n            top_30_percent = 1\n        selected_index = random.randint(0, top_30_percent - 1)\n        base_solution = sorted_solutions[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on the solution\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for a more complex move\n        # Perform a combination of 2-opt and node insertion\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # 2-opt\n        # Node insertion\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 222,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% or randomly if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected = random.choice(selection_pool)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt and edge exchange\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange: swap two edges to create a new tour\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n        if i == k or j == l:\n            # Ensure valid exchange\n            if i == k:\n                k = (k + 1) % n\n            if j == l:\n                l = (l + 1) % n\n        # Perform the exchange\n        new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6552136187357418,
            1.0009170532226563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% or randomly if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected = random.choice(selection_pool)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt and edge exchange\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange: swap two edges to create a new tour\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n        if i == k or j == l:\n            # Ensure valid exchange\n            if i == k:\n                k = (k + 1) % n\n            if j == l:\n                l = (l + 1) % n\n        # Perform the exchange\n        new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 223,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations to explore neighborhood\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k = np.random.randint(0, n)\n\n        # 2-opt move (standard local search)\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware swap: swap nodes that are far in one space but close in others\n        if k != i and k != j:\n            obj1_diff = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                         distance_matrix_1[new_solution[k], new_solution[i]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[k], new_solution[i+1 if i+1 < n else 0]])\n\n            obj2_diff = (distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[k], new_solution[i]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[k], new_solution[i+1 if i+1 < n else 0]])\n\n            obj3_diff = (distance_matrix_3[new_solution[i-1], new_solution[k]] +\n                         distance_matrix_3[new_solution[k], new_solution[i]] -\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_3[new_solution[k], new_solution[i+1 if i+1 < n else 0]])\n\n            if (obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0):\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6336178410118379,
            1.4098013043403625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations to explore neighborhood\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k = np.random.randint(0, n)\n\n        # 2-opt move (standard local search)\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware swap: swap nodes that are far in one space but close in others\n        if k != i and k != j:\n            obj1_diff = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                         distance_matrix_1[new_solution[k], new_solution[i]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[k], new_solution[i+1 if i+1 < n else 0]])\n\n            obj2_diff = (distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[k], new_solution[i]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[k], new_solution[i+1 if i+1 < n else 0]])\n\n            obj3_diff = (distance_matrix_3[new_solution[i-1], new_solution[k]] +\n                         distance_matrix_3[new_solution[k], new_solution[i]] -\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_3[new_solution[k], new_solution[i+1 if i+1 < n else 0]])\n\n            if (obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0):\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 224,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware refinement: swap nodes that improve at least one objective\n    for _ in range(3):  # Limit iterations to prevent excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        original_costs = [\n            distance_matrix_1[base_solution[a-1], base_solution[a]] +\n            distance_matrix_1[base_solution[b-1], base_solution[b]],\n            distance_matrix_2[base_solution[a-1], base_solution[a]] +\n            distance_matrix_2[base_solution[b-1], base_solution[b]],\n            distance_matrix_3[base_solution[a-1], base_solution[a]] +\n            distance_matrix_3[base_solution[b-1], base_solution[b]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[base_solution[a-1], base_solution[b]] +\n            distance_matrix_1[base_solution[b-1], base_solution[a]],\n            distance_matrix_2[base_solution[a-1], base_solution[b]] +\n            distance_matrix_2[base_solution[b-1], base_solution[a]],\n            distance_matrix_3[base_solution[a-1], base_solution[b]] +\n            distance_matrix_3[base_solution[b-1], base_solution[a]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7616894336023561,
            0.9826076865196228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware refinement: swap nodes that improve at least one objective\n    for _ in range(3):  # Limit iterations to prevent excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        original_costs = [\n            distance_matrix_1[base_solution[a-1], base_solution[a]] +\n            distance_matrix_1[base_solution[b-1], base_solution[b]],\n            distance_matrix_2[base_solution[a-1], base_solution[a]] +\n            distance_matrix_2[base_solution[b-1], base_solution[b]],\n            distance_matrix_3[base_solution[a-1], base_solution[a]] +\n            distance_matrix_3[base_solution[b-1], base_solution[b]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[base_solution[a-1], base_solution[b]] +\n            distance_matrix_1[base_solution[b-1], base_solution[a]],\n            distance_matrix_2[base_solution[a-1], base_solution[b]] +\n            distance_matrix_2[base_solution[b-1], base_solution[a]],\n            distance_matrix_3[base_solution[a-1], base_solution[b]] +\n            distance_matrix_3[base_solution[b-1], base_solution[a]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 225,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity (based on objective space distances)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Find the worst edge in any of the three objective spaces\n    worst_edge = -1\n    max_diff = -1\n    for i in range(n):\n        j = (i + 1) % n\n        a, b = new_solution[i], new_solution[j]\n        # Calculate edge cost differences across objectives\n        diff1 = distance_matrix_1[a, b] - (distance_matrix_1[a, new_solution[(i-1)%n]] + distance_matrix_1[b, new_solution[(j+1)%n]])\n        diff2 = distance_matrix_2[a, b] - (distance_matrix_2[a, new_solution[(i-1)%n]] + distance_matrix_2[b, new_solution[(j+1)%n]])\n        diff3 = distance_matrix_3[a, b] - (distance_matrix_3[a, new_solution[(i-1)%n]] + distance_matrix_3[b, new_solution[(j+1)%n]])\n        total_diff = abs(diff1) + abs(diff2) + abs(diff3)\n\n        if total_diff > max_diff:\n            max_diff = total_diff\n            worst_edge = i\n\n    if worst_edge != -1:\n        # Perform 2-opt move\n        i, j = worst_edge, (worst_edge + 1) % n\n        # Find the best possible reconnection across objectives\n        best_reconnection = -1\n        min_total_cost = float('inf')\n\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n\n            # Calculate total cost after reconnection\n            cost1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                     distance_matrix_1[new_solution[j], new_solution[(k+1)%n]])\n            cost2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                     distance_matrix_2[new_solution[j], new_solution[(k+1)%n]])\n            cost3 = (distance_matrix_3[new_solution[i], new_solution[k]] +\n                     distance_matrix_3[new_solution[j], new_solution[(k+1)%n]])\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_reconnection = k\n\n        if best_reconnection != -1:\n            # Reverse the segment between i and best_reconnection\n            new_solution[i+1:best_reconnection+1] = new_solution[i+1:best_reconnection+1][::-1]\n\n    # Also consider a random 2-opt move for exploration\n    if np.random.random() < 0.3:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6986932278963678,
            1.224733829498291
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity (based on objective space distances)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Find the worst edge in any of the three objective spaces\n    worst_edge = -1\n    max_diff = -1\n    for i in range(n):\n        j = (i + 1) % n\n        a, b = new_solution[i], new_solution[j]\n        # Calculate edge cost differences across objectives\n        diff1 = distance_matrix_1[a, b] - (distance_matrix_1[a, new_solution[(i-1)%n]] + distance_matrix_1[b, new_solution[(j+1)%n]])\n        diff2 = distance_matrix_2[a, b] - (distance_matrix_2[a, new_solution[(i-1)%n]] + distance_matrix_2[b, new_solution[(j+1)%n]])\n        diff3 = distance_matrix_3[a, b] - (distance_matrix_3[a, new_solution[(i-1)%n]] + distance_matrix_3[b, new_solution[(j+1)%n]])\n        total_diff = abs(diff1) + abs(diff2) + abs(diff3)\n\n        if total_diff > max_diff:\n            max_diff = total_diff\n            worst_edge = i\n\n    if worst_edge != -1:\n        # Perform 2-opt move\n        i, j = worst_edge, (worst_edge + 1) % n\n        # Find the best possible reconnection across objectives\n        best_reconnection = -1\n        min_total_cost = float('inf')\n\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n\n            # Calculate total cost after reconnection\n            cost1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                     distance_matrix_1[new_solution[j], new_solution[(k+1)%n]])\n            cost2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                     distance_matrix_2[new_solution[j], new_solution[(k+1)%n]])\n            cost3 = (distance_matrix_3[new_solution[i], new_solution[k]] +\n                     distance_matrix_3[new_solution[j], new_solution[(k+1)%n]])\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_reconnection = k\n\n        if best_reconnection != -1:\n            # Reverse the segment between i and best_reconnection\n            new_solution[i+1:best_reconnection+1] = new_solution[i+1:best_reconnection+1][::-1]\n\n    # Also consider a random 2-opt move for exploration\n    if np.random.random() < 0.3:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 226,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst objective and try to improve it\n    obj1, obj2, obj3 = objectives\n    worst_obj = np.argmax([obj1, obj2, obj3])\n\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the worst objective\n    worst_edge = -1\n    max_edge_cost = -1\n    for k in range(n):\n        u = new_solution[k]\n        v = new_solution[(k+1) % n]\n        cost = distance_matrix[u, v]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            worst_edge = k\n\n    # Try to improve the worst edge by swapping with a nearby node\n    if worst_edge != -1:\n        u = new_solution[worst_edge]\n        v = new_solution[(worst_edge+1) % n]\n\n        # Find the best possible swap to replace (u, v)\n        best_swap = None\n        min_gain = float('inf')\n\n        for candidate in range(n):\n            if candidate in [worst_edge, (worst_edge+1) % n]:\n                continue\n\n            # Try inserting candidate between u and v\n            temp_solution = new_solution.copy()\n            temp_solution = np.roll(temp_solution, -worst_edge)\n            temp_solution[1] = candidate\n            temp_solution = np.roll(temp_solution, worst_edge)\n\n            # Calculate the gain in the worst objective\n            cost_before = distance_matrix[u, v]\n            cost_after = distance_matrix[u, candidate] + distance_matrix[candidate, v]\n            gain = cost_before - cost_after\n\n            if gain > min_gain:\n                min_gain = gain\n                best_swap = candidate\n\n        if best_swap is not None:\n            # Apply the best swap\n            new_solution = np.roll(new_solution, -worst_edge)\n            new_solution[1] = best_swap\n            new_solution = np.roll(new_solution, worst_edge)\n\n    return new_solution\n\n",
        "score": [
            -0.8325565602088527,
            1.661728322505951
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst objective and try to improve it\n    obj1, obj2, obj3 = objectives\n    worst_obj = np.argmax([obj1, obj2, obj3])\n\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the worst objective\n    worst_edge = -1\n    max_edge_cost = -1\n    for k in range(n):\n        u = new_solution[k]\n        v = new_solution[(k+1) % n]\n        cost = distance_matrix[u, v]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            worst_edge = k\n\n    # Try to improve the worst edge by swapping with a nearby node\n    if worst_edge != -1:\n        u = new_solution[worst_edge]\n        v = new_solution[(worst_edge+1) % n]\n\n        # Find the best possible swap to replace (u, v)\n        best_swap = None\n        min_gain = float('inf')\n\n        for candidate in range(n):\n            if candidate in [worst_edge, (worst_edge+1) % n]:\n                continue\n\n            # Try inserting candidate between u and v\n            temp_solution = new_solution.copy()\n            temp_solution = np.roll(temp_solution, -worst_edge)\n            temp_solution[1] = candidate\n            temp_solution = np.roll(temp_solution, worst_edge)\n\n            # Calculate the gain in the worst objective\n            cost_before = distance_matrix[u, v]\n            cost_after = distance_matrix[u, candidate] + distance_matrix[candidate, v]\n            gain = cost_before - cost_after\n\n            if gain > min_gain:\n                min_gain = gain\n                best_swap = candidate\n\n        if best_swap is not None:\n            # Apply the best swap\n            new_solution = np.roll(new_solution, -worst_edge)\n            new_solution[1] = best_swap\n            new_solution = np.roll(new_solution, worst_edge)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 227,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of objectives to prioritize those with the best combined performance\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select top 20% solutions for random selection\n    top_k = max(1, len(archive_sorted) // 5)\n    selected_solutions = archive_sorted[:top_k]\n\n    # Randomly select one solution from the top candidates\n    selected_pair = random.choice(selected_solutions)\n    base_solution = selected_pair[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a bias towards improving the worst objective\n    obj1, obj2, obj3 = selected_pair[1]\n    worst_obj = np.argmax([obj1, obj2, obj3])\n\n    # Choose the appropriate distance matrix based on the worst objective\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Perform 2-opt on the worst objective\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional random swap to ensure diversity\n    if random.random() < 0.3:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6624637458731322,
            0.631957495212555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of objectives to prioritize those with the best combined performance\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select top 20% solutions for random selection\n    top_k = max(1, len(archive_sorted) // 5)\n    selected_solutions = archive_sorted[:top_k]\n\n    # Randomly select one solution from the top candidates\n    selected_pair = random.choice(selected_solutions)\n    base_solution = selected_pair[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a bias towards improving the worst objective\n    obj1, obj2, obj3 = selected_pair[1]\n    worst_obj = np.argmax([obj1, obj2, obj3])\n\n    # Choose the appropriate distance matrix based on the worst objective\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Perform 2-opt on the worst objective\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional random swap to ensure diversity\n    if random.random() < 0.3:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 228,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives (promising for improvement)\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.std([obj[i] for _, obj in archive]) for i in range(3)]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly select two segments to exchange (2-opt)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6967415083176041,
            1.136572575569153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives (promising for improvement)\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.std([obj[i] for _, obj in archive]) for i in range(3)]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly select two segments to exchange (2-opt)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 229,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum indicates more potential)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% solutions for random selection\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        selected = random.choice(top_solutions)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    operator = random.choice(['2opt', 'node_insertion', 'swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt on the solution\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator == 'node_insertion':\n        # Perform node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n    else:\n        # Perform swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or omissions)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.515046880019119,
            1.0832986950874328
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum indicates more potential)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% solutions for random selection\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        selected = random.choice(top_solutions)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    operator = random.choice(['2opt', 'node_insertion', 'swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt on the solution\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator == 'node_insertion':\n        # Perform node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n    else:\n        # Perform swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or omissions)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 230,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware perturbation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to a randomly selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation: swap nodes based on their contribution to all three objectives\n    if np.random.rand() < 0.3:  # 30% chance to apply perturbation\n        # Calculate the total contribution of each node to all objectives\n        contributions = np.zeros(n)\n        for k in range(n):\n            node = new_solution[k]\n            prev_node = new_solution[k-1]\n            next_node = new_solution[(k+1) % n]\n            contributions[k] = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                               distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                               distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n\n        # Find the two nodes with the highest contributions\n        worst_nodes = np.argsort(contributions)[-2:]\n        # Swap them to explore a different part of the search space\n        new_solution[worst_nodes[0]], new_solution[worst_nodes[1]] = new_solution[worst_nodes[1]], new_solution[worst_nodes[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.48779800327806766,
            1.1136748790740967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware perturbation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to a randomly selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation: swap nodes based on their contribution to all three objectives\n    if np.random.rand() < 0.3:  # 30% chance to apply perturbation\n        # Calculate the total contribution of each node to all objectives\n        contributions = np.zeros(n)\n        for k in range(n):\n            node = new_solution[k]\n            prev_node = new_solution[k-1]\n            next_node = new_solution[(k+1) % n]\n            contributions[k] = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                               distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                               distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n\n        # Find the two nodes with the highest contributions\n        worst_nodes = np.argsort(contributions)[-2:]\n        # Swap them to explore a different part of the search space\n        new_solution[worst_nodes[0]], new_solution[worst_nodes[1]] = new_solution[worst_nodes[1]], new_solution[worst_nodes[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 231,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    # We prioritize solutions that have not been well-explored\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a score for each solution based on its objective values (lower is better)\n    # We use a weighted sum to balance the three objectives\n    weights = np.array([0.4, 0.3, 0.3])  # Adjust weights based on problem characteristics\n    scores = np.array([np.dot(weights, obj) for obj in archive_objectives])\n\n    # Select the solution with the lowest score (best current solution)\n    best_idx = np.argmin(scores)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective aware perturbations\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt local search\n    for _ in range(10):  # Limit the number of iterations to prevent excessive computation\n        i, j = np.random.randint(0, n, size=2)\n        if i == j:\n            continue\n\n        # Ensure i < j for simplicity\n        if i > j:\n            i, j = j, i\n\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check if the new solution is better in at least one objective\n        old_cost1 = sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        old_cost2 = sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        old_cost3 = sum(distance_matrix_3[base_solution[k-1], base_solution[k]] for k in range(n))\n        new_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        # If the new solution is not better in at least one objective, revert\n        if (new_cost1 >= old_cost1 and new_cost2 >= old_cost2 and new_cost3 >= old_cost3):\n            new_solution = base_solution.copy()\n        else:\n            base_solution = new_solution.copy()\n\n    # Apply multi-objective aware perturbation\n    # Select a segment to perturb based on the worst objective\n    current_costs = [\n        sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k-1], base_solution[k]] for k in range(n))\n    ]\n\n    # Identify the worst objective (highest cost)\n    worst_obj_idx = np.argmax(current_costs)\n\n    # Perturb the solution to improve the worst objective\n    if worst_obj_idx == 0:\n        # For the first objective, perform a more aggressive 2-opt\n        for _ in range(5):\n            i, j = np.random.randint(0, n, size=2)\n            if i == j:\n                continue\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            if new_cost1 < current_costs[0]:\n                base_solution = new_solution.copy()\n                current_costs[0] = new_cost1\n            else:\n                new_solution = base_solution.copy()\n    elif worst_obj_idx == 1:\n        # For the second objective, perform a different local search operator\n        # Example: Insertion move\n        for _ in range(5):\n            i, j = np.random.randint(0, n, size=2)\n            if i == j:\n                continue\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n            new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            if new_cost2 < current_costs[1]:\n                base_solution = new_solution.copy()\n                current_costs[1] = new_cost2\n            else:\n                new_solution = base_solution.copy()\n    else:\n        # For the third objective, perform a swap move\n        for _ in range(5):\n            i, j = np.random.randint(0, n, size=2)\n            if i == j:\n                continue\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n            if new_cost3 < current_costs[2]:\n                base_solution = new_solution.copy()\n                current_costs[2] = new_cost3\n            else:\n                new_solution = base_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -0.7092507987233847,
            3.152224671840668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    # We prioritize solutions that have not been well-explored\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a score for each solution based on its objective values (lower is better)\n    # We use a weighted sum to balance the three objectives\n    weights = np.array([0.4, 0.3, 0.3])  # Adjust weights based on problem characteristics\n    scores = np.array([np.dot(weights, obj) for obj in archive_objectives])\n\n    # Select the solution with the lowest score (best current solution)\n    best_idx = np.argmin(scores)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective aware perturbations\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt local search\n    for _ in range(10):  # Limit the number of iterations to prevent excessive computation\n        i, j = np.random.randint(0, n, size=2)\n        if i == j:\n            continue\n\n        # Ensure i < j for simplicity\n        if i > j:\n            i, j = j, i\n\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check if the new solution is better in at least one objective\n        old_cost1 = sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        old_cost2 = sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        old_cost3 = sum(distance_matrix_3[base_solution[k-1], base_solution[k]] for k in range(n))\n        new_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        # If the new solution is not better in at least one objective, revert\n        if (new_cost1 >= old_cost1 and new_cost2 >= old_cost2 and new_cost3 >= old_cost3):\n            new_solution = base_solution.copy()\n        else:\n            base_solution = new_solution.copy()\n\n    # Apply multi-objective aware perturbation\n    # Select a segment to perturb based on the worst objective\n    current_costs = [\n        sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k-1], base_solution[k]] for k in range(n))\n    ]\n\n    # Identify the worst objective (highest cost)\n    worst_obj_idx = np.argmax(current_costs)\n\n    # Perturb the solution to improve the worst objective\n    if worst_obj_idx == 0:\n        # For the first objective, perform a more aggressive 2-opt\n        for _ in range(5):\n            i, j = np.random.randint(0, n, size=2)\n            if i == j:\n                continue\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            if new_cost1 < current_costs[0]:\n                base_solution = new_solution.copy()\n                current_costs[0] = new_cost1\n            else:\n                new_solution = base_solution.copy()\n    elif worst_obj_idx == 1:\n        # For the second objective, perform a different local search operator\n        # Example: Insertion move\n        for _ in range(5):\n            i, j = np.random.randint(0, n, size=2)\n            if i == j:\n                continue\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n            new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            if new_cost2 < current_costs[1]:\n                base_solution = new_solution.copy()\n                current_costs[1] = new_cost2\n            else:\n                new_solution = base_solution.copy()\n    else:\n        # For the third objective, perform a swap move\n        for _ in range(5):\n            i, j = np.random.randint(0, n, size=2)\n            if i == j:\n                continue\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n            if new_cost3 < current_costs[2]:\n                base_solution = new_solution.copy()\n                current_costs[2] = new_cost3\n            else:\n                new_solution = base_solution.copy()\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 232,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        # Sort solutions by the sum of objectives to find those with higher values (potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 10% of solutions, or at least 1 if archive is small\n        top_candidates = archive_sorted[:max(1, len(archive) // 10)]\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = np.random.permutation(len(instance))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # 2-opt local search (standard for TSP)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: swap nodes that are \"similar\" in one objective but distant in another\n        if n > 2:\n            k, l = random.sample(range(n), 2)\n            obj1_diff = abs(distance_matrix_1[new_solution[k], new_solution[l]] - distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n            obj2_diff = abs(distance_matrix_2[new_solution[k], new_solution[l]] - distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n            obj3_diff = abs(distance_matrix_3[new_solution[k], new_solution[l]] - distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n            # Swap if it improves the balance across objectives\n            if (obj1_diff + obj2_diff + obj3_diff) > (random.random() * 100):  # Stochastic acceptance\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7274739154981915,
            1.180504286289215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        # Sort solutions by the sum of objectives to find those with higher values (potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 10% of solutions, or at least 1 if archive is small\n        top_candidates = archive_sorted[:max(1, len(archive) // 10)]\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = np.random.permutation(len(instance))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # 2-opt local search (standard for TSP)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: swap nodes that are \"similar\" in one objective but distant in another\n        if n > 2:\n            k, l = random.sample(range(n), 2)\n            obj1_diff = abs(distance_matrix_1[new_solution[k], new_solution[l]] - distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n            obj2_diff = abs(distance_matrix_2[new_solution[k], new_solution[l]] - distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n            obj3_diff = abs(distance_matrix_3[new_solution[k], new_solution[l]] - distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n            # Swap if it improves the balance across objectives\n            if (obj1_diff + obj2_diff + obj3_diff) > (random.random() * 100):  # Stochastic acceptance\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 233,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-aware swaps\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current objective values\n    current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n    current_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n    # Try to find a better swap based on the worst objective\n    worst_obj = np.argmax([current_cost1, current_cost2, current_cost3])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best possible swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for a in range(n):\n        for b in range(a + 1, n):\n            # Calculate the change in distance for this swap\n            old_dist = (dist_matrix[new_solution[a-1], new_solution[a]] +\n                        dist_matrix[new_solution[b-1], new_solution[b]])\n            new_dist = (dist_matrix[new_solution[a-1], new_solution[b]] +\n                        dist_matrix[new_solution[b-1], new_solution[a]])\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7704248541977782,
            2.100913166999817
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-aware swaps\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current objective values\n    current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n    current_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n    # Try to find a better swap based on the worst objective\n    worst_obj = np.argmax([current_cost1, current_cost2, current_cost3])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best possible swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for a in range(n):\n        for b in range(a + 1, n):\n            # Calculate the change in distance for this swap\n            old_dist = (dist_matrix[new_solution[a-1], new_solution[a]] +\n                        dist_matrix[new_solution[b-1], new_solution[b]])\n            new_dist = (dist_matrix[new_solution[a-1], new_solution[b]] +\n                        dist_matrix[new_solution[b-1], new_solution[a]])\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 234,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Determine which objective to prioritize for local search\n    obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights by default\n    obj_values = np.array(objectives)\n    priority_obj = np.argmin(obj_values / obj_weights)  # Prioritize the worst objective\n\n    # Select appropriate distance matrix based on priority\n    if priority_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif priority_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Hybrid local search operation\n    if np.random.random() < 0.7:  # 70% chance for 2-opt\n        # Select two random edges to swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for insertion\n        # Select a random node and insert it in a different position\n        i = np.random.randint(n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7848984256557218,
            0.9407211661338806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Determine which objective to prioritize for local search\n    obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights by default\n    obj_values = np.array(objectives)\n    priority_obj = np.argmin(obj_values / obj_weights)  # Prioritize the worst objective\n\n    # Select appropriate distance matrix based on priority\n    if priority_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif priority_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Hybrid local search operation\n    if np.random.random() < 0.7:  # 70% chance for 2-opt\n        # Select two random edges to swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for insertion\n        # Select a random node and insert it in a different position\n        i = np.random.randint(n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 235,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (potentially less dominated) for exploration\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the worst objective space\n    max_dist = -1\n    i, j = -1, -1\n    for idx in range(n):\n        node1 = new_solution[idx]\n        node2 = new_solution[(idx + 1) % n]\n        current_dist = dist_matrix[node1, node2]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            i, j = idx, (idx + 1) % n\n\n    # Perform 2-opt swap\n    if i != -1 and j != -1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then apply a random 2-opt to maintain diversity\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Verify solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7514125720894027,
            1.161311388015747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (potentially less dominated) for exploration\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the worst objective space\n    max_dist = -1\n    i, j = -1, -1\n    for idx in range(n):\n        node1 = new_solution[idx]\n        node2 = new_solution[(idx + 1) % n]\n        current_dist = dist_matrix[node1, node2]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            i, j = idx, (idx + 1) % n\n\n    # Perform 2-opt swap\n    if i != -1 and j != -1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then apply a random 2-opt to maintain diversity\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Verify solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 236,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high crowding distance or low dominance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # If no improvement found, apply a random 2-opt move to maintain diversity\n    if np.array_equal(new_solution, base_solution):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7638643865175567,
            1.0055970191955566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high crowding distance or low dominance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # If no improvement found, apply a random 2-opt move to maintain diversity\n    if np.array_equal(new_solution, base_solution):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 237,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (sum of all three objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_solution = random.choice(archive_sorted[:max(1, len(archive_sorted) // 3)])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with a bias towards the objective with the highest improvement potential\n    # 2. If no improvement, apply a 3-opt move\n    # 3. If still no improvement, apply a random swap\n\n    # Calculate current objectives\n    current_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    current_obj3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    improved = False\n\n    # 1. 2-opt with objective bias\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        new_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Check if at least one objective improved\n        if (new_obj1 < current_obj1 or new_obj2 < current_obj2 or new_obj3 < current_obj3):\n            current_obj1, current_obj2, current_obj3 = new_obj1, new_obj2, new_obj3\n            improved = True\n            break\n        else:\n            # Revert if no improvement\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if not improved:\n        # 2. 3-opt if 2-opt didn't improve\n        for _ in range(10):\n            i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n            # Apply 3-opt move (cycle reversal between i, j, k)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n            # Calculate new objectives\n            new_obj1 = sum(distance_matrix_1[new_solution[m], new_solution[m+1]] for m in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_obj2 = sum(distance_matrix_2[new_solution[m], new_solution[m+1]] for m in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            new_obj3 = sum(distance_matrix_3[new_solution[m], new_solution[m+1]] for m in range(len(new_solution)-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            if (new_obj1 < current_obj1 or new_obj2 < current_obj2 or new_obj3 < current_obj3):\n                current_obj1, current_obj2, current_obj3 = new_obj1, new_obj2, new_obj3\n                improved = True\n                break\n            else:\n                # Revert if no improvement\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if not improved:\n        # 3. Random swap if no improvement\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6537701633651707,
            1.2146002769470214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (sum of all three objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_solution = random.choice(archive_sorted[:max(1, len(archive_sorted) // 3)])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with a bias towards the objective with the highest improvement potential\n    # 2. If no improvement, apply a 3-opt move\n    # 3. If still no improvement, apply a random swap\n\n    # Calculate current objectives\n    current_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    current_obj3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    improved = False\n\n    # 1. 2-opt with objective bias\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        new_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Check if at least one objective improved\n        if (new_obj1 < current_obj1 or new_obj2 < current_obj2 or new_obj3 < current_obj3):\n            current_obj1, current_obj2, current_obj3 = new_obj1, new_obj2, new_obj3\n            improved = True\n            break\n        else:\n            # Revert if no improvement\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if not improved:\n        # 2. 3-opt if 2-opt didn't improve\n        for _ in range(10):\n            i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n            # Apply 3-opt move (cycle reversal between i, j, k)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n            # Calculate new objectives\n            new_obj1 = sum(distance_matrix_1[new_solution[m], new_solution[m+1]] for m in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_obj2 = sum(distance_matrix_2[new_solution[m], new_solution[m+1]] for m in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            new_obj3 = sum(distance_matrix_3[new_solution[m], new_solution[m+1]] for m in range(len(new_solution)-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            if (new_obj1 < current_obj1 or new_obj2 < current_obj2 or new_obj3 < current_obj3):\n                current_obj1, current_obj2, current_obj3 = new_obj1, new_obj2, new_obj3\n                improved = True\n                break\n            else:\n                # Revert if no improvement\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if not improved:\n        # 3. Random swap if no improvement\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 238,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and 3-opt moves\n    # with a focus on improving the worst-performing objective\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move (swap edges)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply 3-opt move (rearrange three edges)\n    if n >= 3:\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n        k = sorted([i, j, k])[1]\n\n        # Rearrange the segment between i and k\n        segment = new_solution[i:k]\n        if len(segment) > 1:\n            new_solution[i:k] = np.roll(segment, shift=np.random.randint(1, len(segment)))\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7236067307590229,
            1.0663059115409852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and 3-opt moves\n    # with a focus on improving the worst-performing objective\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move (swap edges)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply 3-opt move (rearrange three edges)\n    if n >= 3:\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n        k = sorted([i, j, k])[1]\n\n        # Rearrange the segment between i and k\n        segment = new_solution[i:k]\n        if len(segment) > 1:\n            new_solution[i:k] = np.roll(segment, shift=np.random.randint(1, len(segment)))\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 239,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 or all if archive is small\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # 1. Random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Edge insertion move\n    k = random.randint(0, n-1)\n    l = random.randint(0, n-1)\n    if k != l:\n        new_node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, new_node)\n\n    # 3. Multi-objective edge swap (novel operation)\n    # Find edges with high potential for improvement across all three objectives\n    for _ in range(2):  # Perform 2 swaps\n        # Select random edges\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                        distance_matrix_2[new_solution[a], new_solution[b]] +\n                        distance_matrix_3[new_solution[a], new_solution[b]] +\n                        distance_matrix_1[new_solution[c], new_solution[d]] +\n                        distance_matrix_2[new_solution[c], new_solution[d]] +\n                        distance_matrix_3[new_solution[c], new_solution[d]])\n\n        potential_cost = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                          distance_matrix_2[new_solution[a], new_solution[c]] +\n                          distance_matrix_3[new_solution[a], new_solution[c]] +\n                          distance_matrix_1[new_solution[b], new_solution[d]] +\n                          distance_matrix_2[new_solution[b], new_solution[d]] +\n                          distance_matrix_3[new_solution[b], new_solution[d]])\n\n        if potential_cost < current_cost:\n            # Perform the swap\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.8205542310894318,
            0.9309494137763977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 or all if archive is small\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # 1. Random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Edge insertion move\n    k = random.randint(0, n-1)\n    l = random.randint(0, n-1)\n    if k != l:\n        new_node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, new_node)\n\n    # 3. Multi-objective edge swap (novel operation)\n    # Find edges with high potential for improvement across all three objectives\n    for _ in range(2):  # Perform 2 swaps\n        # Select random edges\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                        distance_matrix_2[new_solution[a], new_solution[b]] +\n                        distance_matrix_3[new_solution[a], new_solution[b]] +\n                        distance_matrix_1[new_solution[c], new_solution[d]] +\n                        distance_matrix_2[new_solution[c], new_solution[d]] +\n                        distance_matrix_3[new_solution[c], new_solution[d]])\n\n        potential_cost = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                          distance_matrix_2[new_solution[a], new_solution[c]] +\n                          distance_matrix_3[new_solution[a], new_solution[c]] +\n                          distance_matrix_1[new_solution[b], new_solution[d]] +\n                          distance_matrix_2[new_solution[b], new_solution[d]] +\n                          distance_matrix_3[new_solution[b], new_solution[d]])\n\n        if potential_cost < current_cost:\n            # Perform the swap\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 240,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the most critical objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 > obj2 and obj1 > obj3:\n        # Improve first objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif obj2 > obj1 and obj2 > obj3:\n        # Improve second objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Improve third objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform an objective-aware swap\n    if np.random.random() < 0.5:\n        # Swap nodes that are far in all objectives\n        i, j = np.random.choice(n, 2, replace=False)\n        total_dist = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[j]])\n        if total_dist > (distance_matrix_1[new_solution[i], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[i]] +\n                         distance_matrix_3[new_solution[i], new_solution[i]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Swap nodes that are close in all objectives\n        i, j = np.random.choice(n, 2, replace=False)\n        total_dist = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[j]])\n        if total_dist < (distance_matrix_1[new_solution[i], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[i]] +\n                         distance_matrix_3[new_solution[i], new_solution[i]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7297532333357352,
            1.157060182094574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the most critical objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 > obj2 and obj1 > obj3:\n        # Improve first objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif obj2 > obj1 and obj2 > obj3:\n        # Improve second objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Improve third objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform an objective-aware swap\n    if np.random.random() < 0.5:\n        # Swap nodes that are far in all objectives\n        i, j = np.random.choice(n, 2, replace=False)\n        total_dist = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[j]])\n        if total_dist > (distance_matrix_1[new_solution[i], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[i]] +\n                         distance_matrix_3[new_solution[i], new_solution[i]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Swap nodes that are close in all objectives\n        i, j = np.random.choice(n, 2, replace=False)\n        total_dist = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[j]])\n        if total_dist < (distance_matrix_1[new_solution[i], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[i]] +\n                         distance_matrix_3[new_solution[i], new_solution[i]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 241,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected = random.choices(\n        archive,\n        weights=[1 / (sum(obj) + 1e-6) for _, obj in archive],  # Prefer solutions with lower total cost\n        k=1\n    )[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate edge improvement across all three objectives\n    current_cost = (\n        distance_matrix_1[new_solution[i-1], new_solution[i]] +\n        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n    )\n\n    new_cost = (\n        distance_matrix_1[new_solution[i-1], new_solution[j]] +\n        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n        distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n    )\n\n    # Apply 2-opt if it improves at least one objective\n    if new_cost < current_cost:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # If no improvement, try a different operator: swap two nodes\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7709503526219982,
            1.1608820796012878
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected = random.choices(\n        archive,\n        weights=[1 / (sum(obj) + 1e-6) for _, obj in archive],  # Prefer solutions with lower total cost\n        k=1\n    )[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate edge improvement across all three objectives\n    current_cost = (\n        distance_matrix_1[new_solution[i-1], new_solution[i]] +\n        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n    )\n\n    new_cost = (\n        distance_matrix_1[new_solution[i-1], new_solution[j]] +\n        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n        distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n    )\n\n    # Apply 2-opt if it improves at least one objective\n    if new_cost < current_cost:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # If no improvement, try a different operator: swap two nodes\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 242,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = np.array([np.sum(obj) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-aware edge swapping\n    for _ in range(2):  # Try a few swaps\n        # Calculate edge costs in all three objectives\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        # Find the most \"imbalanced\" edge (where objectives differ significantly)\n        max_diff = -1\n        best_pair = None\n        for k in range(n):\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            costs = edge_cost(a, b)\n            diff = max(costs) - min(costs)\n            if diff > max_diff:\n                max_diff = diff\n                best_pair = (k, (k+1)%n)\n\n        if best_pair:\n            k, l = best_pair\n            # Try to swap with a node that would balance the objectives\n            candidates = list(range(n))\n            random.shuffle(candidates)\n            for m in candidates:\n                if m == k or m == (k+1)%n or m == (k-1)%n or m == (l+1)%n:\n                    continue\n\n                # Calculate potential new edges\n                old_edges = [edge_cost(new_solution[k], new_solution[l]),\n                            edge_cost(new_solution[(k-1)%n], new_solution[k]),\n                            edge_cost(new_solution[l], new_solution[(l+1)%n])]\n\n                new_edges = [edge_cost(new_solution[(k-1)%n], new_solution[m]),\n                            edge_cost(new_solution[m], new_solution[l]),\n                            edge_cost(new_solution[k], new_solution[(l+1)%n])]\n\n                # Check if the swap improves the balance of objectives\n                old_diff = sum(max(costs) - min(costs) for costs in old_edges)\n                new_diff = sum(max(costs) - min(costs) for costs in new_edges)\n\n                if new_diff < old_diff:\n                    # Perform the swap\n                    if k < l:\n                        new_solution[k+1:l] = new_solution[k:l-1][::-1]\n                    else:\n                        new_solution[l+1:k] = new_solution[l:k-1][::-1]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7443742688065187,
            2.6529550790786742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = np.array([np.sum(obj) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-aware edge swapping\n    for _ in range(2):  # Try a few swaps\n        # Calculate edge costs in all three objectives\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        # Find the most \"imbalanced\" edge (where objectives differ significantly)\n        max_diff = -1\n        best_pair = None\n        for k in range(n):\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            costs = edge_cost(a, b)\n            diff = max(costs) - min(costs)\n            if diff > max_diff:\n                max_diff = diff\n                best_pair = (k, (k+1)%n)\n\n        if best_pair:\n            k, l = best_pair\n            # Try to swap with a node that would balance the objectives\n            candidates = list(range(n))\n            random.shuffle(candidates)\n            for m in candidates:\n                if m == k or m == (k+1)%n or m == (k-1)%n or m == (l+1)%n:\n                    continue\n\n                # Calculate potential new edges\n                old_edges = [edge_cost(new_solution[k], new_solution[l]),\n                            edge_cost(new_solution[(k-1)%n], new_solution[k]),\n                            edge_cost(new_solution[l], new_solution[(l+1)%n])]\n\n                new_edges = [edge_cost(new_solution[(k-1)%n], new_solution[m]),\n                            edge_cost(new_solution[m], new_solution[l]),\n                            edge_cost(new_solution[k], new_solution[(l+1)%n])]\n\n                # Check if the swap improves the balance of objectives\n                old_diff = sum(max(costs) - min(costs) for costs in old_edges)\n                new_diff = sum(max(costs) - min(costs) for costs in new_edges)\n\n                if new_diff < old_diff:\n                    # Perform the swap\n                    if k < l:\n                        new_solution[k+1:l] = new_solution[k:l-1][::-1]\n                    else:\n                        new_solution[l+1:k] = new_solution[l:k-1][::-1]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 243,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n    variance = normalized_objectives.var(axis=1)\n    probabilities = variance / variance.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # 2-opt move (standard local search)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure valid segment\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware swap: identify worst segments in any objective space\n        for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            # Find the segment with highest cost in this objective\n            costs = [distance_matrix[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]\n            worst_idx = np.argmax(costs)\n            # Swap with a random node to improve this segment\n            swap_candidate = random.randint(0, n-1)\n            if swap_candidate != worst_idx and swap_candidate != (worst_idx+1)%n:\n                new_solution[worst_idx], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[worst_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7459685311729791,
            2.390706217288971
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n    variance = normalized_objectives.var(axis=1)\n    probabilities = variance / variance.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # 2-opt move (standard local search)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure valid segment\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware swap: identify worst segments in any objective space\n        for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            # Find the segment with highest cost in this objective\n            costs = [distance_matrix[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]\n            worst_idx = np.argmax(costs)\n            # Swap with a random node to improve this segment\n            swap_candidate = random.randint(0, n-1)\n            if swap_candidate != worst_idx and swap_candidate != (worst_idx+1)%n:\n                new_solution[worst_idx], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[worst_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 244,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Calculate diversity scores based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity_scores = np.sum(np.abs(objectives - mean_obj), axis=1)\n\n    # Select a solution with high diversity (potential for improvement)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or 3-opt based on objective diversity\n    if random.random() < 0.7:  # Higher chance for 2-opt\n        # 2-opt with objective-aware edge selection\n        i, j = sorted(random.sample(range(n), 2))\n        # Evaluate the move in all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[j-1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j-1]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j-1]]\n        )\n\n        # Apply if it improves at least one objective\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt with objective-aware edge selection\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Evaluate all possible 3-opt moves and choose the best one\n        best_move = None\n        best_improvement = 0\n\n        # There are 8 possible 3-opt moves (4! / 2 = 8 for circular permutations)\n        # We'll evaluate all of them\n        for move in range(8):\n            temp_solution = new_solution.copy()\n            if move == 0:\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n            elif move == 1:\n                temp_solution[j:k] = temp_solution[j:k][::-1]\n            elif move == 2:\n                temp_solution[i:k] = temp_solution[i:k][::-1]\n            elif move == 3:\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n                temp_solution[j:k] = temp_solution[j:k][::-1]\n            elif move == 4:\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n                temp_solution[i:k] = temp_solution[i:k][::-1]\n            elif move == 5:\n                temp_solution[j:k] = temp_solution[j:k][::-1]\n                temp_solution[i:k] = temp_solution[i:k][::-1]\n            elif move == 6:\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n                temp_solution[j:k] = temp_solution[j:k][::-1]\n                temp_solution[i:k] = temp_solution[i:k][::-1]\n            elif move == 7:\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n                temp_solution[j:k] = temp_solution[j:k][::-1]\n                temp_solution[i:k] = temp_solution[i:k][::-1]\n\n            # Calculate improvement across all three objectives\n            current_cost = (\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                distance_matrix_3[new_solution[k-1], new_solution[k]]\n            )\n            new_cost = (\n                distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_1[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_1[temp_solution[k-1], temp_solution[k]] +\n                distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_2[temp_solution[k-1], temp_solution[k]] +\n                distance_matrix_3[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_3[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_3[temp_solution[k-1], temp_solution[k]]\n            )\n\n            improvement = current_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = move\n\n        # Apply the best move if it improves at least one objective\n        if best_move is not None and best_improvement > 0:\n            if best_move == 0:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            elif best_move == 1:\n                new_solution[j:k] = new_solution[j:k][::-1]\n            elif best_move == 2:\n                new_solution[i:k] = new_solution[i:k][::-1]\n            elif best_move == 3:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n            elif best_move == 4:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[i:k] = new_solution[i:k][::-1]\n            elif best_move == 5:\n                new_solution[j:k] = new_solution[j:k][::-1]\n                new_solution[i:k] = new_solution[i:k][::-1]\n            elif best_move == 6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n                new_solution[i:k] = new_solution[i:k][::-1]\n            elif best_move == 7:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n                new_solution[i:k] = new_solution[i:k][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.4995607295252468,
            1.5162479996681213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Calculate diversity scores based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity_scores = np.sum(np.abs(objectives - mean_obj), axis=1)\n\n    # Select a solution with high diversity (potential for improvement)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or 3-opt based on objective diversity\n    if random.random() < 0.7:  # Higher chance for 2-opt\n        # 2-opt with objective-aware edge selection\n        i, j = sorted(random.sample(range(n), 2))\n        # Evaluate the move in all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[j-1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j-1]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j-1]]\n        )\n\n        # Apply if it improves at least one objective\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt with objective-aware edge selection\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Evaluate all possible 3-opt moves and choose the best one\n        best_move = None\n        best_improvement = 0\n\n        # There are 8 possible 3-opt moves (4! / 2 = 8 for circular permutations)\n        # We'll evaluate all of them\n        for move in range(8):\n            temp_solution = new_solution.copy()\n            if move == 0:\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n            elif move == 1:\n                temp_solution[j:k] = temp_solution[j:k][::-1]\n            elif move == 2:\n                temp_solution[i:k] = temp_solution[i:k][::-1]\n            elif move == 3:\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n                temp_solution[j:k] = temp_solution[j:k][::-1]\n            elif move == 4:\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n                temp_solution[i:k] = temp_solution[i:k][::-1]\n            elif move == 5:\n                temp_solution[j:k] = temp_solution[j:k][::-1]\n                temp_solution[i:k] = temp_solution[i:k][::-1]\n            elif move == 6:\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n                temp_solution[j:k] = temp_solution[j:k][::-1]\n                temp_solution[i:k] = temp_solution[i:k][::-1]\n            elif move == 7:\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n                temp_solution[j:k] = temp_solution[j:k][::-1]\n                temp_solution[i:k] = temp_solution[i:k][::-1]\n\n            # Calculate improvement across all three objectives\n            current_cost = (\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                distance_matrix_3[new_solution[k-1], new_solution[k]]\n            )\n            new_cost = (\n                distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_1[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_1[temp_solution[k-1], temp_solution[k]] +\n                distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_2[temp_solution[k-1], temp_solution[k]] +\n                distance_matrix_3[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_3[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_3[temp_solution[k-1], temp_solution[k]]\n            )\n\n            improvement = current_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = move\n\n        # Apply the best move if it improves at least one objective\n        if best_move is not None and best_improvement > 0:\n            if best_move == 0:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            elif best_move == 1:\n                new_solution[j:k] = new_solution[j:k][::-1]\n            elif best_move == 2:\n                new_solution[i:k] = new_solution[i:k][::-1]\n            elif best_move == 3:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n            elif best_move == 4:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[i:k] = new_solution[i:k][::-1]\n            elif best_move == 5:\n                new_solution[j:k] = new_solution[j:k][::-1]\n                new_solution[i:k] = new_solution[i:k][::-1]\n            elif best_move == 6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n                new_solution[i:k] = new_solution[i:k][::-1]\n            elif best_move == 7:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[j:k] = new_solution[j:k][::-1]\n                new_solution[i:k] = new_solution[i:k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 245,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (here, we select the one with the highest total cost across objectives)\n    archive.sort(key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 2-opt\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    # Randomly select a node to reinsert (node insertion)\n    if n > 2:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5768626372453851,
            0.736299741268158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (here, we select the one with the highest total cost across objectives)\n    archive.sort(key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 2-opt\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    # Randomly select a node to reinsert (node insertion)\n    if n > 2:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 246,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple swaps for better exploration\n        # Select two distinct edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt swap\n        new_solution[i:j] = base_solution[i:j][::-1]\n        new_solution[k:l] = base_solution[k:l][::-1]\n\n        # Evaluate the new solution's potential improvement\n        current_cost = (\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        )\n\n        # If the new solution is worse, revert to original\n        if current_cost > archive[selected_idx][1]:\n            new_solution = base_solution.copy()\n\n    # Additional objective-aware edge swap\n    for _ in range(5):\n        # Select two nodes to swap based on their positions in different objective spaces\n        a, b = random.sample(range(n), 2)\n\n        # Calculate potential improvement in all objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7113101403550287,
            1.64388587474823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple swaps for better exploration\n        # Select two distinct edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt swap\n        new_solution[i:j] = base_solution[i:j][::-1]\n        new_solution[k:l] = base_solution[k:l][::-1]\n\n        # Evaluate the new solution's potential improvement\n        current_cost = (\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        )\n\n        # If the new solution is worse, revert to original\n        if current_cost > archive[selected_idx][1]:\n            new_solution = base_solution.copy()\n\n    # Additional objective-aware edge swap\n    for _ in range(5):\n        # Select two nodes to swap based on their positions in different objective spaces\n        a, b = random.sample(range(n), 2)\n\n        # Calculate potential improvement in all objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 247,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with better diversity or lower objective values)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1] + obj[2]) for (sol, obj) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Choose one of three local search strategies with equal probability\n    strategy = random.choice(['2opt', 'node_swap', 'multi_obj_perturb'])\n\n    if strategy == '2opt':\n        # Perform 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif strategy == 'node_swap':\n        # Perform node swap between two random positions\n        i, j = random.sample(range(n), 2)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # multi_obj_perturb\n        # Multi-objective-aware perturbation: select a segment and reverse it based on the objective with worst performance\n        obj = archive[selected_idx][1]\n        worst_obj = np.argmax(obj)  # 0, 1, or 2 for the three objectives\n\n        # Choose a segment to reverse based on the worst objective's distance matrix\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst segment in the current solution based on the selected distance matrix\n        worst_segment = None\n        worst_segment_cost = -float('inf')\n        for i in range(n-1):\n            current_cost = dist_matrix[base_solution[i], base_solution[i+1]]\n            if current_cost > worst_segment_cost:\n                worst_segment_cost = current_cost\n                worst_segment = (i, i+1)\n\n        if worst_segment:\n            i, j = worst_segment\n            new_solution = base_solution.copy()\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Fallback to simple 2-opt if no segment found\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution = base_solution.copy()\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7664968712490223,
            1.1923885107040406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with better diversity or lower objective values)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1] + obj[2]) for (sol, obj) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Choose one of three local search strategies with equal probability\n    strategy = random.choice(['2opt', 'node_swap', 'multi_obj_perturb'])\n\n    if strategy == '2opt':\n        # Perform 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif strategy == 'node_swap':\n        # Perform node swap between two random positions\n        i, j = random.sample(range(n), 2)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # multi_obj_perturb\n        # Multi-objective-aware perturbation: select a segment and reverse it based on the objective with worst performance\n        obj = archive[selected_idx][1]\n        worst_obj = np.argmax(obj)  # 0, 1, or 2 for the three objectives\n\n        # Choose a segment to reverse based on the worst objective's distance matrix\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst segment in the current solution based on the selected distance matrix\n        worst_segment = None\n        worst_segment_cost = -float('inf')\n        for i in range(n-1):\n            current_cost = dist_matrix[base_solution[i], base_solution[i+1]]\n            if current_cost > worst_segment_cost:\n                worst_segment_cost = current_cost\n                worst_segment = (i, i+1)\n\n        if worst_segment:\n            i, j = worst_segment\n            new_solution = base_solution.copy()\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Fallback to simple 2-opt if no segment found\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution = base_solution.copy()\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 248,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement using a heuristic\n    def potential_score(solution, objectives):\n        # Calculate the total distance for each objective\n        dist1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(len(solution)-1))\n        dist1 += distance_matrix_1[solution[-1], solution[0]]  # Close the loop\n        dist2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(len(solution)-1))\n        dist2 += distance_matrix_2[solution[-1], solution[0]]\n        dist3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(len(solution)-1))\n        dist3 += distance_matrix_3[solution[-1], solution[0]]\n\n        # Calculate the potential improvement score (inverse of current distance)\n        score = 1.0 / (dist1 + dist2 + dist3)\n        return score\n\n    # Sort solutions by potential improvement score (descending)\n    archive_sorted = sorted(archive, key=lambda x: potential_score(x[0], x[1]), reverse=True)\n\n    # Select the top 10% of solutions with highest potential\n    top_k = max(1, len(archive_sorted) // 10)\n    candidates = archive_sorted[:top_k]\n\n    # Randomly select a candidate solution\n    selected = random.choice(candidates)[0].copy()\n\n    # Apply a hybrid local search operator\n    def hybrid_local_search(solution):\n        new_solution = solution.copy()\n        n = len(new_solution)\n\n        # Apply a combination of 2-opt and node insertion\n        for _ in range(10):  # Number of local search iterations\n            # Randomly select two distinct edges to swap (2-opt)\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                new_solution[i+1:j] = new_solution[j-1:i:-1]\n\n            # Randomly select a node and insert it elsewhere (node insertion)\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected)\n\n    return new_solution\n\n",
        "score": [
            -0.6968648978990062,
            3.285190761089325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement using a heuristic\n    def potential_score(solution, objectives):\n        # Calculate the total distance for each objective\n        dist1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(len(solution)-1))\n        dist1 += distance_matrix_1[solution[-1], solution[0]]  # Close the loop\n        dist2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(len(solution)-1))\n        dist2 += distance_matrix_2[solution[-1], solution[0]]\n        dist3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(len(solution)-1))\n        dist3 += distance_matrix_3[solution[-1], solution[0]]\n\n        # Calculate the potential improvement score (inverse of current distance)\n        score = 1.0 / (dist1 + dist2 + dist3)\n        return score\n\n    # Sort solutions by potential improvement score (descending)\n    archive_sorted = sorted(archive, key=lambda x: potential_score(x[0], x[1]), reverse=True)\n\n    # Select the top 10% of solutions with highest potential\n    top_k = max(1, len(archive_sorted) // 10)\n    candidates = archive_sorted[:top_k]\n\n    # Randomly select a candidate solution\n    selected = random.choice(candidates)[0].copy()\n\n    # Apply a hybrid local search operator\n    def hybrid_local_search(solution):\n        new_solution = solution.copy()\n        n = len(new_solution)\n\n        # Apply a combination of 2-opt and node insertion\n        for _ in range(10):  # Number of local search iterations\n            # Randomly select two distinct edges to swap (2-opt)\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                new_solution[i+1:j] = new_solution[j-1:i:-1]\n\n            # Randomly select a node and insert it elsewhere (node insertion)\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 249,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., random selection weighted by objective diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware segment selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Step 1: Select a segment to modify based on objective diversity\n    segment_length = min(4, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Step 2: Calculate segment costs in all three objectives\n    segment_costs = [\n        sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))) +\n        distance_matrix_1[segment[-1], segment[0]],\n        sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))) +\n        distance_matrix_2[segment[-1], segment[0]],\n        sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(1, len(segment))) +\n        distance_matrix_3[segment[-1], segment[0]]\n    ]\n\n    # Step 3: Apply 2-opt or 3-opt based on which objective has higher segment cost\n    if segment_length == 4:\n        # 3-opt: reverse the middle two nodes\n        segment[1:3] = segment[2:0:-1]\n    else:\n        # 2-opt: reverse the segment\n        segment = segment[::-1]\n\n    new_solution[start:start+segment_length] = segment\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7058556488211373,
            1.3788821697235107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., random selection weighted by objective diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware segment selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Step 1: Select a segment to modify based on objective diversity\n    segment_length = min(4, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Step 2: Calculate segment costs in all three objectives\n    segment_costs = [\n        sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))) +\n        distance_matrix_1[segment[-1], segment[0]],\n        sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))) +\n        distance_matrix_2[segment[-1], segment[0]],\n        sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(1, len(segment))) +\n        distance_matrix_3[segment[-1], segment[0]]\n    ]\n\n    # Step 3: Apply 2-opt or 3-opt based on which objective has higher segment cost\n    if segment_length == 4:\n        # 3-opt: reverse the middle two nodes\n        segment[1:3] = segment[2:0:-1]\n    else:\n        # 2-opt: reverse the segment\n        segment = segment[::-1]\n\n    new_solution[start:start+segment_length] = segment\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 250,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for _, obj in archive]\n    objectives = np.array(objectives)\n    obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n\n    # Prefer solutions that are not too close to the current Pareto front\n    diversity_scores = np.sum((objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-specific edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve the worst objective\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Evaluate the current and reversed segment\n        current_segment = new_solution[i:j+1]\n        reversed_segment = current_segment[::-1]\n\n        # Calculate objective improvements\n        if worst_obj == 0:\n            current_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            reversed_cost = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n        elif worst_obj == 1:\n            current_cost = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            reversed_cost = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n        else:\n            current_cost = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            reversed_cost = sum(distance_matrix_3[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n\n        if reversed_cost < current_cost:\n            new_solution[i:j+1] = reversed_segment\n\n    # Then apply edge swaps based on all objectives\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate improvement across all objectives\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i], new_solution[i+1]])\n\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j], new_solution[i+1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6318662013081655,
            1.2075341939926147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for _, obj in archive]\n    objectives = np.array(objectives)\n    obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n\n    # Prefer solutions that are not too close to the current Pareto front\n    diversity_scores = np.sum((objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-specific edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve the worst objective\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Evaluate the current and reversed segment\n        current_segment = new_solution[i:j+1]\n        reversed_segment = current_segment[::-1]\n\n        # Calculate objective improvements\n        if worst_obj == 0:\n            current_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            reversed_cost = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n        elif worst_obj == 1:\n            current_cost = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            reversed_cost = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n        else:\n            current_cost = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            reversed_cost = sum(distance_matrix_3[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n\n        if reversed_cost < current_cost:\n            new_solution[i:j+1] = reversed_segment\n\n    # Then apply edge swaps based on all objectives\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate improvement across all objectives\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i], new_solution[i+1]])\n\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j], new_solution[i+1]])\n\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 251,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized sum of objectives for each solution\n    normalized_objectives = np.array(archive_objectives)\n    min_obj = np.min(normalized_objectives, axis=0)\n    max_obj = np.max(normalized_objectives, axis=0)\n    normalized_objectives = (normalized_objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    obj_scores = np.sum(normalized_objectives, axis=1)\n\n    # Select the solution with the lowest score (best overall performance)\n    selected_idx = np.argmin(obj_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve multiple objectives\n    # Calculate the current objective values\n    current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Find the worst objective to improve\n    worst_obj = np.argmax([current_obj1, current_obj2, current_obj3])\n\n    # Perform a swap that improves the worst objective\n    for _ in range(10):  # Try up to 10 random swaps\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new objective values\n        new_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj3 = sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Check if the swap improves the worst objective\n        if worst_obj == 0 and new_obj1 < current_obj1:\n            new_solution = temp_solution\n            break\n        elif worst_obj == 1 and new_obj2 < current_obj2:\n            new_solution = temp_solution\n            break\n        elif worst_obj == 2 and new_obj3 < current_obj3:\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6440853248783057,
            1.1090905785560607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized sum of objectives for each solution\n    normalized_objectives = np.array(archive_objectives)\n    min_obj = np.min(normalized_objectives, axis=0)\n    max_obj = np.max(normalized_objectives, axis=0)\n    normalized_objectives = (normalized_objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    obj_scores = np.sum(normalized_objectives, axis=1)\n\n    # Select the solution with the lowest score (best overall performance)\n    selected_idx = np.argmin(obj_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve multiple objectives\n    # Calculate the current objective values\n    current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Find the worst objective to improve\n    worst_obj = np.argmax([current_obj1, current_obj2, current_obj3])\n\n    # Perform a swap that improves the worst objective\n    for _ in range(10):  # Try up to 10 random swaps\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new objective values\n        new_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj3 = sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Check if the swap improves the worst objective\n        if worst_obj == 0 and new_obj1 < current_obj1:\n            new_solution = temp_solution\n            break\n        elif worst_obj == 1 and new_obj2 < current_obj2:\n            new_solution = temp_solution\n            break\n        elif worst_obj == 2 and new_obj3 < current_obj3:\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 252,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives (using a simple weighted sum)\n    weights = [0.3, 0.3, 0.4]  # Adjust weights based on problem-specific importance\n    archive_with_scores = [(sol, obj, sum(w * o for w, o in zip(weights, obj))) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: x[2])\n    selected_sol = archive_with_scores[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = selected_sol.copy()\n\n    # Choose between 2-opt or 3-opt with probability\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt local search (more disruptive)\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n\n    # Ensure the solution remains a valid tour\n    if not (len(np.unique(new_solution)) == len(new_solution) and len(new_solution) == len(selected_sol)):\n        # Fallback to simple swap if the tour is invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5262498760762017,
            1.8144314646720887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives (using a simple weighted sum)\n    weights = [0.3, 0.3, 0.4]  # Adjust weights based on problem-specific importance\n    archive_with_scores = [(sol, obj, sum(w * o for w, o in zip(weights, obj))) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: x[2])\n    selected_sol = archive_with_scores[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = selected_sol.copy()\n\n    # Choose between 2-opt or 3-opt with probability\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt local search (more disruptive)\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n\n    # Ensure the solution remains a valid tour\n    if not (len(np.unique(new_solution)) == len(new_solution) and len(new_solution) == len(selected_sol)):\n        # Fallback to simple swap if the tour is invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 253,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective diversity (standard deviation across objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    diversity = np.std(objectives, axis=0)\n    weighted_diversity = np.sum(diversity)\n\n    # Select solutions with high diversity and sort by worst objective (potential for improvement)\n    candidates = []\n    for sol, obj in archive:\n        worst_obj = max(obj)\n        candidates.append((sol, worst_obj, weighted_diversity))\n\n    # Sort by worst objective (ascending) and then by diversity (descending)\n    candidates.sort(key=lambda x: (x[1], -x[2]))\n    selected_solution = candidates[0][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and random swap with objective-aware selection\n    if n < 4:\n        # For small instances, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, use a combination of 2-opt and random swap\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # Select a segment to reverse (2-opt)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Select a random swap with objective-aware consideration\n            # Calculate the potential improvement for each possible swap\n            improvements = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    # Calculate the change in all three objectives\n                    delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                    delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                    delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                    # Combine the improvements (could use weighted sum or other aggregation)\n                    total_improvement = delta_obj1 + delta_obj2 + delta_obj3\n                    improvements.append((total_improvement, i, j))\n\n            # Sort by improvement and select the top 10% candidates\n            improvements.sort(key=lambda x: x[0])\n            num_candidates = max(1, len(improvements) // 10)\n            candidates = improvements[:num_candidates]\n\n            if candidates:\n                # Select a candidate with probability proportional to its improvement\n                improvements = [abs(x[0]) for x in candidates]\n                total_improvement = sum(improvements)\n                if total_improvement > 0:\n                    probs = [x/total_improvement for x in improvements]\n                    selected = random.choices(candidates, weights=probs, k=1)[0]\n                    i, j = selected[1], selected[2]\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    assert len(new_solution) == len(np.unique(new_solution))\n    assert len(new_solution) == len(instance)\n\n    return new_solution\n\n",
        "score": [
            -0.7765977066791352,
            2.1864169955253603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective diversity (standard deviation across objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    diversity = np.std(objectives, axis=0)\n    weighted_diversity = np.sum(diversity)\n\n    # Select solutions with high diversity and sort by worst objective (potential for improvement)\n    candidates = []\n    for sol, obj in archive:\n        worst_obj = max(obj)\n        candidates.append((sol, worst_obj, weighted_diversity))\n\n    # Sort by worst objective (ascending) and then by diversity (descending)\n    candidates.sort(key=lambda x: (x[1], -x[2]))\n    selected_solution = candidates[0][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and random swap with objective-aware selection\n    if n < 4:\n        # For small instances, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, use a combination of 2-opt and random swap\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # Select a segment to reverse (2-opt)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Select a random swap with objective-aware consideration\n            # Calculate the potential improvement for each possible swap\n            improvements = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    # Calculate the change in all three objectives\n                    delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                    delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                    delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                    # Combine the improvements (could use weighted sum or other aggregation)\n                    total_improvement = delta_obj1 + delta_obj2 + delta_obj3\n                    improvements.append((total_improvement, i, j))\n\n            # Sort by improvement and select the top 10% candidates\n            improvements.sort(key=lambda x: x[0])\n            num_candidates = max(1, len(improvements) // 10)\n            candidates = improvements[:num_candidates]\n\n            if candidates:\n                # Select a candidate with probability proportional to its improvement\n                improvements = [abs(x[0]) for x in candidates]\n                total_improvement = sum(improvements)\n                if total_improvement > 0:\n                    probs = [x/total_improvement for x in improvements]\n                    selected = random.choices(candidates, weights=probs, k=1)[0]\n                    i, j = selected[1], selected[2]\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    assert len(new_solution) == len(np.unique(new_solution))\n    assert len(new_solution) == len(instance)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 254,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of 2-opt and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose between 2-opt and insertion\n    if np.random.rand() < 0.5:\n        # 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insertion move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.5997694660100338,
            0.42228151559829713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of 2-opt and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose between 2-opt and insertion\n    if np.random.rand() < 0.5:\n        # 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insertion move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 255,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Select two distinct edges to potentially reverse\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the change in all three objectives\n        # Original edges: (i-1, i) and (j, j+1)\n        # New edges: (i-1, j) and (i, j+1)\n        i_prev = (i - 1) % n\n        j_next = (j + 1) % n\n\n        # Calculate objective changes\n        delta_obj1 = (distance_matrix_1[new_solution[i_prev], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[j_next]]) - \\\n                     (distance_matrix_1[new_solution[i_prev], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[j_next]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i_prev], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[j_next]]) - \\\n                     (distance_matrix_2[new_solution[i_prev], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[j_next]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i_prev], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[j_next]]) - \\\n                     (distance_matrix_3[new_solution[i_prev], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[j_next]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.716618888957713,
            0.7996338367462158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Select two distinct edges to potentially reverse\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the change in all three objectives\n        # Original edges: (i-1, i) and (j, j+1)\n        # New edges: (i-1, j) and (i, j+1)\n        i_prev = (i - 1) % n\n        j_next = (j + 1) % n\n\n        # Calculate objective changes\n        delta_obj1 = (distance_matrix_1[new_solution[i_prev], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[j_next]]) - \\\n                     (distance_matrix_1[new_solution[i_prev], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[j_next]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i_prev], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[j_next]]) - \\\n                     (distance_matrix_2[new_solution[i_prev], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[j_next]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i_prev], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[j_next]]) - \\\n                     (distance_matrix_3[new_solution[i_prev], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[j_next]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 256,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Calculate potential improvement in all three objectives\n        current_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]\n\n        current_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]\n\n        current_cost3 = distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n        new_cost3 = distance_matrix_3[base_solution[i-1], base_solution[j]] + distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or new_cost3 < current_cost3):\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Additional objective-aware 2-opt to further improve\n    for _ in range(5):\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Calculate objective improvements\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7582276917220981,
            1.4649542212486266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Calculate potential improvement in all three objectives\n        current_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]\n\n        current_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]\n\n        current_cost3 = distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n        new_cost3 = distance_matrix_3[base_solution[i-1], base_solution[j]] + distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or new_cost3 < current_cost3):\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Additional objective-aware 2-opt to further improve\n    for _ in range(5):\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Calculate objective improvements\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 257,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best average objective value to focus on promising regions\n    selected_idx = np.argmin([sum(obj) / 3 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion move\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n    # 2-opt swap for the first objective\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check if the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    # Insertion move for the other objectives\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l], [node], new_solution[l:]])\n\n    # Ensure solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7454476012807529,
            1.0403057217597962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best average objective value to focus on promising regions\n    selected_idx = np.argmin([sum(obj) / 3 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion move\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n    # 2-opt swap for the first objective\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check if the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    # Insertion move for the other objectives\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l], [node], new_solution[l:]])\n\n    # Ensure solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 258,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    # Sort archive by sum of objectives (descending) to prioritize high-potential solutions\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Randomly select from top 5\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt combined with multi-objective edge swap\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges for 2-opt\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i == j or j - i == 1 or (j == n-1 and i == 0):\n            continue  # Skip invalid or trivial swaps\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective edge swap: consider swapping edges that improve at least one objective\n        for k in range(n):\n            l = (k + 1) % n\n            m = (j + 1) % n\n            n_next = (j + 2) % n if j + 2 < n else 0\n\n            # Calculate cost change for each objective\n            cost_change1 = (distance_matrix_1[new_solution[k], new_solution[m]] +\n                           distance_matrix_1[new_solution[l], new_solution[n_next]]) - \\\n                          (distance_matrix_1[new_solution[k], new_solution[l]] +\n                           distance_matrix_1[new_solution[m], new_solution[n_next]])\n\n            cost_change2 = (distance_matrix_2[new_solution[k], new_solution[m]] +\n                           distance_matrix_2[new_solution[l], new_solution[n_next]]) - \\\n                          (distance_matrix_2[new_solution[k], new_solution[l]] +\n                           distance_matrix_2[new_solution[m], new_solution[n_next]])\n\n            cost_change3 = (distance_matrix_3[new_solution[k], new_solution[m]] +\n                           distance_matrix_3[new_solution[l], new_solution[n_next]]) - \\\n                          (distance_matrix_3[new_solution[k], new_solution[l]] +\n                           distance_matrix_3[new_solution[m], new_solution[n_next]])\n\n            # If the swap improves at least one objective, keep it\n            if cost_change1 < 0 or cost_change2 < 0 or cost_change3 < 0:\n                temp = new_solution[m]\n                new_solution[m] = new_solution[l]\n                new_solution[l] = temp\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6379772671050141,
            1.8765348315238952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    # Sort archive by sum of objectives (descending) to prioritize high-potential solutions\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Randomly select from top 5\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt combined with multi-objective edge swap\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges for 2-opt\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i == j or j - i == 1 or (j == n-1 and i == 0):\n            continue  # Skip invalid or trivial swaps\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective edge swap: consider swapping edges that improve at least one objective\n        for k in range(n):\n            l = (k + 1) % n\n            m = (j + 1) % n\n            n_next = (j + 2) % n if j + 2 < n else 0\n\n            # Calculate cost change for each objective\n            cost_change1 = (distance_matrix_1[new_solution[k], new_solution[m]] +\n                           distance_matrix_1[new_solution[l], new_solution[n_next]]) - \\\n                          (distance_matrix_1[new_solution[k], new_solution[l]] +\n                           distance_matrix_1[new_solution[m], new_solution[n_next]])\n\n            cost_change2 = (distance_matrix_2[new_solution[k], new_solution[m]] +\n                           distance_matrix_2[new_solution[l], new_solution[n_next]]) - \\\n                          (distance_matrix_2[new_solution[k], new_solution[l]] +\n                           distance_matrix_2[new_solution[m], new_solution[n_next]])\n\n            cost_change3 = (distance_matrix_3[new_solution[k], new_solution[m]] +\n                           distance_matrix_3[new_solution[l], new_solution[n_next]]) - \\\n                          (distance_matrix_3[new_solution[k], new_solution[l]] +\n                           distance_matrix_3[new_solution[m], new_solution[n_next]])\n\n            # If the swap improves at least one objective, keep it\n            if cost_change1 < 0 or cost_change2 < 0 or cost_change3 < 0:\n                temp = new_solution[m]\n                new_solution[m] = new_solution[l]\n                new_solution[l] = temp\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 259,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    def diversity_score(solution):\n        obj = archive[solution][1]\n        return np.std(obj)\n\n    # Rank solutions by diversity and select top candidates\n    ranked_indices = sorted(range(len(archive)), key=lambda i: -diversity_score(i))\n    top_candidates = ranked_indices[:max(3, len(archive) // 3)]  # Consider top 1/3 or at least 3 solutions\n    selected_idx = random.choice(top_candidates)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Random 2-opt move (for local improvement in one objective)\n    # 2. Objective-aware edge swap (for multi-objective improvement)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply random 2-opt move\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply objective-aware edge swap\n    if n > 2:\n        # Select edges to swap based on which objective they perform poorly in\n        obj = archive[selected_idx][1]\n        worst_obj = obj.index(max(obj))  # Identify worst objective\n\n        # Choose two edges that are likely to improve the worst objective\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find edges with high distance in the worst objective\n        edge_distances = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            edge_distances.append((i, (i+1)%n, dist_matrix[u, v]))\n\n        # Sort by distance and select the two longest edges\n        edge_distances.sort(key=lambda x: -x[2])\n        if len(edge_distances) >= 2:\n            i1, j1, _ = edge_distances[0]\n            i2, j2, _ = edge_distances[1]\n\n            # Perform the swap\n            if i1 != i2 and j1 != j2:\n                new_solution[i1], new_solution[i2] = new_solution[i2], new_solution[i1]\n\n    # Verify feasibility (though operations above should maintain it)\n    if len(set(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.5800608456999002,
            4.279400622844696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    def diversity_score(solution):\n        obj = archive[solution][1]\n        return np.std(obj)\n\n    # Rank solutions by diversity and select top candidates\n    ranked_indices = sorted(range(len(archive)), key=lambda i: -diversity_score(i))\n    top_candidates = ranked_indices[:max(3, len(archive) // 3)]  # Consider top 1/3 or at least 3 solutions\n    selected_idx = random.choice(top_candidates)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Random 2-opt move (for local improvement in one objective)\n    # 2. Objective-aware edge swap (for multi-objective improvement)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply random 2-opt move\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply objective-aware edge swap\n    if n > 2:\n        # Select edges to swap based on which objective they perform poorly in\n        obj = archive[selected_idx][1]\n        worst_obj = obj.index(max(obj))  # Identify worst objective\n\n        # Choose two edges that are likely to improve the worst objective\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find edges with high distance in the worst objective\n        edge_distances = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            edge_distances.append((i, (i+1)%n, dist_matrix[u, v]))\n\n        # Sort by distance and select the two longest edges\n        edge_distances.sort(key=lambda x: -x[2])\n        if len(edge_distances) >= 2:\n            i1, j1, _ = edge_distances[0]\n            i2, j2, _ = edge_distances[1]\n\n            # Perform the swap\n            if i1 != i2 and j1 != j2:\n                new_solution[i1], new_solution[i2] = new_solution[i2], new_solution[i1]\n\n    # Verify feasibility (though operations above should maintain it)\n    if len(set(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 260,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = np.array([sum(obj) for _, obj in archive])\n    weights = weights / weights.sum() if weights.sum() > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total distance for each objective\n    current_dist1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n    current_dist2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n    current_dist3 = sum(distance_matrix_3[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n\n    # Hybrid local search operator: combination of 2-opt and insertion with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First try 2-opt with objective-aware edge selection\n    for _ in range(min(10, n//2)):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate potential improvement for each objective\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        delta1 = sum(distance_matrix_1[a, b] for a, b in new_edges) - sum(distance_matrix_1[a, b] for a, b in old_edges[:2])\n        delta2 = sum(distance_matrix_2[a, b] for a, b in new_edges) - sum(distance_matrix_2[a, b] for a, b in old_edges[:2])\n        delta3 = sum(distance_matrix_3[a, b] for a, b in new_edges) - sum(distance_matrix_3[a, b] for a, b in old_edges[:2])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Then try insertion with objective-aware node selection\n    for _ in range(min(5, n//3)):\n        # Select a node that's \"bad\" in at least one objective\n        bad_nodes = []\n        for idx in range(n):\n            prev = new_solution[idx-1]\n            curr = new_solution[idx]\n            next_node = new_solution[(idx+1)%n]\n\n            dist1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            dist2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            dist3 = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n\n            # If this node is a local maximum in any objective\n            if (dist1 > distance_matrix_1[prev, next_node] * 1.2 or\n                dist2 > distance_matrix_2[prev, next_node] * 1.2 or\n                dist3 > distance_matrix_3[prev, next_node] * 1.2):\n                bad_nodes.append(idx)\n\n        if bad_nodes:\n            node_idx = np.random.choice(bad_nodes)\n            node = new_solution[node_idx]\n\n            # Try to reinsert this node in a better position\n            best_pos = -1\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == node_idx or pos == (node_idx-1)%n:\n                    continue\n\n                # Calculate potential improvement\n                prev = new_solution[pos-1]\n                next_node = new_solution[pos]\n\n                old_dist1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n                new_dist1 = distance_matrix_1[prev, next_node]\n\n                old_dist2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n                new_dist2 = distance_matrix_2[prev, next_node]\n\n                old_dist3 = distance_matrix_3[prev, node] + distance_matrix_3[node, next_node]\n                new_dist3 = distance_matrix_3[prev, next_node]\n\n                improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2) + (old_dist3 - new_dist3)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != -1 and best_improvement > 0:\n                # Remove the node and reinsert\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, best_pos, node)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7470340139944255,
            1.2093982219696044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = np.array([sum(obj) for _, obj in archive])\n    weights = weights / weights.sum() if weights.sum() > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total distance for each objective\n    current_dist1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n    current_dist2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n    current_dist3 = sum(distance_matrix_3[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n\n    # Hybrid local search operator: combination of 2-opt and insertion with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First try 2-opt with objective-aware edge selection\n    for _ in range(min(10, n//2)):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate potential improvement for each objective\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        delta1 = sum(distance_matrix_1[a, b] for a, b in new_edges) - sum(distance_matrix_1[a, b] for a, b in old_edges[:2])\n        delta2 = sum(distance_matrix_2[a, b] for a, b in new_edges) - sum(distance_matrix_2[a, b] for a, b in old_edges[:2])\n        delta3 = sum(distance_matrix_3[a, b] for a, b in new_edges) - sum(distance_matrix_3[a, b] for a, b in old_edges[:2])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Then try insertion with objective-aware node selection\n    for _ in range(min(5, n//3)):\n        # Select a node that's \"bad\" in at least one objective\n        bad_nodes = []\n        for idx in range(n):\n            prev = new_solution[idx-1]\n            curr = new_solution[idx]\n            next_node = new_solution[(idx+1)%n]\n\n            dist1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            dist2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            dist3 = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n\n            # If this node is a local maximum in any objective\n            if (dist1 > distance_matrix_1[prev, next_node] * 1.2 or\n                dist2 > distance_matrix_2[prev, next_node] * 1.2 or\n                dist3 > distance_matrix_3[prev, next_node] * 1.2):\n                bad_nodes.append(idx)\n\n        if bad_nodes:\n            node_idx = np.random.choice(bad_nodes)\n            node = new_solution[node_idx]\n\n            # Try to reinsert this node in a better position\n            best_pos = -1\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == node_idx or pos == (node_idx-1)%n:\n                    continue\n\n                # Calculate potential improvement\n                prev = new_solution[pos-1]\n                next_node = new_solution[pos]\n\n                old_dist1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n                new_dist1 = distance_matrix_1[prev, next_node]\n\n                old_dist2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n                new_dist2 = distance_matrix_2[prev, next_node]\n\n                old_dist3 = distance_matrix_3[prev, node] + distance_matrix_3[node, next_node]\n                new_dist3 = distance_matrix_3[prev, next_node]\n\n                improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2) + (old_dist3 - new_dist3)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != -1 and best_improvement > 0:\n                # Remove the node and reinsert\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, best_pos, node)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 261,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here we select the solution with the highest sum of objectives, assuming it has room for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Apply a 2-opt move if it improves at least one objective\n    # 2. If no improvement, apply a 3-opt move\n    n = len(new_solution)\n    improved = False\n\n    # Try 2-opt first\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i:j+1] = np.flip(candidate[i:j+1])\n\n            # Check if candidate is better in at least one objective\n            old_obj = archive[selected_idx][1]\n            new_obj = (\n                np.sum(distance_matrix_1[np.roll(candidate, -1), candidate]),\n                np.sum(distance_matrix_2[np.roll(candidate, -1), candidate]),\n                np.sum(distance_matrix_3[np.roll(candidate, -1), candidate])\n            )\n\n            if any(new_o < old_o for new_o, old_o in zip(new_obj, old_obj)):\n                new_solution = candidate\n                improved = True\n                break\n        if improved:\n            break\n\n    # If no improvement with 2-opt, try 3-opt\n    if not improved:\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    # Create candidate solution\n                    candidate = new_solution.copy()\n                    candidate[i:j+1] = candidate[j:k+1]\n                    candidate[j:k+1] = new_solution[i:j+1]\n\n                    # Check if candidate is better in at least one objective\n                    old_obj = archive[selected_idx][1]\n                    new_obj = (\n                        np.sum(distance_matrix_1[np.roll(candidate, -1), candidate]),\n                        np.sum(distance_matrix_2[np.roll(candidate, -1), candidate]),\n                        np.sum(distance_matrix_3[np.roll(candidate, -1), candidate])\n                    )\n\n                    if any(new_o < old_o for new_o, old_o in zip(new_obj, old_obj)):\n                        new_solution = candidate\n                        improved = True\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    # If no improvement, apply a random 2-opt as fallback\n    if not improved:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.6359327401161375,
            0.965842854976654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here we select the solution with the highest sum of objectives, assuming it has room for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Apply a 2-opt move if it improves at least one objective\n    # 2. If no improvement, apply a 3-opt move\n    n = len(new_solution)\n    improved = False\n\n    # Try 2-opt first\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i:j+1] = np.flip(candidate[i:j+1])\n\n            # Check if candidate is better in at least one objective\n            old_obj = archive[selected_idx][1]\n            new_obj = (\n                np.sum(distance_matrix_1[np.roll(candidate, -1), candidate]),\n                np.sum(distance_matrix_2[np.roll(candidate, -1), candidate]),\n                np.sum(distance_matrix_3[np.roll(candidate, -1), candidate])\n            )\n\n            if any(new_o < old_o for new_o, old_o in zip(new_obj, old_obj)):\n                new_solution = candidate\n                improved = True\n                break\n        if improved:\n            break\n\n    # If no improvement with 2-opt, try 3-opt\n    if not improved:\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    # Create candidate solution\n                    candidate = new_solution.copy()\n                    candidate[i:j+1] = candidate[j:k+1]\n                    candidate[j:k+1] = new_solution[i:j+1]\n\n                    # Check if candidate is better in at least one objective\n                    old_obj = archive[selected_idx][1]\n                    new_obj = (\n                        np.sum(distance_matrix_1[np.roll(candidate, -1), candidate]),\n                        np.sum(distance_matrix_2[np.roll(candidate, -1), candidate]),\n                        np.sum(distance_matrix_3[np.roll(candidate, -1), candidate])\n                    )\n\n                    if any(new_o < old_o for new_o, old_o in zip(new_obj, old_obj)):\n                        new_solution = candidate\n                        improved = True\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    # If no improvement, apply a random 2-opt as fallback\n    if not improved:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 262,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # 1. Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # 2. Objective-aware swap: choose which nodes to swap based on their contributions to each objective\n    segment = new_solution[i:j+1]\n    if len(segment) < 2:\n        return new_solution\n\n    # Calculate the improvement potential for each swap candidate\n    improvements = []\n    for k in range(len(segment)-1):\n        a, b = segment[k], segment[k+1]\n\n        # Calculate the change in each objective if we swap a and b\n        original_cost = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b])\n        swapped_cost = (distance_matrix_1[a, segment[k+1]] + distance_matrix_1[segment[k+1], b] +\n                        distance_matrix_2[a, segment[k+1]] + distance_matrix_2[segment[k+1], b] +\n                        distance_matrix_3[a, segment[k+1]] + distance_matrix_3[segment[k+1], b])\n        improvement = original_cost - swapped_cost\n        improvements.append(improvement)\n\n    if improvements:\n        best_swap = np.argmax(improvements)\n        # Perform the best swap found\n        new_solution[i+best_swap], new_solution[i+best_swap+1] = new_solution[i+best_swap+1], new_solution[i+best_swap]\n\n    # 3. If no improvement, try a random 2-opt\n    if new_solution.tolist() == base_solution.tolist():\n        # Select two non-adjacent edges\n        a, b = np.random.choice(n, size=2, replace=False)\n        if abs(a - b) <= 1:\n            return new_solution\n\n        # Perform 2-opt\n        if a > b:\n            a, b = b, a\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6800634957441103,
            1.248953139781952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # 1. Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # 2. Objective-aware swap: choose which nodes to swap based on their contributions to each objective\n    segment = new_solution[i:j+1]\n    if len(segment) < 2:\n        return new_solution\n\n    # Calculate the improvement potential for each swap candidate\n    improvements = []\n    for k in range(len(segment)-1):\n        a, b = segment[k], segment[k+1]\n\n        # Calculate the change in each objective if we swap a and b\n        original_cost = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b])\n        swapped_cost = (distance_matrix_1[a, segment[k+1]] + distance_matrix_1[segment[k+1], b] +\n                        distance_matrix_2[a, segment[k+1]] + distance_matrix_2[segment[k+1], b] +\n                        distance_matrix_3[a, segment[k+1]] + distance_matrix_3[segment[k+1], b])\n        improvement = original_cost - swapped_cost\n        improvements.append(improvement)\n\n    if improvements:\n        best_swap = np.argmax(improvements)\n        # Perform the best swap found\n        new_solution[i+best_swap], new_solution[i+best_swap+1] = new_solution[i+best_swap+1], new_solution[i+best_swap]\n\n    # 3. If no improvement, try a random 2-opt\n    if new_solution.tolist() == base_solution.tolist():\n        # Select two non-adjacent edges\n        a, b = np.random.choice(n, size=2, replace=False)\n        if abs(a - b) <= 1:\n            return new_solution\n\n        # Perform 2-opt\n        if a > b:\n            a, b = b, a\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 263,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    def potential_score(obj):\n        return -(obj[0] + obj[1] + obj[2])  # Negative for minimization\n\n    archive.sort(key=lambda x: potential_score(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 or all if less than 3\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    def calculate_edge_cost(i, j):\n        # Calculate the cost of replacing edges (i-1, i) and (j, j+1) with (i-1, j) and (i, j+1)\n        cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%len(base_solution)]]\n        cost2 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%len(base_solution)]]\n        delta1 = cost1 - cost2\n\n        cost1 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%len(base_solution)]]\n        cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%len(base_solution)]]\n        delta2 = cost1 - cost2\n\n        cost1 = distance_matrix_3[base_solution[i-1], base_solution[j]] + distance_matrix_3[base_solution[i], base_solution[(j+1)%len(base_solution)]]\n        cost2 = distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[j], base_solution[(j+1)%len(base_solution)]]\n        delta3 = cost1 - cost2\n\n        # Weighted sum of improvements across objectives\n        return (delta1 + delta2 + delta3) / 3\n\n    # Find the best 2-opt move across all objectives\n    best_delta = float('inf')\n    best_i, best_j = -1, -1\n\n    for i in range(1, len(base_solution)-1):\n        for j in range(i+1, len(base_solution)):\n            delta = calculate_edge_cost(i, j)\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    # Apply the best move if it improves at least one objective\n    if best_i != -1 and best_delta < 0:\n        new_solution = base_solution.copy()\n        # Reverse the segment between best_i and best_j\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n        return new_solution\n\n    # If no improvement found, perform a random 2-opt move\n    i = np.random.randint(1, len(base_solution)-1)\n    j = np.random.randint(i+1, len(base_solution))\n    new_solution = base_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6675349053162802,
            3.3685858726501463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    def potential_score(obj):\n        return -(obj[0] + obj[1] + obj[2])  # Negative for minimization\n\n    archive.sort(key=lambda x: potential_score(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 or all if less than 3\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    def calculate_edge_cost(i, j):\n        # Calculate the cost of replacing edges (i-1, i) and (j, j+1) with (i-1, j) and (i, j+1)\n        cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%len(base_solution)]]\n        cost2 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%len(base_solution)]]\n        delta1 = cost1 - cost2\n\n        cost1 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%len(base_solution)]]\n        cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%len(base_solution)]]\n        delta2 = cost1 - cost2\n\n        cost1 = distance_matrix_3[base_solution[i-1], base_solution[j]] + distance_matrix_3[base_solution[i], base_solution[(j+1)%len(base_solution)]]\n        cost2 = distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[j], base_solution[(j+1)%len(base_solution)]]\n        delta3 = cost1 - cost2\n\n        # Weighted sum of improvements across objectives\n        return (delta1 + delta2 + delta3) / 3\n\n    # Find the best 2-opt move across all objectives\n    best_delta = float('inf')\n    best_i, best_j = -1, -1\n\n    for i in range(1, len(base_solution)-1):\n        for j in range(i+1, len(base_solution)):\n            delta = calculate_edge_cost(i, j)\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    # Apply the best move if it improves at least one objective\n    if best_i != -1 and best_delta < 0:\n        new_solution = base_solution.copy()\n        # Reverse the segment between best_i and best_j\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n        return new_solution\n\n    # If no improvement found, perform a random 2-opt move\n    i = np.random.randint(1, len(base_solution)-1)\n    j = np.random.randint(i+1, len(base_solution))\n    new_solution = base_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 264,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity to potential improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 2:\n        return new_solution\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Select edges with high distance in the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the edge with maximum distance in the worst objective\n    max_dist = -1\n    max_i, max_j = 0, 1\n    for i in range(n):\n        j = (i + 1) % n\n        current_dist = dist_matrix[base_solution[i], base_solution[j]]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            max_i, max_j = i, j\n\n    # Swap the nodes at max_i and max_j to potentially improve the worst objective\n    if max_i != max_j:\n        new_solution[max_i], new_solution[max_j] = new_solution[max_j], new_solution[max_i]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8229000541931765,
            0.8122160315513611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity to potential improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 2:\n        return new_solution\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Select edges with high distance in the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the edge with maximum distance in the worst objective\n    max_dist = -1\n    max_i, max_j = 0, 1\n    for i in range(n):\n        j = (i + 1) % n\n        current_dist = dist_matrix[base_solution[i], base_solution[j]]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            max_i, max_j = i, j\n\n    # Swap the nodes at max_i and max_j to potentially improve the worst objective\n    if max_i != max_j:\n        new_solution[max_i], new_solution[max_j] = new_solution[max_j], new_solution[max_i]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 265,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware moves\n    n = len(base_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    # Perform a 2-opt move\n    new_solution[a:b] = base_solution[a:b][::-1]\n\n    # Objective-aware perturbation: consider the worst-performing objective\n    objectives = [obj for (sol, obj) in archive]\n    worst_obj_idx = np.argmax([sum(obj) for obj in objectives])\n    worst_solution = archive[worst_obj_idx][0]\n\n    # Apply a move that improves the worst objective\n    for i in range(n):\n        j = (i + 1) % n\n        # Calculate potential improvement in the worst objective\n        original_cost = (distance_matrix_1[worst_solution[i], worst_solution[j]] +\n                          distance_matrix_2[worst_solution[i], worst_solution[j]] +\n                          distance_matrix_3[worst_solution[i], worst_solution[j]])\n        swapped_cost = (distance_matrix_1[worst_solution[i], worst_solution[j+1]] +\n                        distance_matrix_2[worst_solution[i], worst_solution[j+1]] +\n                        distance_matrix_3[worst_solution[i], worst_solution[j+1]])\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.75720703467792,
            1.1924043655395509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware moves\n    n = len(base_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    # Perform a 2-opt move\n    new_solution[a:b] = base_solution[a:b][::-1]\n\n    # Objective-aware perturbation: consider the worst-performing objective\n    objectives = [obj for (sol, obj) in archive]\n    worst_obj_idx = np.argmax([sum(obj) for obj in objectives])\n    worst_solution = archive[worst_obj_idx][0]\n\n    # Apply a move that improves the worst objective\n    for i in range(n):\n        j = (i + 1) % n\n        # Calculate potential improvement in the worst objective\n        original_cost = (distance_matrix_1[worst_solution[i], worst_solution[j]] +\n                          distance_matrix_2[worst_solution[i], worst_solution[j]] +\n                          distance_matrix_3[worst_solution[i], worst_solution[j]])\n        swapped_cost = (distance_matrix_1[worst_solution[i], worst_solution[j+1]] +\n                        distance_matrix_2[worst_solution[i], worst_solution[j+1]] +\n                        distance_matrix_3[worst_solution[i], worst_solution[j+1]])\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 266,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a solution with high potential for improvement (lowest cost in at least one objective)\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives to identify potential candidates\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select top 10% of solutions or all if archive is small\n    candidate_count = max(1, len(archive_sorted) // 10)\n    candidates = archive_sorted[:candidate_count]\n\n    # Randomly select one candidate\n    base_solution, _ = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n), 2)\n\n        # Perform 2-opt move (swap edges)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check if the move improves at least one objective\n        original_costs = [\n            sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # If the move doesn't improve at least one objective, revert it\n        if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = base_solution.copy()\n\n        # Occasionally perform objective-aware swaps (focus on the worst objective)\n        if random.random() < 0.3:\n            worst_obj = np.argmax(original_costs)\n            if worst_obj == 0:\n                current_matrix = distance_matrix_1\n            elif worst_obj == 1:\n                current_matrix = distance_matrix_2\n            else:\n                current_matrix = distance_matrix_3\n\n            # Find the worst edge in this objective\n            max_cost = -1\n            worst_i = -1\n            for k in range(n):\n                cost = current_matrix[new_solution[k], new_solution[(k+1)%n]]\n                if cost > max_cost:\n                    max_cost = cost\n                    worst_i = k\n\n            # Try to replace the worst edge with a better one\n            for k in range(n):\n                if k == worst_i or k == (worst_i + 1) % n:\n                    continue\n                # Try swapping nodes\n                temp_solution = new_solution.copy()\n                temp_solution[worst_i], temp_solution[k] = temp_solution[k], temp_solution[worst_i]\n                temp_cost = sum(current_matrix[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n))\n                if temp_cost < max_cost:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6858610145535277,
            4.047494411468506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a solution with high potential for improvement (lowest cost in at least one objective)\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives to identify potential candidates\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select top 10% of solutions or all if archive is small\n    candidate_count = max(1, len(archive_sorted) // 10)\n    candidates = archive_sorted[:candidate_count]\n\n    # Randomly select one candidate\n    base_solution, _ = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n), 2)\n\n        # Perform 2-opt move (swap edges)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check if the move improves at least one objective\n        original_costs = [\n            sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # If the move doesn't improve at least one objective, revert it\n        if all(new_cost >= original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = base_solution.copy()\n\n        # Occasionally perform objective-aware swaps (focus on the worst objective)\n        if random.random() < 0.3:\n            worst_obj = np.argmax(original_costs)\n            if worst_obj == 0:\n                current_matrix = distance_matrix_1\n            elif worst_obj == 1:\n                current_matrix = distance_matrix_2\n            else:\n                current_matrix = distance_matrix_3\n\n            # Find the worst edge in this objective\n            max_cost = -1\n            worst_i = -1\n            for k in range(n):\n                cost = current_matrix[new_solution[k], new_solution[(k+1)%n]]\n                if cost > max_cost:\n                    max_cost = cost\n                    worst_i = k\n\n            # Try to replace the worst edge with a better one\n            for k in range(n):\n                if k == worst_i or k == (worst_i + 1) % n:\n                    continue\n                # Try swapping nodes\n                temp_solution = new_solution.copy()\n                temp_solution[worst_i], temp_solution[k] = temp_solution[k], temp_solution[worst_i]\n                temp_cost = sum(current_matrix[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n))\n                if temp_cost < max_cost:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 267,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware node swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt local search to improve one objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i == j or j - i == 1:\n            continue\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Evaluate candidate\n        obj1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        obj2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        obj3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective improves\n        current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        if (obj1 < current_obj1) or (obj2 < current_obj2) or (obj3 < current_obj3):\n            new_solution = candidate\n\n    # Then perform objective-aware node swaps\n    for _ in range(5):  # Limit iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i == j:\n            continue\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Evaluate candidate\n        obj1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        obj2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        obj3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective improves\n        current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        if (obj1 < current_obj1) or (obj2 < current_obj2) or (obj3 < current_obj3):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6376591758435294,
            2.7153142929077148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware node swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt local search to improve one objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i == j or j - i == 1:\n            continue\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Evaluate candidate\n        obj1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        obj2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        obj3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective improves\n        current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        if (obj1 < current_obj1) or (obj2 < current_obj2) or (obj3 < current_obj3):\n            new_solution = candidate\n\n    # Then perform objective-aware node swaps\n    for _ in range(5):  # Limit iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i == j:\n            continue\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Evaluate candidate\n        obj1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        obj2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        obj3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective improves\n        current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        if (obj1 < current_obj1) or (obj2 < current_obj2) or (obj3 < current_obj3):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 268,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best node to swap with another based on objectives\n    if np.random.rand() < 0.5:\n        # Evaluate potential swaps based on all three objectives\n        best_node = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j:\n                continue\n\n            # Calculate improvement for each objective\n            original_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_1[base_solution[i], base_solution[i+1]] +\n                            distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_2[base_solution[i], base_solution[i+1]] +\n                            distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_3[base_solution[i], base_solution[i+1]])\n\n            new_cost = (distance_matrix_1[base_solution[i-1], base_solution[k]] +\n                        distance_matrix_1[base_solution[k], base_solution[i+1]] +\n                        distance_matrix_2[base_solution[i-1], base_solution[k]] +\n                        distance_matrix_2[base_solution[k], base_solution[i+1]] +\n                        distance_matrix_3[base_solution[i-1], base_solution[k]] +\n                        distance_matrix_3[base_solution[k], base_solution[i+1]])\n\n            improvement = original_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_node = k\n\n        if best_node != -1:\n            new_solution[i], new_solution[best_node] = new_solution[best_node], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.719765197366229,
            1.274269962310791
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best node to swap with another based on objectives\n    if np.random.rand() < 0.5:\n        # Evaluate potential swaps based on all three objectives\n        best_node = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j:\n                continue\n\n            # Calculate improvement for each objective\n            original_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_1[base_solution[i], base_solution[i+1]] +\n                            distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_2[base_solution[i], base_solution[i+1]] +\n                            distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_3[base_solution[i], base_solution[i+1]])\n\n            new_cost = (distance_matrix_1[base_solution[i-1], base_solution[k]] +\n                        distance_matrix_1[base_solution[k], base_solution[i+1]] +\n                        distance_matrix_2[base_solution[i-1], base_solution[k]] +\n                        distance_matrix_2[base_solution[k], base_solution[i+1]] +\n                        distance_matrix_3[base_solution[i-1], base_solution[k]] +\n                        distance_matrix_3[base_solution[k], base_solution[i+1]])\n\n            improvement = original_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_node = k\n\n        if best_node != -1:\n            new_solution[i], new_solution[best_node] = new_solution[best_node], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 269,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive\n    base_solution, _ = archive[np.random.randint(len(archive))]\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment to reverse (2-opt)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Randomly swap two nodes (swap-opt)\n    if n > 1:\n        k, l = np.random.choice(n, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Randomly insert a node to a new position (insert-opt)\n    if n > 2:\n        m = np.random.randint(n)\n        node = new_solution[m]\n        new_solution = np.delete(new_solution, m)\n        new_pos = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If duplicates exist, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7155259951950311,
            1.2003735303878784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive\n    base_solution, _ = archive[np.random.randint(len(archive))]\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment to reverse (2-opt)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Randomly swap two nodes (swap-opt)\n    if n > 1:\n        k, l = np.random.choice(n, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Randomly insert a node to a new position (insert-opt)\n    if n > 2:\n        m = np.random.randint(n)\n        node = new_solution[m]\n        new_solution = np.delete(new_solution, m)\n        new_pos = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If duplicates exist, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 270,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated and showing potential for improvement\n    # Here, we select the solution with the highest sum of normalized objectives (to encourage diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap based on the most critical objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n\n    # Probabilistically select which objective to prioritize\n    obj_weights = np.array([obj1, obj2, obj3]) / total_obj\n    selected_obj = np.random.choice([0, 1, 2], p=obj_weights)\n\n    # Get the distance matrix corresponding to the selected objective\n    if selected_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif selected_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the pair of edges that would most improve the selected objective\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Current edges: (i, i+1) and (j, (j+1)%n)\n            # Potential new edges: (i, j) and (i+1, (j+1)%n)\n            current_length = distance_matrix[new_solution[i], new_solution[i+1]] + distance_matrix[new_solution[j], new_solution[(j+1)%n]]\n            new_length = distance_matrix[new_solution[i], new_solution[j]] + distance_matrix[new_solution[i+1], new_solution[(j+1)%n]]\n            improvement = current_length - new_length\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        # Reverse the segment between best_i+1 and best_j\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6866902975367475,
            2.085312879085541
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated and showing potential for improvement\n    # Here, we select the solution with the highest sum of normalized objectives (to encourage diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap based on the most critical objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n\n    # Probabilistically select which objective to prioritize\n    obj_weights = np.array([obj1, obj2, obj3]) / total_obj\n    selected_obj = np.random.choice([0, 1, 2], p=obj_weights)\n\n    # Get the distance matrix corresponding to the selected objective\n    if selected_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif selected_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the pair of edges that would most improve the selected objective\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Current edges: (i, i+1) and (j, (j+1)%n)\n            # Potential new edges: (i, j) and (i+1, (j+1)%n)\n            current_length = distance_matrix[new_solution[i], new_solution[i+1]] + distance_matrix[new_solution[j], new_solution[(j+1)%n]]\n            new_length = distance_matrix[new_solution[i], new_solution[j]] + distance_matrix[new_solution[i+1], new_solution[(j+1)%n]]\n            improvement = current_length - new_length\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        # Reverse the segment between best_i+1 and best_j\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 271,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose solutions with high diversity in objectives\n    objectives = [obj for (sol, obj) in archive]\n    objective_values = np.array(objectives)\n    normalized_obj = (objective_values - objective_values.mean(axis=0)) / (objective_values.std(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    selected_indices = np.argsort(-diversity_scores)[:max(1, len(archive)//3)]  # Top 1/3 diverse solutions\n\n    if len(selected_indices) == 0:\n        selected_indices = [0]\n\n    # Randomly select one of the top diverse solutions\n    base_idx = np.random.choice(selected_indices)\n    base_solution = archive[base_idx][0].copy()\n\n    # Hybrid local search strategy: combination of 2-opt and random segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, apply 2-opt to the segment with the highest average distance in any objective space\n    for _ in range(3):  # Repeat 3 times for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        segment_reversed = segment[::-1]\n\n        # Evaluate both options in all three objectives\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = segment_reversed\n        reversed_costs = [\n            sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n            sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n            sum(distance_matrix_3[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(reversed_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = temp_solution\n\n    # Then apply random segment inversion to escape local optima\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and apply a simpler move\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8112779741756277,
            1.3946362614631653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose solutions with high diversity in objectives\n    objectives = [obj for (sol, obj) in archive]\n    objective_values = np.array(objectives)\n    normalized_obj = (objective_values - objective_values.mean(axis=0)) / (objective_values.std(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    selected_indices = np.argsort(-diversity_scores)[:max(1, len(archive)//3)]  # Top 1/3 diverse solutions\n\n    if len(selected_indices) == 0:\n        selected_indices = [0]\n\n    # Randomly select one of the top diverse solutions\n    base_idx = np.random.choice(selected_indices)\n    base_solution = archive[base_idx][0].copy()\n\n    # Hybrid local search strategy: combination of 2-opt and random segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, apply 2-opt to the segment with the highest average distance in any objective space\n    for _ in range(3):  # Repeat 3 times for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        segment_reversed = segment[::-1]\n\n        # Evaluate both options in all three objectives\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = segment_reversed\n        reversed_costs = [\n            sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n            sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n            sum(distance_matrix_3[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(reversed_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = temp_solution\n\n    # Then apply random segment inversion to escape local optima\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and apply a simpler move\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 272,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and random segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt or random segment reversal based on a probability\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random segment reversal with variable length\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7973101111703647,
            0.8525000214576721
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and random segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt or random segment reversal based on a probability\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random segment reversal with variable length\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 273,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(np.arange(1, n-1), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to balance the three objectives\n    # Calculate the current total distances for each objective\n    def calculate_total_distance(solution, distance_matrix):\n        total = 0.0\n        for k in range(len(solution) - 1):\n            total += distance_matrix[solution[k], solution[k+1]]\n        total += distance_matrix[solution[-1], solution[0]]  # Return to start\n        return total\n\n    current_distances = [\n        calculate_total_distance(new_solution, distance_matrix_1),\n        calculate_total_distance(new_solution, distance_matrix_2),\n        calculate_total_distance(new_solution, distance_matrix_3)\n    ]\n\n    # Find the objective with the highest current distance\n    worst_obj_idx = np.argmax(current_distances)\n\n    # Select a pair of nodes to swap that might improve this worst objective\n    # We look for nodes that are close in the other two objectives but far in the worst one\n    for _ in range(10):  # Try up to 10 random swaps\n        a, b = sorted(np.random.choice(np.arange(1, n-1), 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new distances\n        new_distances = [\n            calculate_total_distance(temp_solution, distance_matrix_1),\n            calculate_total_distance(temp_solution, distance_matrix_2),\n            calculate_total_distance(temp_solution, distance_matrix_3)\n        ]\n\n        # Accept if it improves the worst objective while not worsening others too much\n        if (new_distances[worst_obj_idx] < current_distances[worst_obj_idx] and\n            all(new_distances[i] <= current_distances[i] * 1.05 for i in range(3) if i != worst_obj_idx)):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7520696885419097,
            2.1006261706352234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(np.arange(1, n-1), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to balance the three objectives\n    # Calculate the current total distances for each objective\n    def calculate_total_distance(solution, distance_matrix):\n        total = 0.0\n        for k in range(len(solution) - 1):\n            total += distance_matrix[solution[k], solution[k+1]]\n        total += distance_matrix[solution[-1], solution[0]]  # Return to start\n        return total\n\n    current_distances = [\n        calculate_total_distance(new_solution, distance_matrix_1),\n        calculate_total_distance(new_solution, distance_matrix_2),\n        calculate_total_distance(new_solution, distance_matrix_3)\n    ]\n\n    # Find the objective with the highest current distance\n    worst_obj_idx = np.argmax(current_distances)\n\n    # Select a pair of nodes to swap that might improve this worst objective\n    # We look for nodes that are close in the other two objectives but far in the worst one\n    for _ in range(10):  # Try up to 10 random swaps\n        a, b = sorted(np.random.choice(np.arange(1, n-1), 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new distances\n        new_distances = [\n            calculate_total_distance(temp_solution, distance_matrix_1),\n            calculate_total_distance(temp_solution, distance_matrix_2),\n            calculate_total_distance(temp_solution, distance_matrix_3)\n        ]\n\n        # Accept if it improves the worst objective while not worsening others too much\n        if (new_distances[worst_obj_idx] < current_distances[worst_obj_idx] and\n            all(new_distances[i] <= current_distances[i] * 1.05 for i in range(3) if i != worst_obj_idx)):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 274,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum indicates more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search strategy combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            # Select two distinct edges to swap\n            i, j = sorted(random.sample(range(n), 2))\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform node insertion\n            # Remove a random node and insert it in a new position\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6304954630969303,
            1.1604532837867736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum indicates more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search strategy combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            # Select two distinct edges to swap\n            i, j = sorted(random.sample(range(n), 2))\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform node insertion\n            # Remove a random node and insert it in a new position\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 275,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two non-adjacent edges to modify\n    i = np.random.randint(0, n-2)\n    j = np.random.randint(i+2, n)\n\n    # Apply 2-opt move (swap edges)\n    new_solution[i+1:j+1] = base_solution[j:i:-1]\n\n    # Apply edge insertion (move a random edge to a different position)\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n or set(new_solution) != set(base_solution):\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8009369941361127,
            0.6945552945137023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two non-adjacent edges to modify\n    i = np.random.randint(0, n-2)\n    j = np.random.randint(i+2, n)\n\n    # Apply 2-opt move (swap edges)\n    new_solution[i+1:j+1] = base_solution[j:i:-1]\n\n    # Apply edge insertion (move a random edge to a different position)\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n or set(new_solution) != set(base_solution):\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 276,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest in at least one objective)\n    sorted_archive = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Apply hybrid local search: 2-opt with multi-objective edge swap\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n        # Multi-objective edge swap\n        if i != k and j != l:\n            # Calculate current and potential improvements in all three objectives\n            current_cost = (\n                distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]],\n                distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]],\n                distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[j-1], base_solution[j]]\n            )\n\n            potential_cost = (\n                distance_matrix_1[base_solution[i-1], base_solution[k]] + distance_matrix_1[base_solution[j-1], base_solution[l]],\n                distance_matrix_2[base_solution[i-1], base_solution[k]] + distance_matrix_2[base_solution[j-1], base_solution[l]],\n                distance_matrix_3[base_solution[i-1], base_solution[k]] + distance_matrix_3[base_solution[j-1], base_solution[l]]\n            )\n\n            # Accept if at least one objective improves\n            if any(p < c for p, c in zip(potential_cost, current_cost)):\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.5863169243845645,
            0.9925063729286194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest in at least one objective)\n    sorted_archive = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Apply hybrid local search: 2-opt with multi-objective edge swap\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n        # Multi-objective edge swap\n        if i != k and j != l:\n            # Calculate current and potential improvements in all three objectives\n            current_cost = (\n                distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]],\n                distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]],\n                distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[j-1], base_solution[j]]\n            )\n\n            potential_cost = (\n                distance_matrix_1[base_solution[i-1], base_solution[k]] + distance_matrix_1[base_solution[j-1], base_solution[l]],\n                distance_matrix_2[base_solution[i-1], base_solution[k]] + distance_matrix_2[base_solution[j-1], base_solution[l]],\n                distance_matrix_3[base_solution[i-1], base_solution[k]] + distance_matrix_3[base_solution[j-1], base_solution[l]]\n            )\n\n            # Accept if at least one objective improves\n            if any(p < c for p, c in zip(potential_cost, current_cost)):\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 277,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by sum of objectives to find the most promising solution\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Determine which objective space has the highest cost in the segment\n    segment_costs = [\n        sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))),\n        sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))),\n        sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    ]\n\n    # Reverse the segment if it improves the worst objective\n    worst_obj = np.argmax(segment_costs)\n    if worst_obj == 0:\n        original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n    elif worst_obj == 1:\n        original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n    else:\n        original_cost = sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        reversed_cost = sum(distance_matrix_3[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n\n    if reversed_cost < original_cost:\n        new_solution[i:j+1] = segment[::-1]\n\n    # Apply a 2-opt swap to further improve the solution\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6847009526048213,
            1.0824903011322022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by sum of objectives to find the most promising solution\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Determine which objective space has the highest cost in the segment\n    segment_costs = [\n        sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))),\n        sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))),\n        sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    ]\n\n    # Reverse the segment if it improves the worst objective\n    worst_obj = np.argmax(segment_costs)\n    if worst_obj == 0:\n        original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n    elif worst_obj == 1:\n        original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n    else:\n        original_cost = sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        reversed_cost = sum(distance_matrix_3[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n\n    if reversed_cost < original_cost:\n        new_solution[i:j+1] = segment[::-1]\n\n    # Apply a 2-opt swap to further improve the solution\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 278,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in any objective)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Perform 2-opt on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Choose distance matrix based on worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the worst objective\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        j = (i + 1) % n\n        dist = dist_matrix[base_solution[i], base_solution[j]]\n        if dist > max_dist:\n            max_dist = dist\n            worst_edge = (i, j)\n\n    if worst_edge:\n        i, j = worst_edge\n        # Try to find a better pair to swap\n        for k in range(i + 1, j):\n            l = (k + 1) % n\n            if dist_matrix[base_solution[i], base_solution[k]] + dist_matrix[base_solution[j], base_solution[l]] < max_dist:\n                # Perform the swap\n                new_solution[i:j] = np.flip(new_solution[i:j])\n                break\n\n    # Step 2: Perform a random swap to explore other objectives\n    if np.random.random() < 0.3:  # 30% chance of additional swap\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6940245793205314,
            1.4272881269454956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in any objective)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Perform 2-opt on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Choose distance matrix based on worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the worst objective\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        j = (i + 1) % n\n        dist = dist_matrix[base_solution[i], base_solution[j]]\n        if dist > max_dist:\n            max_dist = dist\n            worst_edge = (i, j)\n\n    if worst_edge:\n        i, j = worst_edge\n        # Try to find a better pair to swap\n        for k in range(i + 1, j):\n            l = (k + 1) % n\n            if dist_matrix[base_solution[i], base_solution[k]] + dist_matrix[base_solution[j], base_solution[l]] < max_dist:\n                # Perform the swap\n                new_solution[i:j] = np.flip(new_solution[i:j])\n                break\n\n    # Step 2: Perform a random swap to explore other objectives\n    if np.random.random() < 0.3:  # 30% chance of additional swap\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 279,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * obj_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the most congested objective\n    obj_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj_values)\n\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Evaluate the swap in the worst objective space\n        if worst_obj_idx == 0:\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]])\n        elif worst_obj_idx == 1:\n            current_cost = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]])\n        else:\n            current_cost = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[i]])\n\n        if new_cost < current_cost:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Second, perform an objective-aware swap to balance the objectives\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the swap if it improves at least one objective without worsening others too much\n        if (delta_obj1 <= 0 or delta_obj2 <= 0 or delta_obj3 <= 0) and \\\n           not (delta_obj1 > 0 and delta_obj2 > 0 and delta_obj3 > 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5237727098136371,
            1.4272826433181762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * obj_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the most congested objective\n    obj_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj_values)\n\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Evaluate the swap in the worst objective space\n        if worst_obj_idx == 0:\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]])\n        elif worst_obj_idx == 1:\n            current_cost = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]])\n        else:\n            current_cost = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[i]])\n\n        if new_cost < current_cost:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Second, perform an objective-aware swap to balance the objectives\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                      distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the swap if it improves at least one objective without worsening others too much\n        if (delta_obj1 <= 0 or delta_obj2 <= 0 or delta_obj3 <= 0) and \\\n           not (delta_obj1 > 0 and delta_obj2 > 0 and delta_obj3 > 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 280,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high diversity or low cost in at least one objective)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt with a focus on improving the worst objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid modifying the start/end point\n\n        # Evaluate the current and reversed segment in all objectives\n        current_costs = [\n            sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)] + [distance_matrix_1[new_solution[-1], new_solution[0]]]),\n            sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)] + [distance_matrix_2[new_solution[-1], new_solution[0]]]),\n            sum([distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)] + [distance_matrix_3[new_solution[-1], new_solution[0]]])\n        ]\n\n        reversed_segment = new_solution.copy()\n        reversed_segment[i:j+1] = reversed_segment[i:j+1][::-1]\n\n        new_costs = [\n            sum([distance_matrix_1[reversed_segment[k], reversed_segment[k+1]] for k in range(n-1)] + [distance_matrix_1[reversed_segment[-1], reversed_segment[0]]]),\n            sum([distance_matrix_2[reversed_segment[k], reversed_segment[k+1]] for k in range(n-1)] + [distance_matrix_2[reversed_segment[-1], reversed_segment[0]]]),\n            sum([distance_matrix_3[reversed_segment[k], reversed_segment[k+1]] for k in range(n-1)] + [distance_matrix_3[reversed_segment[-1], reversed_segment[0]]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_costs[k] < current_costs[k] for k in range(3)):\n            new_solution = reversed_segment\n\n    # Additional multi-objective aware swap\n    for _ in range(5):\n        i, j = np.random.choice(range(1, n-1), 2, replace=False)\n        if i == j:\n            continue\n\n        # Evaluate the current and swapped nodes in all objectives\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[i+1]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[j+1]]\n        ]\n\n        swapped_solution = new_solution.copy()\n        swapped_solution[i], swapped_solution[j] = swapped_solution[j], swapped_solution[i]\n\n        new_costs = [\n            distance_matrix_1[swapped_solution[i-1], swapped_solution[i]] + distance_matrix_1[swapped_solution[i], swapped_solution[i+1]] +\n            distance_matrix_1[swapped_solution[j-1], swapped_solution[j]] + distance_matrix_1[swapped_solution[j], swapped_solution[j+1]],\n            distance_matrix_2[swapped_solution[i-1], swapped_solution[i]] + distance_matrix_2[swapped_solution[i], swapped_solution[i+1]] +\n            distance_matrix_2[swapped_solution[j-1], swapped_solution[j]] + distance_matrix_2[swapped_solution[j], swapped_solution[j+1]],\n            distance_matrix_3[swapped_solution[i-1], swapped_solution[i]] + distance_matrix_3[swapped_solution[i], swapped_solution[i+1]] +\n            distance_matrix_3[swapped_solution[j-1], swapped_solution[j]] + distance_matrix_3[swapped_solution[j], swapped_solution[j+1]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_costs[k] < current_costs[k] for k in range(3)):\n            new_solution = swapped_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6312012000859791,
            3.102922260761261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high diversity or low cost in at least one objective)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt with a focus on improving the worst objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid modifying the start/end point\n\n        # Evaluate the current and reversed segment in all objectives\n        current_costs = [\n            sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)] + [distance_matrix_1[new_solution[-1], new_solution[0]]]),\n            sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)] + [distance_matrix_2[new_solution[-1], new_solution[0]]]),\n            sum([distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)] + [distance_matrix_3[new_solution[-1], new_solution[0]]])\n        ]\n\n        reversed_segment = new_solution.copy()\n        reversed_segment[i:j+1] = reversed_segment[i:j+1][::-1]\n\n        new_costs = [\n            sum([distance_matrix_1[reversed_segment[k], reversed_segment[k+1]] for k in range(n-1)] + [distance_matrix_1[reversed_segment[-1], reversed_segment[0]]]),\n            sum([distance_matrix_2[reversed_segment[k], reversed_segment[k+1]] for k in range(n-1)] + [distance_matrix_2[reversed_segment[-1], reversed_segment[0]]]),\n            sum([distance_matrix_3[reversed_segment[k], reversed_segment[k+1]] for k in range(n-1)] + [distance_matrix_3[reversed_segment[-1], reversed_segment[0]]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_costs[k] < current_costs[k] for k in range(3)):\n            new_solution = reversed_segment\n\n    # Additional multi-objective aware swap\n    for _ in range(5):\n        i, j = np.random.choice(range(1, n-1), 2, replace=False)\n        if i == j:\n            continue\n\n        # Evaluate the current and swapped nodes in all objectives\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[i+1]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[j+1]]\n        ]\n\n        swapped_solution = new_solution.copy()\n        swapped_solution[i], swapped_solution[j] = swapped_solution[j], swapped_solution[i]\n\n        new_costs = [\n            distance_matrix_1[swapped_solution[i-1], swapped_solution[i]] + distance_matrix_1[swapped_solution[i], swapped_solution[i+1]] +\n            distance_matrix_1[swapped_solution[j-1], swapped_solution[j]] + distance_matrix_1[swapped_solution[j], swapped_solution[j+1]],\n            distance_matrix_2[swapped_solution[i-1], swapped_solution[i]] + distance_matrix_2[swapped_solution[i], swapped_solution[i+1]] +\n            distance_matrix_2[swapped_solution[j-1], swapped_solution[j]] + distance_matrix_2[swapped_solution[j], swapped_solution[j+1]],\n            distance_matrix_3[swapped_solution[i-1], swapped_solution[i]] + distance_matrix_3[swapped_solution[i], swapped_solution[i+1]] +\n            distance_matrix_3[swapped_solution[j-1], swapped_solution[j]] + distance_matrix_3[swapped_solution[j], swapped_solution[j+1]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_costs[k] < current_costs[k] for k in range(3)):\n            new_solution = swapped_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 281,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate ranks for each objective\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros_like(objectives)\n    for i in range(3):\n        ranks[:, i] = np.argsort(np.argsort(objectives[:, i]))\n\n    # Select solutions with best average rank that show improvement potential\n    avg_ranks = np.mean(ranks, axis=1)\n    improvement_potential = np.sum(ranks < len(archive)/2, axis=1)  # Number of objectives with potential improvement\n    candidate_indices = np.where(improvement_potential >= 2)[0]  # Solutions with potential in at least 2 objectives\n\n    if len(candidate_indices) == 0:\n        # Fallback: select solution with best average rank if no candidates with improvement potential\n        selected_idx = np.argmin(avg_ranks)\n    else:\n        # Select from candidates with best average rank\n        candidate_avg_ranks = avg_ranks[candidate_indices]\n        selected_idx = candidate_indices[np.argmin(candidate_avg_ranks)]\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to the objective with highest rank\n    obj_rank = ranks[selected_idx]\n    worst_obj = np.argmax(obj_rank)\n\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid modifying the start/end point\n\n        # Evaluate current and potential new segments\n        if worst_obj == 0:\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        elif worst_obj == 1:\n            current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n        else:\n            current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n\n        if new_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply 3-opt to improve overall solution\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if i == 0 and k == n-1:\n            continue  # Avoid modifying the start/end point\n\n        # Evaluate current and potential new segments\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[k]])\n\n        # Try all possible 3-opt configurations\n        configs = [\n            (new_solution[i:j+1][::-1], new_solution[j:k+1][::-1], new_solution[k:][::-1]),\n            (new_solution[i:j+1][::-1], new_solution[j:k+1], new_solution[k:][::-1]),\n            (new_solution[i:j+1], new_solution[j:k+1][::-1], new_solution[k:][::-1])\n        ]\n\n        best_config = None\n        best_cost = current_cost\n\n        for config in configs:\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = config[0]\n            temp_solution[j:k+1] = config[1]\n            temp_solution[k:] = config[2]\n\n            total_cost = 0\n            for m in range(n):\n                u, v = temp_solution[m-1], temp_solution[m]\n                total_cost += (distance_matrix_1[u, v] +\n                              distance_matrix_2[u, v] +\n                              distance_matrix_3[u, v])\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_config = config\n\n        if best_config:\n            new_solution[i:j+1] = best_config[0]\n            new_solution[j:k+1] = best_config[1]\n            new_solution[k:] = best_config[2]\n\n    return new_solution\n\n",
        "score": [
            -0.6849834370948968,
            2.7287108182907103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate ranks for each objective\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros_like(objectives)\n    for i in range(3):\n        ranks[:, i] = np.argsort(np.argsort(objectives[:, i]))\n\n    # Select solutions with best average rank that show improvement potential\n    avg_ranks = np.mean(ranks, axis=1)\n    improvement_potential = np.sum(ranks < len(archive)/2, axis=1)  # Number of objectives with potential improvement\n    candidate_indices = np.where(improvement_potential >= 2)[0]  # Solutions with potential in at least 2 objectives\n\n    if len(candidate_indices) == 0:\n        # Fallback: select solution with best average rank if no candidates with improvement potential\n        selected_idx = np.argmin(avg_ranks)\n    else:\n        # Select from candidates with best average rank\n        candidate_avg_ranks = avg_ranks[candidate_indices]\n        selected_idx = candidate_indices[np.argmin(candidate_avg_ranks)]\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to the objective with highest rank\n    obj_rank = ranks[selected_idx]\n    worst_obj = np.argmax(obj_rank)\n\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid modifying the start/end point\n\n        # Evaluate current and potential new segments\n        if worst_obj == 0:\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        elif worst_obj == 1:\n            current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n        else:\n            current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n\n        if new_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply 3-opt to improve overall solution\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if i == 0 and k == n-1:\n            continue  # Avoid modifying the start/end point\n\n        # Evaluate current and potential new segments\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[k]])\n\n        # Try all possible 3-opt configurations\n        configs = [\n            (new_solution[i:j+1][::-1], new_solution[j:k+1][::-1], new_solution[k:][::-1]),\n            (new_solution[i:j+1][::-1], new_solution[j:k+1], new_solution[k:][::-1]),\n            (new_solution[i:j+1], new_solution[j:k+1][::-1], new_solution[k:][::-1])\n        ]\n\n        best_config = None\n        best_cost = current_cost\n\n        for config in configs:\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = config[0]\n            temp_solution[j:k+1] = config[1]\n            temp_solution[k:] = config[2]\n\n            total_cost = 0\n            for m in range(n):\n                u, v = temp_solution[m-1], temp_solution[m]\n                total_cost += (distance_matrix_1[u, v] +\n                              distance_matrix_2[u, v] +\n                              distance_matrix_3[u, v])\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_config = config\n\n        if best_config:\n            new_solution[i:j+1] = best_config[0]\n            new_solution[j:k+1] = best_config[1]\n            new_solution[k:] = best_config[2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 282,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_candidates = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = random.randint(0, len(top_candidates) - 1)\n    base_solution = top_candidates[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with probability 0.7, otherwise use objective-aware swaps\n    if random.random() < 0.7:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware swaps: identify nodes with high potential for improvement\n        # Calculate potential improvement for each node in each objective space\n        potential_improvement = np.zeros(n)\n        for k in range(n):\n            node = new_solution[k]\n            prev_node = new_solution[k-1]\n            next_node = new_solution[(k+1) % n]\n\n            # Calculate potential improvement in each objective space\n            current_cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                            distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                            distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n\n            # Try swapping with next node\n            next_next_node = new_solution[(k+2) % n]\n            swapped_cost = (distance_matrix_1[prev_node, next_node] + distance_matrix_1[next_node, next_next_node] +\n                            distance_matrix_2[prev_node, next_node] + distance_matrix_2[next_node, next_next_node] +\n                            distance_matrix_3[prev_node, next_node] + distance_matrix_3[next_node, next_next_node])\n\n            potential_improvement[k] = current_cost - swapped_cost\n\n        # Select nodes with highest potential improvement\n        top_nodes = np.argsort(potential_improvement)[-min(3, n):]\n        for node_idx in top_nodes:\n            # Perform swap with next node\n            next_idx = (node_idx + 1) % n\n            new_solution[node_idx], new_solution[next_idx] = new_solution[next_idx], new_solution[node_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7359408424499317,
            1.1280300259590148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_candidates = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = random.randint(0, len(top_candidates) - 1)\n    base_solution = top_candidates[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with probability 0.7, otherwise use objective-aware swaps\n    if random.random() < 0.7:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware swaps: identify nodes with high potential for improvement\n        # Calculate potential improvement for each node in each objective space\n        potential_improvement = np.zeros(n)\n        for k in range(n):\n            node = new_solution[k]\n            prev_node = new_solution[k-1]\n            next_node = new_solution[(k+1) % n]\n\n            # Calculate potential improvement in each objective space\n            current_cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                            distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                            distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n\n            # Try swapping with next node\n            next_next_node = new_solution[(k+2) % n]\n            swapped_cost = (distance_matrix_1[prev_node, next_node] + distance_matrix_1[next_node, next_next_node] +\n                            distance_matrix_2[prev_node, next_node] + distance_matrix_2[next_node, next_next_node] +\n                            distance_matrix_3[prev_node, next_node] + distance_matrix_3[next_node, next_next_node])\n\n            potential_improvement[k] = current_cost - swapped_cost\n\n        # Select nodes with highest potential improvement\n        top_nodes = np.argsort(potential_improvement)[-min(3, n):]\n        for node_idx in top_nodes:\n            # Perform swap with next node\n            next_idx = (node_idx + 1) % n\n            new_solution[node_idx], new_solution[next_idx] = new_solution[next_idx], new_solution[node_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 283,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here, we select the solution with the highest average objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / 3)[0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and random swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply 2-opt to the objective with the highest variance in the archive\n    objectives = np.array([obj for (sol, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    target_obj = np.argmax(variances)\n\n    # Choose a random segment to apply 2-opt\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random swap to maintain diversity\n    if np.random.rand() < 0.5:\n        a, b = np.random.choice(range(n), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to 2-opt only\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5568182012215841,
            1.1516079783439637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here, we select the solution with the highest average objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]) / 3)[0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and random swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply 2-opt to the objective with the highest variance in the archive\n    objectives = np.array([obj for (sol, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    target_obj = np.argmax(variances)\n\n    # Choose a random segment to apply 2-opt\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random swap to maintain diversity\n    if np.random.rand() < 0.5:\n        a, b = np.random.choice(range(n), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to 2-opt only\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 284,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # We define potential as the average of the three objectives (lower is better)\n    potentials = [np.mean(obj) for _, obj in archive]\n    min_potential = min(potentials)\n    max_potential = max(potentials)\n\n    # Normalize potentials to [0, 1] and invert to favor lower values\n    normalized = [(max_potential - p) / (max_potential - min_potential) for p in potentials]\n    weights = np.array(normalized) / np.sum(normalized)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware edge swap\n    # Select two edges that are \"critical\" in at least one objective\n    def get_edge_cost(solution, i, j, distance_matrix):\n        return distance_matrix[solution[i], solution[j]] + distance_matrix[solution[j], solution[(i+1)%n]]\n\n    # Find the edge with highest cost in any objective\n    max_cost = -1\n    best_i = 0\n    for i in range(n):\n        cost1 = get_edge_cost(new_solution, i, (i+1)%n, distance_matrix_1)\n        cost2 = get_edge_cost(new_solution, i, (i+1)%n, distance_matrix_2)\n        cost3 = get_edge_cost(new_solution, i, (i+1)%n, distance_matrix_3)\n        total_cost = cost1 + cost2 + cost3\n        if total_cost > max_cost:\n            max_cost = total_cost\n            best_i = i\n\n    # Try to replace this edge with a better one\n    best_j = -1\n    best_improvement = 0\n    for j in range(n):\n        if j == best_i or j == (best_i + 1) % n:\n            continue\n\n        # Calculate potential new edges\n        new_cost1 = distance_matrix_1[new_solution[best_i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(best_i+1)%n]]\n        old_cost1 = distance_matrix_1[new_solution[best_i], new_solution[(best_i+1)%n]]\n\n        new_cost2 = distance_matrix_2[new_solution[best_i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(best_i+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[best_i], new_solution[(best_i+1)%n]]\n\n        new_cost3 = distance_matrix_3[new_solution[best_i], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(best_i+1)%n]]\n        old_cost3 = distance_matrix_3[new_solution[best_i], new_solution[(best_i+1)%n]]\n\n        improvement = (old_cost1 + old_cost2 + old_cost3) - (new_cost1 + new_cost2 + new_cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_j = j\n\n    if best_j != -1:\n        # Perform the swap\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.7547272330798696,
            1.8718074083328247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # We define potential as the average of the three objectives (lower is better)\n    potentials = [np.mean(obj) for _, obj in archive]\n    min_potential = min(potentials)\n    max_potential = max(potentials)\n\n    # Normalize potentials to [0, 1] and invert to favor lower values\n    normalized = [(max_potential - p) / (max_potential - min_potential) for p in potentials]\n    weights = np.array(normalized) / np.sum(normalized)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware edge swap\n    # Select two edges that are \"critical\" in at least one objective\n    def get_edge_cost(solution, i, j, distance_matrix):\n        return distance_matrix[solution[i], solution[j]] + distance_matrix[solution[j], solution[(i+1)%n]]\n\n    # Find the edge with highest cost in any objective\n    max_cost = -1\n    best_i = 0\n    for i in range(n):\n        cost1 = get_edge_cost(new_solution, i, (i+1)%n, distance_matrix_1)\n        cost2 = get_edge_cost(new_solution, i, (i+1)%n, distance_matrix_2)\n        cost3 = get_edge_cost(new_solution, i, (i+1)%n, distance_matrix_3)\n        total_cost = cost1 + cost2 + cost3\n        if total_cost > max_cost:\n            max_cost = total_cost\n            best_i = i\n\n    # Try to replace this edge with a better one\n    best_j = -1\n    best_improvement = 0\n    for j in range(n):\n        if j == best_i or j == (best_i + 1) % n:\n            continue\n\n        # Calculate potential new edges\n        new_cost1 = distance_matrix_1[new_solution[best_i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(best_i+1)%n]]\n        old_cost1 = distance_matrix_1[new_solution[best_i], new_solution[(best_i+1)%n]]\n\n        new_cost2 = distance_matrix_2[new_solution[best_i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(best_i+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[best_i], new_solution[(best_i+1)%n]]\n\n        new_cost3 = distance_matrix_3[new_solution[best_i], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(best_i+1)%n]]\n        old_cost3 = distance_matrix_3[new_solution[best_i], new_solution[(best_i+1)%n]]\n\n        improvement = (old_cost1 + old_cost2 + old_cost3) - (new_cost1 + new_cost2 + new_cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_j = j\n\n    if best_j != -1:\n        # Perform the swap\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 285,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge selection: prioritize edges that improve at least one objective\n    for _ in range(10):  # Limit the number of attempts to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate current and new edge costs for all three objectives\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        current_costs = [\n            distance_matrix_1[current_edges[0][0], current_edges[0][1]] + distance_matrix_1[current_edges[1][0], current_edges[1][1]],\n            distance_matrix_2[current_edges[0][0], current_edges[0][1]] + distance_matrix_2[current_edges[1][0], current_edges[1][1]],\n            distance_matrix_3[current_edges[0][0], current_edges[0][1]] + distance_matrix_3[current_edges[1][0], current_edges[1][1]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n            distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]],\n            distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]]\n        ]\n\n        # Check if at least one objective improves\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            # Perform 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Additional improvement: try to swap nodes that are far apart in at least one objective space\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Check if swapping i and j improves at least one objective\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7707294287840947,
            1.0692439317703246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge selection: prioritize edges that improve at least one objective\n    for _ in range(10):  # Limit the number of attempts to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate current and new edge costs for all three objectives\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        current_costs = [\n            distance_matrix_1[current_edges[0][0], current_edges[0][1]] + distance_matrix_1[current_edges[1][0], current_edges[1][1]],\n            distance_matrix_2[current_edges[0][0], current_edges[0][1]] + distance_matrix_2[current_edges[1][0], current_edges[1][1]],\n            distance_matrix_3[current_edges[0][0], current_edges[0][1]] + distance_matrix_3[current_edges[1][0], current_edges[1][1]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n            distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]],\n            distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]]\n        ]\n\n        # Check if at least one objective improves\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            # Perform 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Additional improvement: try to swap nodes that are far apart in at least one objective space\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Check if swapping i and j improves at least one objective\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 286,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate potential for each solution (inverse of average objective value)\n        potentials = [1.0 / (np.mean(obj) + 1e-6) for _, obj in archive]\n        probabilities = np.array(potentials) / np.sum(potentials)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n\n    # Apply a 3-opt move that considers all three objectives\n    def calculate_3opt_cost(solution, i, j, k):\n        # Original edges\n        orig_edges = [\n            (solution[i-1], solution[i]),\n            (solution[j-1], solution[j]),\n            (solution[k-1], solution[k])\n        ]\n\n        # New edges\n        new_edges = [\n            (solution[i-1], solution[j]),\n            (solution[j-1], solution[k]),\n            (solution[k-1], solution[i])\n        ]\n\n        # Calculate cost for all three objectives\n        cost1 = sum(distance_matrix_1[a][b] for a, b in orig_edges) - sum(distance_matrix_1[a][b] for a, b in new_edges)\n        cost2 = sum(distance_matrix_2[a][b] for a, b in orig_edges) - sum(distance_matrix_2[a][b] for a, b in new_edges)\n        cost3 = sum(distance_matrix_3[a][b] for a, b in orig_edges) - sum(distance_matrix_3[a][b] for a, b in new_edges)\n\n        return cost1, cost2, cost3\n\n    # Try different orderings of the 3-opt move\n    orderings = [\n        (i, j, k),\n        (i, k, j),\n        (j, i, k),\n        (j, k, i),\n        (k, i, j),\n        (k, j, i)\n    ]\n\n    best_cost = float('inf')\n    best_ordering = None\n\n    for ordering in orderings:\n        cost1, cost2, cost3 = calculate_3opt_cost(base_solution, *ordering)\n        total_cost = cost1 + cost2 + cost3  # Simple aggregation for selection\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_ordering = ordering\n\n    if best_ordering is not None:\n        # Apply the best 3-opt move\n        i, j, k = best_ordering\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:k][::-1],\n            base_solution[k:j][::-1],\n            base_solution[j:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.5739066682091758,
            1.9086599469184875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate potential for each solution (inverse of average objective value)\n        potentials = [1.0 / (np.mean(obj) + 1e-6) for _, obj in archive]\n        probabilities = np.array(potentials) / np.sum(potentials)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n\n    # Apply a 3-opt move that considers all three objectives\n    def calculate_3opt_cost(solution, i, j, k):\n        # Original edges\n        orig_edges = [\n            (solution[i-1], solution[i]),\n            (solution[j-1], solution[j]),\n            (solution[k-1], solution[k])\n        ]\n\n        # New edges\n        new_edges = [\n            (solution[i-1], solution[j]),\n            (solution[j-1], solution[k]),\n            (solution[k-1], solution[i])\n        ]\n\n        # Calculate cost for all three objectives\n        cost1 = sum(distance_matrix_1[a][b] for a, b in orig_edges) - sum(distance_matrix_1[a][b] for a, b in new_edges)\n        cost2 = sum(distance_matrix_2[a][b] for a, b in orig_edges) - sum(distance_matrix_2[a][b] for a, b in new_edges)\n        cost3 = sum(distance_matrix_3[a][b] for a, b in orig_edges) - sum(distance_matrix_3[a][b] for a, b in new_edges)\n\n        return cost1, cost2, cost3\n\n    # Try different orderings of the 3-opt move\n    orderings = [\n        (i, j, k),\n        (i, k, j),\n        (j, i, k),\n        (j, k, i),\n        (k, i, j),\n        (k, j, i)\n    ]\n\n    best_cost = float('inf')\n    best_ordering = None\n\n    for ordering in orderings:\n        cost1, cost2, cost3 = calculate_3opt_cost(base_solution, *ordering)\n        total_cost = cost1 + cost2 + cost3  # Simple aggregation for selection\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_ordering = ordering\n\n    if best_ordering is not None:\n        # Apply the best 3-opt move\n        i, j, k = best_ordering\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:k][::-1],\n            base_solution[k:j][::-1],\n            base_solution[j:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 287,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    num_nodes = len(base_solution)\n    for _ in range(min(10, num_nodes // 2)):  # Limit number of operations\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(num_nodes), 2))\n\n        # 2-opt move (swap edges)\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: find nodes that improve at least one objective\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate current and potential costs\n            current_cost = (\n                distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%num_nodes]],\n                distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%num_nodes]],\n                distance_matrix_3[new_solution[i-1], node_i] + distance_matrix_3[node_i, new_solution[(i+1)%num_nodes]]\n            )\n\n            new_cost = (\n                distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%num_nodes]],\n                distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%num_nodes]],\n                distance_matrix_3[new_solution[i-1], node_j] + distance_matrix_3[node_j, new_solution[(i+1)%num_nodes]]\n            )\n\n            # Accept if at least one objective improves\n            if any(new_cost[k] < current_cost[k] for k in range(3)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates and covers all nodes)\n    assert len(new_solution) == len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.773474620050569,
            0.8974485039710999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    num_nodes = len(base_solution)\n    for _ in range(min(10, num_nodes // 2)):  # Limit number of operations\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(num_nodes), 2))\n\n        # 2-opt move (swap edges)\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: find nodes that improve at least one objective\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate current and potential costs\n            current_cost = (\n                distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%num_nodes]],\n                distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%num_nodes]],\n                distance_matrix_3[new_solution[i-1], node_i] + distance_matrix_3[node_i, new_solution[(i+1)%num_nodes]]\n            )\n\n            new_cost = (\n                distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%num_nodes]],\n                distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%num_nodes]],\n                distance_matrix_3[new_solution[i-1], node_j] + distance_matrix_3[node_j, new_solution[(i+1)%num_nodes]]\n            )\n\n            # Accept if at least one objective improves\n            if any(new_cost[k] < current_cost[k] for k in range(3)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates and covers all nodes)\n    assert len(new_solution) == len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 288,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # Standard 2-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Objective-aware swap: identify nodes that are outliers in any objective space\n    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the node with maximum distance in this objective space\n        max_dist_node = None\n        max_dist = -1\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            current_dist = dist_matrix[prev, curr] + dist_matrix[curr, next_node]\n            if current_dist > max_dist:\n                max_dist = current_dist\n                max_dist_node = i\n\n        if max_dist_node is not None:\n            # Swap with a random node to potentially improve this objective\n            swap_with = np.random.randint(n)\n            while swap_with == max_dist_node:\n                swap_with = np.random.randint(n)\n            new_solution[max_dist_node], new_solution[swap_with] = new_solution[swap_with], new_solution[max_dist_node]\n\n    return new_solution\n\n",
        "score": [
            -0.7175694267197953,
            0.6494189858436584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # Standard 2-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Objective-aware swap: identify nodes that are outliers in any objective space\n    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the node with maximum distance in this objective space\n        max_dist_node = None\n        max_dist = -1\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            current_dist = dist_matrix[prev, curr] + dist_matrix[curr, next_node]\n            if current_dist > max_dist:\n                max_dist = current_dist\n                max_dist_node = i\n\n        if max_dist_node is not None:\n            # Swap with a random node to potentially improve this objective\n            swap_with = np.random.randint(n)\n            while swap_with == max_dist_node:\n                swap_with = np.random.randint(n)\n            new_solution[max_dist_node], new_solution[swap_with] = new_solution[swap_with], new_solution[max_dist_node]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 289,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 5:\n        # Combine objectives and sort by their sum (could use other metrics like Pareto dominance)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        selected_archive = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    else:\n        selected_archive = archive\n\n    # Randomly select a base solution from the top candidates\n    base_solution, _ = random.choice(selected_archive)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and node insertion\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly choose a segment to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Apply 2-opt move\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Apply node insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7061791440536511,
            1.6243096232414245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 5:\n        # Combine objectives and sort by their sum (could use other metrics like Pareto dominance)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        selected_archive = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    else:\n        selected_archive = archive\n\n    # Randomly select a base solution from the top candidates\n    base_solution, _ = random.choice(selected_archive)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and node insertion\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly choose a segment to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Apply 2-opt move\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Apply node insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 290,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution in the archive\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select a solution with high crowding distance (indicating potential for improvement)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Determine which objective to prioritize based on the solution's position in the archive\n    if len(archive) > 1:\n        obj = archive[selected_idx][1]\n        total_obj = sum(obj)\n        if total_obj > 0:\n            # Prioritize the objective with the highest relative value\n            obj_weights = [o / total_obj for o in obj]\n            obj_choice = np.random.choice(3, p=obj_weights)\n        else:\n            obj_choice = np.random.randint(3)\n    else:\n        obj_choice = np.random.randint(3)\n\n    # Apply a distance-aware 2-opt move based on the chosen objective\n    if obj_choice == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt swap\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler swap\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5212764325194381,
            2.194251501560211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution in the archive\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select a solution with high crowding distance (indicating potential for improvement)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Determine which objective to prioritize based on the solution's position in the archive\n    if len(archive) > 1:\n        obj = archive[selected_idx][1]\n        total_obj = sum(obj)\n        if total_obj > 0:\n            # Prioritize the objective with the highest relative value\n            obj_weights = [o / total_obj for o in obj]\n            obj_choice = np.random.choice(3, p=obj_weights)\n        else:\n            obj_choice = np.random.randint(3)\n    else:\n        obj_choice = np.random.randint(3)\n\n    # Apply a distance-aware 2-opt move based on the chosen objective\n    if obj_choice == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt swap\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler swap\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 291,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher than average objectives)\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = np.mean([obj[0] for obj in objectives])\n    avg_obj2 = np.mean([obj[1] for obj in objectives])\n    avg_obj3 = np.mean([obj[2] for obj in objectives])\n\n    candidates = [sol for sol, obj in archive if obj[0] > avg_obj1 or obj[1] > avg_obj2 or obj[2] > avg_obj3]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between 2-opt and objective-aware swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware swap: prioritize swaps that improve the worst objective\n        worst_obj_index = np.argmax(archive[np.where([np.array_equal(sol, base_solution) for sol, _ in archive])[0][0]][1])\n\n        for _ in range(10):  # Try multiple swaps\n            i, j = random.sample(range(n), 2)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            # Calculate the change in the worst objective\n            old_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                        distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                        distance_matrix_1[base_solution[j-1], base_solution[j]] +\n                        distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n\n            new_cost = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                        distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                        distance_matrix_1[temp_solution[j-1], temp_solution[j]] +\n                        distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]])\n\n            if worst_obj_index == 0 and new_cost < old_cost:\n                new_solution = temp_solution\n                break\n            elif worst_obj_index == 1:\n                old_cost = (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                            distance_matrix_2[base_solution[j-1], base_solution[j]] +\n                            distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                new_cost = (distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                            distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] +\n                            distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                            distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]])\n                if new_cost < old_cost:\n                    new_solution = temp_solution\n                    break\n            elif worst_obj_index == 2:\n                old_cost = (distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_3[base_solution[i], base_solution[(i+1)%n]] +\n                            distance_matrix_3[base_solution[j-1], base_solution[j]] +\n                            distance_matrix_3[base_solution[j], base_solution[(j+1)%n]])\n                new_cost = (distance_matrix_3[temp_solution[i-1], temp_solution[i]] +\n                            distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] +\n                            distance_matrix_3[temp_solution[j-1], temp_solution[j]] +\n                            distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]])\n                if new_cost < old_cost:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8098720657578605,
            1.4810129880905152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher than average objectives)\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = np.mean([obj[0] for obj in objectives])\n    avg_obj2 = np.mean([obj[1] for obj in objectives])\n    avg_obj3 = np.mean([obj[2] for obj in objectives])\n\n    candidates = [sol for sol, obj in archive if obj[0] > avg_obj1 or obj[1] > avg_obj2 or obj[2] > avg_obj3]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between 2-opt and objective-aware swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware swap: prioritize swaps that improve the worst objective\n        worst_obj_index = np.argmax(archive[np.where([np.array_equal(sol, base_solution) for sol, _ in archive])[0][0]][1])\n\n        for _ in range(10):  # Try multiple swaps\n            i, j = random.sample(range(n), 2)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            # Calculate the change in the worst objective\n            old_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                        distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                        distance_matrix_1[base_solution[j-1], base_solution[j]] +\n                        distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n\n            new_cost = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                        distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                        distance_matrix_1[temp_solution[j-1], temp_solution[j]] +\n                        distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]])\n\n            if worst_obj_index == 0 and new_cost < old_cost:\n                new_solution = temp_solution\n                break\n            elif worst_obj_index == 1:\n                old_cost = (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                            distance_matrix_2[base_solution[j-1], base_solution[j]] +\n                            distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                new_cost = (distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                            distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] +\n                            distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                            distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]])\n                if new_cost < old_cost:\n                    new_solution = temp_solution\n                    break\n            elif worst_obj_index == 2:\n                old_cost = (distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_3[base_solution[i], base_solution[(i+1)%n]] +\n                            distance_matrix_3[base_solution[j-1], base_solution[j]] +\n                            distance_matrix_3[base_solution[j], base_solution[(j+1)%n]])\n                new_cost = (distance_matrix_3[temp_solution[i-1], temp_solution[i]] +\n                            distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] +\n                            distance_matrix_3[temp_solution[j-1], temp_solution[j]] +\n                            distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]])\n                if new_cost < old_cost:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 292,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate the total distance for each objective\n    def calculate_total_distance(solution, distance_matrix):\n        total = 0.0\n        for i in range(len(solution)):\n            total += distance_matrix[solution[i-1], solution[i]]\n        return total\n\n    current_distances = (\n        calculate_total_distance(base_solution, distance_matrix_1),\n        calculate_total_distance(base_solution, distance_matrix_2),\n        calculate_total_distance(base_solution, distance_matrix_3)\n    )\n\n    # Hybrid local search strategy combining 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the objective with the highest current distance\n    worst_obj = np.argmax(current_distances)\n\n    # Select two random edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Create new solution with edge swaps\n    if worst_obj == 0:\n        # For first objective, perform standard 2-opt\n        new_solution = np.concatenate((new_solution[:i], new_solution[j:k+1][::-1], new_solution[l:]))\n    else:\n        # For other objectives, perform edge exchange\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    # Additional improvement: try to optimize the worst objective further\n    if worst_obj == 0:\n        # For first objective, try to find a better 2-opt move\n        for _ in range(10):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            candidate = new_solution.copy()\n            candidate[a:b+1] = candidate[a:b+1][::-1]\n            if calculate_total_distance(candidate, distance_matrix_1) < current_distances[0]:\n                new_solution = candidate\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7075988171886942,
            1.4108182787895203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate the total distance for each objective\n    def calculate_total_distance(solution, distance_matrix):\n        total = 0.0\n        for i in range(len(solution)):\n            total += distance_matrix[solution[i-1], solution[i]]\n        return total\n\n    current_distances = (\n        calculate_total_distance(base_solution, distance_matrix_1),\n        calculate_total_distance(base_solution, distance_matrix_2),\n        calculate_total_distance(base_solution, distance_matrix_3)\n    )\n\n    # Hybrid local search strategy combining 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the objective with the highest current distance\n    worst_obj = np.argmax(current_distances)\n\n    # Select two random edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Create new solution with edge swaps\n    if worst_obj == 0:\n        # For first objective, perform standard 2-opt\n        new_solution = np.concatenate((new_solution[:i], new_solution[j:k+1][::-1], new_solution[l:]))\n    else:\n        # For other objectives, perform edge exchange\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    # Additional improvement: try to optimize the worst objective further\n    if worst_obj == 0:\n        # For first objective, try to find a better 2-opt move\n        for _ in range(10):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            candidate = new_solution.copy()\n            candidate[a:b+1] = candidate[a:b+1][::-1]\n            if calculate_total_distance(candidate, distance_matrix_1) < current_distances[0]:\n                new_solution = candidate\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 293,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to improve the most underperforming objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        # Improve first objective by finding the best swap in distance_matrix_1\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                # Calculate potential improvement\n                old_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]])\n                new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[a]])\n                improvement = old_dist - new_dist\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    elif worst_obj == 1:\n        # Improve second objective by finding the best swap in distance_matrix_2\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                old_dist = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[b]])\n                new_dist = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[a]])\n                improvement = old_dist - new_dist\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    else:\n        # Improve third objective by finding the best swap in distance_matrix_3\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                old_dist = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_3[new_solution[b-1], new_solution[b]])\n                new_dist = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_3[new_solution[b-1], new_solution[a]])\n                improvement = old_dist - new_dist\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7695079626377609,
            1.688178336620331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to improve the most underperforming objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        # Improve first objective by finding the best swap in distance_matrix_1\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                # Calculate potential improvement\n                old_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]])\n                new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[a]])\n                improvement = old_dist - new_dist\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    elif worst_obj == 1:\n        # Improve second objective by finding the best swap in distance_matrix_2\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                old_dist = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[b]])\n                new_dist = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[a]])\n                improvement = old_dist - new_dist\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    else:\n        # Improve third objective by finding the best swap in distance_matrix_3\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                old_dist = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_3[new_solution[b-1], new_solution[b]])\n                new_dist = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_3[new_solution[b-1], new_solution[a]])\n                improvement = old_dist - new_dist\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 294,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives (higher sum indicates more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select from top 30% of solutions\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and 3-opt with probability based on archive size\n        if random.random() < 0.7 or len(archive) < 5:\n            # 2-opt move (better for local refinement)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move (more disruptive, better for escaping local optima)\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Apply 3-opt operation (cyclic permutation)\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6247650119096562,
            0.8943202376365662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives (higher sum indicates more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select from top 30% of solutions\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and 3-opt with probability based on archive size\n        if random.random() < 0.7 or len(archive) < 5:\n            # 2-opt move (better for local refinement)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move (more disruptive, better for escaping local optima)\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Apply 3-opt operation (cyclic permutation)\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 295,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the lowest combined objective values as candidates\n    candidates = sorted(archive, key=lambda x: sum(x[1]))[:max(3, len(archive) // 5)]\n    selected = random.choice(candidates)[0].copy()\n\n    # Hybrid local search strategy\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # 1. Multi-objective 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Objective-aware node insertion\n    if random.random() < 0.3:  # 30% chance for this operation\n        k = random.randint(0, n-1)\n        l = (k + random.randint(1, n-1)) % n\n        if k > l:\n            k, l = l, k\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l], [node], new_solution[l:]])\n\n    # 3. Objective-aware swap based on worst objective\n    if random.random() < 0.5:  # 50% chance for this operation\n        # Calculate current objectives\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Identify worst objective\n        worst_obj = np.argmax([obj1, obj2, obj3])\n        if worst_obj == 0:\n            mat = distance_matrix_1\n        elif worst_obj == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find best swap to improve worst objective\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+2, n):\n                if b == (a + 1) % n:\n                    continue\n                # Calculate improvement if we swap a and b\n                old_dist = (mat[new_solution[a], new_solution[(a+1)%n]] +\n                           mat[new_solution[b], new_solution[(b+1)%n]])\n                new_dist = (mat[new_solution[a], new_solution[b]] +\n                           mat[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n                improvement = old_dist - new_dist\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n\n        if best_swap is not None:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7978109144795924,
            1.2665311813354492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the lowest combined objective values as candidates\n    candidates = sorted(archive, key=lambda x: sum(x[1]))[:max(3, len(archive) // 5)]\n    selected = random.choice(candidates)[0].copy()\n\n    # Hybrid local search strategy\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # 1. Multi-objective 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Objective-aware node insertion\n    if random.random() < 0.3:  # 30% chance for this operation\n        k = random.randint(0, n-1)\n        l = (k + random.randint(1, n-1)) % n\n        if k > l:\n            k, l = l, k\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l], [node], new_solution[l:]])\n\n    # 3. Objective-aware swap based on worst objective\n    if random.random() < 0.5:  # 50% chance for this operation\n        # Calculate current objectives\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Identify worst objective\n        worst_obj = np.argmax([obj1, obj2, obj3])\n        if worst_obj == 0:\n            mat = distance_matrix_1\n        elif worst_obj == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find best swap to improve worst objective\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+2, n):\n                if b == (a + 1) % n:\n                    continue\n                # Calculate improvement if we swap a and b\n                old_dist = (mat[new_solution[a], new_solution[(a+1)%n]] +\n                           mat[new_solution[b], new_solution[(b+1)%n]])\n                new_dist = (mat[new_solution[a], new_solution[b]] +\n                           mat[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n                improvement = old_dist - new_dist\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n\n        if best_swap is not None:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 296,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt move (for one objective)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge exchange (for another objective)\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    if k != l and l != k+1 and abs(k-l) > 1:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the tour is valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.682274114416322,
            1.0853398084640502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt move (for one objective)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge exchange (for another objective)\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    if k != l and l != k+1 and abs(k-l) > 1:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the tour is valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 297,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective variance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        variances = np.var(objectives, axis=1)\n        # Select solutions with highest variance (more potential for improvement)\n        candidate_indices = np.argsort(variances)[-max(2, len(archive)//2):]\n        selected_index = random.choice(candidate_indices)\n        base_solution = archive[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware perturbations\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or 3-opt based on objective diversity\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt: Select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt: Select three edges and try to improve the tour\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            # Try different configurations\n            options = [\n                np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]]),\n                np.concatenate([new_solution[:i], segment1[::-1], segment2, new_solution[k:]]),\n                np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]]),\n                np.concatenate([new_solution[:i], segment2, segment1[::-1], new_solution[k:]]),\n                np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]]),\n                np.concatenate([new_solution[:i], segment2[::-1], segment1[::-1], new_solution[k:]])\n            ]\n            # Evaluate all options in all three objectives\n            current_costs = [\n                sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n                sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n                sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n            ]\n            best_option = new_solution.copy()\n            best_improvement = 0\n            for option in options:\n                option_costs = [\n                    sum(distance_matrix_1[option[i-1], option[i]] for i in range(n)),\n                    sum(distance_matrix_2[option[i-1], option[i]] for i in range(n)),\n                    sum(distance_matrix_3[option[i-1], option[i]] for i in range(n))\n                ]\n                # Calculate improvement in all objectives\n                improvement = sum((current_costs[i] - option_costs[i]) for i in range(3))\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_option = option.copy()\n            new_solution = best_option\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.5758696104547104,
            1.3048433184623718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective variance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        variances = np.var(objectives, axis=1)\n        # Select solutions with highest variance (more potential for improvement)\n        candidate_indices = np.argsort(variances)[-max(2, len(archive)//2):]\n        selected_index = random.choice(candidate_indices)\n        base_solution = archive[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware perturbations\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or 3-opt based on objective diversity\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt: Select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt: Select three edges and try to improve the tour\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            # Try different configurations\n            options = [\n                np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]]),\n                np.concatenate([new_solution[:i], segment1[::-1], segment2, new_solution[k:]]),\n                np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]]),\n                np.concatenate([new_solution[:i], segment2, segment1[::-1], new_solution[k:]]),\n                np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]]),\n                np.concatenate([new_solution[:i], segment2[::-1], segment1[::-1], new_solution[k:]])\n            ]\n            # Evaluate all options in all three objectives\n            current_costs = [\n                sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n                sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n                sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n            ]\n            best_option = new_solution.copy()\n            best_improvement = 0\n            for option in options:\n                option_costs = [\n                    sum(distance_matrix_1[option[i-1], option[i]] for i in range(n)),\n                    sum(distance_matrix_2[option[i-1], option[i]] for i in range(n)),\n                    sum(distance_matrix_3[option[i-1], option[i]] for i in range(n))\n                ]\n                # Calculate improvement in all objectives\n                improvement = sum((current_costs[i] - option_costs[i]) for i in range(3))\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_option = option.copy()\n            new_solution = best_option\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 298,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across all three objectives\n    best_solution = archive[0][0].copy()\n    best_score = sum(archive[0][1])\n\n    for sol, obj in archive[1:]:\n        current_score = sum(obj)\n        if current_score < best_score:\n            best_solution = sol.copy()\n            best_score = current_score\n\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a 2-opt move or a 3-opt move based on objective improvement\n        # Calculate current total distance across all three objectives\n        def total_distance(sol):\n            dist1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            dist2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            dist3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n            return dist1 + dist2 + dist3\n\n        current_dist = total_distance(new_solution)\n\n        # Try a 2-opt move\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        if total_distance(candidate) < current_dist:\n            new_solution = candidate\n        else:\n            # If 2-opt didn't improve, try a 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n            candidate[j:k+1] = candidate[j:k+1][::-1]\n\n            if total_distance(candidate) < current_dist:\n                new_solution = candidate\n            else:\n                # If neither improved, just perform a random 2-opt move\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6561095474961117,
            0.8549617171287537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across all three objectives\n    best_solution = archive[0][0].copy()\n    best_score = sum(archive[0][1])\n\n    for sol, obj in archive[1:]:\n        current_score = sum(obj)\n        if current_score < best_score:\n            best_solution = sol.copy()\n            best_score = current_score\n\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a 2-opt move or a 3-opt move based on objective improvement\n        # Calculate current total distance across all three objectives\n        def total_distance(sol):\n            dist1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            dist2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            dist3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n            return dist1 + dist2 + dist3\n\n        current_dist = total_distance(new_solution)\n\n        # Try a 2-opt move\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        if total_distance(candidate) < current_dist:\n            new_solution = candidate\n        else:\n            # If 2-opt didn't improve, try a 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n            candidate[j:k+1] = candidate[j:k+1][::-1]\n\n            if total_distance(candidate) < current_dist:\n                new_solution = candidate\n            else:\n                # If neither improved, just perform a random 2-opt move\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 299,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    normalized_objectives = objectives / avg_objectives\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt (standard local search)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform objective-aware swaps (custom heuristic for multi-objective optimization)\n    for _ in range(5):\n        # Select two nodes with high potential for improvement in any objective\n        node_a, node_b = np.random.choice(n, 2, replace=False)\n        a_pos = np.where(new_solution == node_a)[0][0]\n        b_pos = np.where(new_solution == node_b)[0][0]\n\n        # Calculate potential improvement in all three objectives\n        delta_1 = (distance_matrix_1[new_solution[(a_pos-1)%n], node_b] +\n                   distance_matrix_1[node_b, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_1[new_solution[(b_pos-1)%n], node_a] +\n                   distance_matrix_1[node_a, new_solution[(b_pos+1)%n]]) - \\\n                  (distance_matrix_1[new_solution[(a_pos-1)%n], node_a] +\n                   distance_matrix_1[node_a, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_1[new_solution[(b_pos-1)%n], node_b] +\n                   distance_matrix_1[node_b, new_solution[(b_pos+1)%n]])\n\n        delta_2 = (distance_matrix_2[new_solution[(a_pos-1)%n], node_b] +\n                   distance_matrix_2[node_b, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_2[new_solution[(b_pos-1)%n], node_a] +\n                   distance_matrix_2[node_a, new_solution[(b_pos+1)%n]]) - \\\n                  (distance_matrix_2[new_solution[(a_pos-1)%n], node_a] +\n                   distance_matrix_2[node_a, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_2[new_solution[(b_pos-1)%n], node_b] +\n                   distance_matrix_2[node_b, new_solution[(b_pos+1)%n]])\n\n        delta_3 = (distance_matrix_3[new_solution[(a_pos-1)%n], node_b] +\n                   distance_matrix_3[node_b, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_3[new_solution[(b_pos-1)%n], node_a] +\n                   distance_matrix_3[node_a, new_solution[(b_pos+1)%n]]) - \\\n                  (distance_matrix_3[new_solution[(a_pos-1)%n], node_a] +\n                   distance_matrix_3[node_a, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_3[new_solution[(b_pos-1)%n], node_b] +\n                   distance_matrix_3[node_b, new_solution[(b_pos+1)%n]])\n\n        # Accept swap if it improves at least one objective\n        if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n            new_solution[a_pos], new_solution[b_pos] = new_solution[b_pos], new_solution[a_pos]\n\n    return new_solution\n\n",
        "score": [
            -0.6961890688971436,
            1.9365700960159302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    normalized_objectives = objectives / avg_objectives\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt (standard local search)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform objective-aware swaps (custom heuristic for multi-objective optimization)\n    for _ in range(5):\n        # Select two nodes with high potential for improvement in any objective\n        node_a, node_b = np.random.choice(n, 2, replace=False)\n        a_pos = np.where(new_solution == node_a)[0][0]\n        b_pos = np.where(new_solution == node_b)[0][0]\n\n        # Calculate potential improvement in all three objectives\n        delta_1 = (distance_matrix_1[new_solution[(a_pos-1)%n], node_b] +\n                   distance_matrix_1[node_b, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_1[new_solution[(b_pos-1)%n], node_a] +\n                   distance_matrix_1[node_a, new_solution[(b_pos+1)%n]]) - \\\n                  (distance_matrix_1[new_solution[(a_pos-1)%n], node_a] +\n                   distance_matrix_1[node_a, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_1[new_solution[(b_pos-1)%n], node_b] +\n                   distance_matrix_1[node_b, new_solution[(b_pos+1)%n]])\n\n        delta_2 = (distance_matrix_2[new_solution[(a_pos-1)%n], node_b] +\n                   distance_matrix_2[node_b, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_2[new_solution[(b_pos-1)%n], node_a] +\n                   distance_matrix_2[node_a, new_solution[(b_pos+1)%n]]) - \\\n                  (distance_matrix_2[new_solution[(a_pos-1)%n], node_a] +\n                   distance_matrix_2[node_a, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_2[new_solution[(b_pos-1)%n], node_b] +\n                   distance_matrix_2[node_b, new_solution[(b_pos+1)%n]])\n\n        delta_3 = (distance_matrix_3[new_solution[(a_pos-1)%n], node_b] +\n                   distance_matrix_3[node_b, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_3[new_solution[(b_pos-1)%n], node_a] +\n                   distance_matrix_3[node_a, new_solution[(b_pos+1)%n]]) - \\\n                  (distance_matrix_3[new_solution[(a_pos-1)%n], node_a] +\n                   distance_matrix_3[node_a, new_solution[(a_pos+1)%n]] +\n                   distance_matrix_3[new_solution[(b_pos-1)%n], node_b] +\n                   distance_matrix_3[node_b, new_solution[(b_pos+1)%n]])\n\n        # Accept swap if it improves at least one objective\n        if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n            new_solution[a_pos], new_solution[b_pos] = new_solution[b_pos], new_solution[a_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 300,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weights = objective_variances / np.sum(objective_variances)  # Normalize weights\n\n    # Randomly select a solution with probability proportional to its objective variance\n    probabilities = np.array([np.dot(weights, obj) for _, obj in archive])\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or segment reversal\n    if np.random.rand() < 0.5:\n        # 2-opt: reverse a random segment\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment reversal: reverse a random segment and then apply 2-opt\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        k, l = sorted(np.random.choice(n, size=2, replace=False))\n        if k < l:\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7899378272132106,
            1.814945125579834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weights = objective_variances / np.sum(objective_variances)  # Normalize weights\n\n    # Randomly select a solution with probability proportional to its objective variance\n    probabilities = np.array([np.dot(weights, obj) for _, obj in archive])\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or segment reversal\n    if np.random.rand() < 0.5:\n        # 2-opt: reverse a random segment\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment reversal: reverse a random segment and then apply 2-opt\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        k, l = sorted(np.random.choice(n, size=2, replace=False))\n        if k < l:\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    }
]