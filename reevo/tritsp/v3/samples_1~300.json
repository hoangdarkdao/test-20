[
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement in all three objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            # Perform 2-opt swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional objective-aware 2-opt\n    for _ in range(5):\n        # Select a segment to reverse based on the most improved objective\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] -\n             distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] -\n             distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]] -\n             distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Accept if the best objective improves\n        if max(improvements) > 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7693182207225816,
            2.8199588894844054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement in all three objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            # Perform 2-opt swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional objective-aware 2-opt\n    for _ in range(5):\n        # Select a segment to reverse based on the most improved objective\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] -\n             distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] -\n             distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]] -\n             distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Accept if the best objective improves\n        if max(improvements) > 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement in all three objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            # Perform 2-opt swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional objective-aware 2-opt\n    for _ in range(5):\n        # Select a segment to reverse based on the most improved objective\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] -\n             distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] -\n             distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]] -\n             distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Accept if the best objective improves\n        if max(improvements) > 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7693182207225816,
            2.8199588894844054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement in all three objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            # Perform 2-opt swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional objective-aware 2-opt\n    for _ in range(5):\n        # Select a segment to reverse based on the most improved objective\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] -\n             distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] -\n             distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]] -\n             distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Accept if the best objective improves\n        if max(improvements) > 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement in all three objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            # Perform 2-opt swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional objective-aware 2-opt\n    for _ in range(5):\n        # Select a segment to reverse based on the most improved objective\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] -\n             distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] -\n             distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]] -\n             distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Accept if the best objective improves\n        if max(improvements) > 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7693182207225816,
            2.8199588894844054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement in all three objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            # Perform 2-opt swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional objective-aware 2-opt\n    for _ in range(5):\n        # Select a segment to reverse based on the most improved objective\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] -\n             distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] -\n             distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]] -\n             distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Accept if the best objective improves\n        if max(improvements) > 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher costs)\n    objectives = [obj for (_, obj) in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    selected_indices = []\n\n    # Select solutions that are above average in at least one objective\n    for i, obj in enumerate(objectives):\n        if any(obj[j] > avg_objectives[j] for j in range(3)):\n            selected_indices.append(i)\n\n    if not selected_indices:\n        selected_indices = [np.random.randint(0, len(archive))]\n\n    selected_idx = np.random.choice(selected_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap (reverses a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform objective-aware swap (based on the worst objective)\n    obj = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj)\n\n    if worst_obj_idx == 0:\n        # If first objective is worst, swap edges that might reduce distance in space 1\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif worst_obj_idx == 1:\n        # If second objective is worst, swap edges that might reduce distance in space 2\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If third objective is worst, swap edges that might reduce distance in space 3\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7395689705840038,
            1.6099295020103455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher costs)\n    objectives = [obj for (_, obj) in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    selected_indices = []\n\n    # Select solutions that are above average in at least one objective\n    for i, obj in enumerate(objectives):\n        if any(obj[j] > avg_objectives[j] for j in range(3)):\n            selected_indices.append(i)\n\n    if not selected_indices:\n        selected_indices = [np.random.randint(0, len(archive))]\n\n    selected_idx = np.random.choice(selected_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap (reverses a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform objective-aware swap (based on the worst objective)\n    obj = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj)\n\n    if worst_obj_idx == 0:\n        # If first objective is worst, swap edges that might reduce distance in space 1\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif worst_obj_idx == 1:\n        # If second objective is worst, swap edges that might reduce distance in space 2\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If third objective is worst, swap edges that might reduce distance in space 3\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher costs)\n    objectives = [obj for (_, obj) in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    selected_indices = []\n\n    # Select solutions that are above average in at least one objective\n    for i, obj in enumerate(objectives):\n        if any(obj[j] > avg_objectives[j] for j in range(3)):\n            selected_indices.append(i)\n\n    if not selected_indices:\n        selected_indices = [np.random.randint(0, len(archive))]\n\n    selected_idx = np.random.choice(selected_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap (reverses a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform objective-aware swap (based on the worst objective)\n    obj = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj)\n\n    if worst_obj_idx == 0:\n        # If first objective is worst, swap edges that might reduce distance in space 1\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif worst_obj_idx == 1:\n        # If second objective is worst, swap edges that might reduce distance in space 2\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If third objective is worst, swap edges that might reduce distance in space 3\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7395689705840038,
            1.6099295020103455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher costs)\n    objectives = [obj for (_, obj) in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    selected_indices = []\n\n    # Select solutions that are above average in at least one objective\n    for i, obj in enumerate(objectives):\n        if any(obj[j] > avg_objectives[j] for j in range(3)):\n            selected_indices.append(i)\n\n    if not selected_indices:\n        selected_indices = [np.random.randint(0, len(archive))]\n\n    selected_idx = np.random.choice(selected_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap (reverses a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform objective-aware swap (based on the worst objective)\n    obj = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj)\n\n    if worst_obj_idx == 0:\n        # If first objective is worst, swap edges that might reduce distance in space 1\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif worst_obj_idx == 1:\n        # If second objective is worst, swap edges that might reduce distance in space 2\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If third objective is worst, swap edges that might reduce distance in space 3\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the spread of objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding_distances = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt and alternating segment inversion\n    operator_choice = random.random()\n\n    if operator_choice < 0.5:  # Apply 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Apply alternating segment inversion\n        segment_length = random.randint(2, max(2, n // 3))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is not a valid tour\")\n\n    return new_solution\n\n",
        "score": [
            -0.6989055897073349,
            1.4803836345672607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the spread of objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding_distances = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt and alternating segment inversion\n    operator_choice = random.random()\n\n    if operator_choice < 0.5:  # Apply 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Apply alternating segment inversion\n        segment_length = random.randint(2, max(2, n // 3))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is not a valid tour\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the spread of objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding_distances = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt and alternating segment inversion\n    operator_choice = random.random()\n\n    if operator_choice < 0.5:  # Apply 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Apply alternating segment inversion\n        segment_length = random.randint(2, max(2, n // 3))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is not a valid tour\")\n\n    return new_solution\n\n",
        "score": [
            -0.6989055897073349,
            1.4803836345672607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the spread of objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding_distances = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt and alternating segment inversion\n    operator_choice = random.random()\n\n    if operator_choice < 0.5:  # Apply 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Apply alternating segment inversion\n        segment_length = random.randint(2, max(2, n // 3))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is not a valid tour\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate a score for each solution based on objective values (lower is better)\n        scores = [sum(obj) for _, obj in archive]\n        min_score = min(scores)\n        candidates = [i for i, score in enumerate(scores) if score <= min_score * 1.1]  # 10% tolerance\n\n        if candidates:\n            selected_idx = random.choice(candidates)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and objective-aware edge swap\n    if n > 3:\n        # Randomly select two segments to swap (2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware edge swap: try to improve the worst objective\n        # Calculate current objectives\n        def calculate_objective(sol):\n            obj1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n            obj3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n            return (obj1, obj2, obj3)\n\n        current_obj = calculate_objective(new_solution)\n        max_obj_idx = np.argmax(current_obj)\n\n        # Find the worst objective and try to improve it\n        if max_obj_idx == 0:\n            dm = distance_matrix_1\n        elif max_obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Try to find a better edge swap for the worst objective\n        improved = False\n        for _ in range(10):  # Limited attempts to keep it efficient\n            a, b = sorted(random.sample(range(n), 2))\n            if a == b:\n                continue\n\n            # Current edges: (a,a+1) and (b,b+1)\n            # Proposed edges: (a,b+1) and (b,a+1)\n            delta = (dm[new_solution[a], new_solution[(b+1)%n]] +\n                     dm[new_solution[b], new_solution[(a+1)%n]] -\n                     dm[new_solution[a], new_solution[(a+1)%n]] -\n                     dm[new_solution[b], new_solution[(b+1)%n]])\n\n            if delta < 0:  # Improvement found\n                # Perform the swap\n                if a < b:\n                    new_solution[a:b+1] = np.concatenate([new_solution[a:b+1][::-1]])\n                else:\n                    # Handle wrap-around case\n                    part1 = new_solution[a:][::-1]\n                    part2 = new_solution[:b+1][::-1]\n                    new_solution = np.concatenate([part1, part2])\n                improved = True\n                break\n\n        if not improved:\n            # If no improvement, try a random 3-opt for more exploration\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            segment3 = new_solution[k:] if i > 0 else new_solution[:i]\n\n            # Try different permutations\n            permutations = [\n                np.concatenate([segment1, segment2, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment2, segment3, segment1]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment3, segment2, segment1])\n            ]\n\n            # Evaluate all permutations\n            best_perm = new_solution.copy()\n            best_obj = current_obj\n\n            for perm in permutations:\n                temp_sol = np.concatenate([new_solution[:i], perm, new_solution[k:]])\n                temp_obj = calculate_objective(temp_sol)\n\n                # Check if any objective is improved\n                if any(temp_obj[i] < best_obj[i] for i in range(3)):\n                    best_perm = temp_sol.copy()\n                    best_obj = temp_obj\n\n            new_solution = best_perm\n\n    return new_solution\n\n",
        "score": [
            -0.7483993100585602,
            1.4778315067291259
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate a score for each solution based on objective values (lower is better)\n        scores = [sum(obj) for _, obj in archive]\n        min_score = min(scores)\n        candidates = [i for i, score in enumerate(scores) if score <= min_score * 1.1]  # 10% tolerance\n\n        if candidates:\n            selected_idx = random.choice(candidates)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and objective-aware edge swap\n    if n > 3:\n        # Randomly select two segments to swap (2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware edge swap: try to improve the worst objective\n        # Calculate current objectives\n        def calculate_objective(sol):\n            obj1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n            obj3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n            return (obj1, obj2, obj3)\n\n        current_obj = calculate_objective(new_solution)\n        max_obj_idx = np.argmax(current_obj)\n\n        # Find the worst objective and try to improve it\n        if max_obj_idx == 0:\n            dm = distance_matrix_1\n        elif max_obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Try to find a better edge swap for the worst objective\n        improved = False\n        for _ in range(10):  # Limited attempts to keep it efficient\n            a, b = sorted(random.sample(range(n), 2))\n            if a == b:\n                continue\n\n            # Current edges: (a,a+1) and (b,b+1)\n            # Proposed edges: (a,b+1) and (b,a+1)\n            delta = (dm[new_solution[a], new_solution[(b+1)%n]] +\n                     dm[new_solution[b], new_solution[(a+1)%n]] -\n                     dm[new_solution[a], new_solution[(a+1)%n]] -\n                     dm[new_solution[b], new_solution[(b+1)%n]])\n\n            if delta < 0:  # Improvement found\n                # Perform the swap\n                if a < b:\n                    new_solution[a:b+1] = np.concatenate([new_solution[a:b+1][::-1]])\n                else:\n                    # Handle wrap-around case\n                    part1 = new_solution[a:][::-1]\n                    part2 = new_solution[:b+1][::-1]\n                    new_solution = np.concatenate([part1, part2])\n                improved = True\n                break\n\n        if not improved:\n            # If no improvement, try a random 3-opt for more exploration\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            segment3 = new_solution[k:] if i > 0 else new_solution[:i]\n\n            # Try different permutations\n            permutations = [\n                np.concatenate([segment1, segment2, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment2, segment3, segment1]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment3, segment2, segment1])\n            ]\n\n            # Evaluate all permutations\n            best_perm = new_solution.copy()\n            best_obj = current_obj\n\n            for perm in permutations:\n                temp_sol = np.concatenate([new_solution[:i], perm, new_solution[k:]])\n                temp_obj = calculate_objective(temp_sol)\n\n                # Check if any objective is improved\n                if any(temp_obj[i] < best_obj[i] for i in range(3)):\n                    best_perm = temp_sol.copy()\n                    best_obj = temp_obj\n\n            new_solution = best_perm\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate a score for each solution based on objective values (lower is better)\n        scores = [sum(obj) for _, obj in archive]\n        min_score = min(scores)\n        candidates = [i for i, score in enumerate(scores) if score <= min_score * 1.1]  # 10% tolerance\n\n        if candidates:\n            selected_idx = random.choice(candidates)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and objective-aware edge swap\n    if n > 3:\n        # Randomly select two segments to swap (2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware edge swap: try to improve the worst objective\n        # Calculate current objectives\n        def calculate_objective(sol):\n            obj1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n            obj3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n            return (obj1, obj2, obj3)\n\n        current_obj = calculate_objective(new_solution)\n        max_obj_idx = np.argmax(current_obj)\n\n        # Find the worst objective and try to improve it\n        if max_obj_idx == 0:\n            dm = distance_matrix_1\n        elif max_obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Try to find a better edge swap for the worst objective\n        improved = False\n        for _ in range(10):  # Limited attempts to keep it efficient\n            a, b = sorted(random.sample(range(n), 2))\n            if a == b:\n                continue\n\n            # Current edges: (a,a+1) and (b,b+1)\n            # Proposed edges: (a,b+1) and (b,a+1)\n            delta = (dm[new_solution[a], new_solution[(b+1)%n]] +\n                     dm[new_solution[b], new_solution[(a+1)%n]] -\n                     dm[new_solution[a], new_solution[(a+1)%n]] -\n                     dm[new_solution[b], new_solution[(b+1)%n]])\n\n            if delta < 0:  # Improvement found\n                # Perform the swap\n                if a < b:\n                    new_solution[a:b+1] = np.concatenate([new_solution[a:b+1][::-1]])\n                else:\n                    # Handle wrap-around case\n                    part1 = new_solution[a:][::-1]\n                    part2 = new_solution[:b+1][::-1]\n                    new_solution = np.concatenate([part1, part2])\n                improved = True\n                break\n\n        if not improved:\n            # If no improvement, try a random 3-opt for more exploration\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            segment3 = new_solution[k:] if i > 0 else new_solution[:i]\n\n            # Try different permutations\n            permutations = [\n                np.concatenate([segment1, segment2, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment2, segment3, segment1]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment3, segment2, segment1])\n            ]\n\n            # Evaluate all permutations\n            best_perm = new_solution.copy()\n            best_obj = current_obj\n\n            for perm in permutations:\n                temp_sol = np.concatenate([new_solution[:i], perm, new_solution[k:]])\n                temp_obj = calculate_objective(temp_sol)\n\n                # Check if any objective is improved\n                if any(temp_obj[i] < best_obj[i] for i in range(3)):\n                    best_perm = temp_sol.copy()\n                    best_obj = temp_obj\n\n            new_solution = best_perm\n\n    return new_solution\n\n",
        "score": [
            -0.7483993100585602,
            1.4778315067291259
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate a score for each solution based on objective values (lower is better)\n        scores = [sum(obj) for _, obj in archive]\n        min_score = min(scores)\n        candidates = [i for i, score in enumerate(scores) if score <= min_score * 1.1]  # 10% tolerance\n\n        if candidates:\n            selected_idx = random.choice(candidates)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combination of 2-opt and objective-aware edge swap\n    if n > 3:\n        # Randomly select two segments to swap (2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware edge swap: try to improve the worst objective\n        # Calculate current objectives\n        def calculate_objective(sol):\n            obj1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n            obj3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n            return (obj1, obj2, obj3)\n\n        current_obj = calculate_objective(new_solution)\n        max_obj_idx = np.argmax(current_obj)\n\n        # Find the worst objective and try to improve it\n        if max_obj_idx == 0:\n            dm = distance_matrix_1\n        elif max_obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Try to find a better edge swap for the worst objective\n        improved = False\n        for _ in range(10):  # Limited attempts to keep it efficient\n            a, b = sorted(random.sample(range(n), 2))\n            if a == b:\n                continue\n\n            # Current edges: (a,a+1) and (b,b+1)\n            # Proposed edges: (a,b+1) and (b,a+1)\n            delta = (dm[new_solution[a], new_solution[(b+1)%n]] +\n                     dm[new_solution[b], new_solution[(a+1)%n]] -\n                     dm[new_solution[a], new_solution[(a+1)%n]] -\n                     dm[new_solution[b], new_solution[(b+1)%n]])\n\n            if delta < 0:  # Improvement found\n                # Perform the swap\n                if a < b:\n                    new_solution[a:b+1] = np.concatenate([new_solution[a:b+1][::-1]])\n                else:\n                    # Handle wrap-around case\n                    part1 = new_solution[a:][::-1]\n                    part2 = new_solution[:b+1][::-1]\n                    new_solution = np.concatenate([part1, part2])\n                improved = True\n                break\n\n        if not improved:\n            # If no improvement, try a random 3-opt for more exploration\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            segment3 = new_solution[k:] if i > 0 else new_solution[:i]\n\n            # Try different permutations\n            permutations = [\n                np.concatenate([segment1, segment2, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment2, segment3, segment1]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment3, segment2, segment1])\n            ]\n\n            # Evaluate all permutations\n            best_perm = new_solution.copy()\n            best_obj = current_obj\n\n            for perm in permutations:\n                temp_sol = np.concatenate([new_solution[:i], perm, new_solution[k:]])\n                temp_obj = calculate_objective(temp_sol)\n\n                # Check if any objective is improved\n                if any(temp_obj[i] < best_obj[i] for i in range(3)):\n                    best_perm = temp_sol.copy()\n                    best_obj = temp_obj\n\n            new_solution = best_perm\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 2:\n        # Sort archive by the sum of objectives to find solutions in the middle of the Pareto front\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is neither the best nor the worst\n        selected_idx = len(sorted_archive) // 2\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Apply 2-opt move (swap edges)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Evaluate the move across all three objectives\n        def evaluate_move(solution):\n            cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (cost1, cost2, cost3)\n\n        current_cost = evaluate_move(base_solution)\n        new_cost = evaluate_move(new_solution)\n\n        # Accept the move if it improves at least one objective\n        if any(new_c < current_c for new_c, current_c in zip(new_cost, current_cost)):\n            base_solution = new_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -0.7850402040056752,
            4.398978137969971
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 2:\n        # Sort archive by the sum of objectives to find solutions in the middle of the Pareto front\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is neither the best nor the worst\n        selected_idx = len(sorted_archive) // 2\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Apply 2-opt move (swap edges)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Evaluate the move across all three objectives\n        def evaluate_move(solution):\n            cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (cost1, cost2, cost3)\n\n        current_cost = evaluate_move(base_solution)\n        new_cost = evaluate_move(new_solution)\n\n        # Accept the move if it improves at least one objective\n        if any(new_c < current_c for new_c, current_c in zip(new_cost, current_cost)):\n            base_solution = new_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 2:\n        # Sort archive by the sum of objectives to find solutions in the middle of the Pareto front\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is neither the best nor the worst\n        selected_idx = len(sorted_archive) // 2\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Apply 2-opt move (swap edges)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Evaluate the move across all three objectives\n        def evaluate_move(solution):\n            cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (cost1, cost2, cost3)\n\n        current_cost = evaluate_move(base_solution)\n        new_cost = evaluate_move(new_solution)\n\n        # Accept the move if it improves at least one objective\n        if any(new_c < current_c for new_c, current_c in zip(new_cost, current_cost)):\n            base_solution = new_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -0.7850402040056752,
            4.398978137969971
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 2:\n        # Sort archive by the sum of objectives to find solutions in the middle of the Pareto front\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is neither the best nor the worst\n        selected_idx = len(sorted_archive) // 2\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Apply 2-opt move (swap edges)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Evaluate the move across all three objectives\n        def evaluate_move(solution):\n            cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (cost1, cost2, cost3)\n\n        current_cost = evaluate_move(base_solution)\n        new_cost = evaluate_move(new_solution)\n\n        # Accept the move if it improves at least one objective\n        if any(new_c < current_c for new_c, current_c in zip(new_cost, current_cost)):\n            base_solution = new_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with objective-aware perturbation\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two non-adjacent edges to reverse\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or abs(i - j) == 1:\n            continue\n\n        # Perform 2-opt\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware perturbation: randomly swap a segment based on objective differences\n        if np.random.random() < 0.3:  # 30% chance of additional perturbation\n            k = np.random.randint(1, n//2)\n            segment = new_solution[k:k+k]\n            # Choose which objective to prioritize for the swap\n            obj_weights = [1.0 / (1 + obj) for obj in archive[selected_idx][1]]\n            chosen_obj = np.random.choice(3, p=np.array(obj_weights)/sum(obj_weights))\n\n            # Find the best position to insert the segment based on the chosen objective\n            best_pos = k\n            best_score = float('inf')\n            for pos in range(n - k + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                if chosen_obj == 0:\n                    score = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                elif chosen_obj == 1:\n                    score = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n                else:\n                    score = sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos + k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.667833646981392,
            4.108953869342804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with objective-aware perturbation\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two non-adjacent edges to reverse\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or abs(i - j) == 1:\n            continue\n\n        # Perform 2-opt\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware perturbation: randomly swap a segment based on objective differences\n        if np.random.random() < 0.3:  # 30% chance of additional perturbation\n            k = np.random.randint(1, n//2)\n            segment = new_solution[k:k+k]\n            # Choose which objective to prioritize for the swap\n            obj_weights = [1.0 / (1 + obj) for obj in archive[selected_idx][1]]\n            chosen_obj = np.random.choice(3, p=np.array(obj_weights)/sum(obj_weights))\n\n            # Find the best position to insert the segment based on the chosen objective\n            best_pos = k\n            best_score = float('inf')\n            for pos in range(n - k + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                if chosen_obj == 0:\n                    score = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                elif chosen_obj == 1:\n                    score = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n                else:\n                    score = sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos + k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combination of objectives (e.g., sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select top 30% of solutions with the best combined objective\n    top_k = max(1, len(archive) // 3)\n    candidates = archive_sorted[:top_k]\n\n    # Randomly select a candidate from the top candidates\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt or 3-opt based on the current solution's objective diversity\n    objectives = selected[1]\n    obj_diversity = np.std(objectives)\n\n    if obj_diversity > np.mean(objectives) * 0.3 or random.random() < 0.3:  # If objectives are diverse, use 3-opt\n        # 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse the middle segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the last segment\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7085105014231818,
            1.9302805066108704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combination of objectives (e.g., sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select top 30% of solutions with the best combined objective\n    top_k = max(1, len(archive) // 3)\n    candidates = archive_sorted[:top_k]\n\n    # Randomly select a candidate from the top candidates\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt or 3-opt based on the current solution's objective diversity\n    objectives = selected[1]\n    obj_diversity = np.std(objectives)\n\n    if obj_diversity > np.mean(objectives) * 0.3 or random.random() < 0.3:  # If objectives are diverse, use 3-opt\n        # 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse the middle segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the last segment\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine the weights for each objective based on their relative improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.max(objectives, axis=0) - objectives[selected_idx]\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(3) / 3\n\n    # Hybrid local search: weighted combination of 2-opt and 3-opt moves\n    n = len(base_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # 2-opt move with probability weighted by objectives\n        if np.random.random() < weights[0] + weights[1]:\n            # Reverse segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move: select two additional points and perform a swap\n            k, l = np.random.choice(n, 2, replace=False)\n            k, l = min(k, l), max(k, l)\n            if k < i < j < l:\n                # Case 1: k < i < j < l\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                new_solution[j+1:l+1] = new_solution[j+1:l+1][::-1]\n            elif i < k < j < l:\n                # Case 2: i < k < j < l\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n            elif i < k < l < j:\n                # Case 3: i < k < l < j\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n    return new_solution\n\n",
        "score": [
            -0.6780544265173631,
            1.966866946220398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine the weights for each objective based on their relative improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.max(objectives, axis=0) - objectives[selected_idx]\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(3) / 3\n\n    # Hybrid local search: weighted combination of 2-opt and 3-opt moves\n    n = len(base_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # 2-opt move with probability weighted by objectives\n        if np.random.random() < weights[0] + weights[1]:\n            # Reverse segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move: select two additional points and perform a swap\n            k, l = np.random.choice(n, 2, replace=False)\n            k, l = min(k, l), max(k, l)\n            if k < i < j < l:\n                # Case 1: k < i < j < l\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                new_solution[j+1:l+1] = new_solution[j+1:l+1][::-1]\n            elif i < k < j < l:\n                # Case 2: i < k < j < l\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n            elif i < k < l < j:\n                # Case 3: i < k < l < j\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective aware swap\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt on the worst objective space\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    worst_obj_idx = np.argmax(avg_objectives)\n\n    # Choose between 2-opt or multi-objective swap based on a probability\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search on the worst objective space\n        n = len(new_solution)\n        best_improvement = 0\n        best_i, best_j = -1, -1\n\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                # Calculate change in all three objectives\n                if worst_obj_idx == 0:\n                    delta = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                             distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                elif worst_obj_idx == 1:\n                    delta = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                             distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                else:\n                    delta = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                             distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_i, best_j = i, j\n\n        if best_i != -1:\n            # Reverse the segment between best_i+1 and best_j\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n    else:\n        # Multi-objective aware swap: swap nodes that have high variance in their positions\n        n = len(new_solution)\n        # Calculate position variance for each node\n        variances = []\n        for node in new_solution:\n            coords = instance[node]\n            x1, y1, x2, y2, x3, y3 = coords\n            var = np.var([x1, y1, x2, y2, x3, y3])\n            variances.append(var)\n\n        # Find the two nodes with highest variance\n        sorted_indices = np.argsort(variances)[::-1]\n        i, j = sorted_indices[0], sorted_indices[1]\n\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.813384398873696,
            4.028697299957275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective aware swap\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt on the worst objective space\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    worst_obj_idx = np.argmax(avg_objectives)\n\n    # Choose between 2-opt or multi-objective swap based on a probability\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search on the worst objective space\n        n = len(new_solution)\n        best_improvement = 0\n        best_i, best_j = -1, -1\n\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                # Calculate change in all three objectives\n                if worst_obj_idx == 0:\n                    delta = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                             distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                elif worst_obj_idx == 1:\n                    delta = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                             distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                else:\n                    delta = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                             distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_i, best_j = i, j\n\n        if best_i != -1:\n            # Reverse the segment between best_i+1 and best_j\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n    else:\n        # Multi-objective aware swap: swap nodes that have high variance in their positions\n        n = len(new_solution)\n        # Calculate position variance for each node\n        variances = []\n        for node in new_solution:\n            coords = instance[node]\n            x1, y1, x2, y2, x3, y3 = coords\n            var = np.var([x1, y1, x2, y2, x3, y3])\n            variances.append(var)\n\n        # Find the two nodes with highest variance\n        sorted_indices = np.argsort(variances)[::-1]\n        i, j = sorted_indices[0], sorted_indices[1]\n\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective aware swap\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt on the worst objective space\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    worst_obj_idx = np.argmax(avg_objectives)\n\n    # Choose between 2-opt or multi-objective swap based on a probability\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search on the worst objective space\n        n = len(new_solution)\n        best_improvement = 0\n        best_i, best_j = -1, -1\n\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                # Calculate change in all three objectives\n                if worst_obj_idx == 0:\n                    delta = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                             distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                elif worst_obj_idx == 1:\n                    delta = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                             distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                else:\n                    delta = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                             distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_i, best_j = i, j\n\n        if best_i != -1:\n            # Reverse the segment between best_i+1 and best_j\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n    else:\n        # Multi-objective aware swap: swap nodes that have high variance in their positions\n        n = len(new_solution)\n        # Calculate position variance for each node\n        variances = []\n        for node in new_solution:\n            coords = instance[node]\n            x1, y1, x2, y2, x3, y3 = coords\n            var = np.var([x1, y1, x2, y2, x3, y3])\n            variances.append(var)\n\n        # Find the two nodes with highest variance\n        sorted_indices = np.argsort(variances)[::-1]\n        i, j = sorted_indices[0], sorted_indices[1]\n\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.813384398873696,
            4.028697299957275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective aware swap\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt on the worst objective space\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    worst_obj_idx = np.argmax(avg_objectives)\n\n    # Choose between 2-opt or multi-objective swap based on a probability\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search on the worst objective space\n        n = len(new_solution)\n        best_improvement = 0\n        best_i, best_j = -1, -1\n\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                # Calculate change in all three objectives\n                if worst_obj_idx == 0:\n                    delta = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                             distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                elif worst_obj_idx == 1:\n                    delta = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                             distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                else:\n                    delta = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                             distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_i, best_j = i, j\n\n        if best_i != -1:\n            # Reverse the segment between best_i+1 and best_j\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n    else:\n        # Multi-objective aware swap: swap nodes that have high variance in their positions\n        n = len(new_solution)\n        # Calculate position variance for each node\n        variances = []\n        for node in new_solution:\n            coords = instance[node]\n            x1, y1, x2, y2, x3, y3 = coords\n            var = np.var([x1, y1, x2, y2, x3, y3])\n            variances.append(var)\n\n        # Find the two nodes with highest variance\n        sorted_indices = np.argsort(variances)[::-1]\n        i, j = sorted_indices[0], sorted_indices[1]\n\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a multi-objective aware swap\n    # Find the edge with the highest total distance across all objectives\n    max_total_dist = -1\n    best_i, best_j = 0, 0\n    for i in range(n):\n        j = (i + 1) % n\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        dist3 = distance_matrix_3[new_solution[i], new_solution[j]]\n        total_dist = dist1 + dist2 + dist3\n        if total_dist > max_total_dist:\n            max_total_dist = total_dist\n            best_i, best_j = i, j\n\n    # Swap the nodes connected by this edge with another random edge\n    if best_i != best_j:\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[best_i], new_solution[k] = new_solution[k], new_solution[best_i]\n        new_solution[best_j], new_solution[l] = new_solution[l], new_solution[best_j]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7584978694420952,
            1.5465655326843262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a multi-objective aware swap\n    # Find the edge with the highest total distance across all objectives\n    max_total_dist = -1\n    best_i, best_j = 0, 0\n    for i in range(n):\n        j = (i + 1) % n\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        dist3 = distance_matrix_3[new_solution[i], new_solution[j]]\n        total_dist = dist1 + dist2 + dist3\n        if total_dist > max_total_dist:\n            max_total_dist = total_dist\n            best_i, best_j = i, j\n\n    # Swap the nodes connected by this edge with another random edge\n    if best_i != best_j:\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[best_i], new_solution[k] = new_solution[k], new_solution[best_i]\n        new_solution[best_j], new_solution[l] = new_solution[l], new_solution[best_j]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already converged)\n    # Here, we select a solution with the highest sum of objectives as a starting point\n    objectives = np.array([obj for _, obj in archive])\n    objective_sums = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and insertion moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform insertion move (reinsert a node in a different position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6976991882487269,
            1.7477192163467408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already converged)\n    # Here, we select a solution with the highest sum of objectives as a starting point\n    objectives = np.array([obj for _, obj in archive])\n    objective_sums = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and insertion moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform insertion move (reinsert a node in a different position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, min(5, len(archive) - 1)) if len(archive) > 1 else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # First, perform a standard 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-aware swaps\n    for _ in range(2):  # Limit the number of swaps to maintain diversity\n        # Calculate the current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        )\n\n        # Find the worst objective\n        worst_obj_idx = np.argmax(current_obj)\n\n        # Select matrices based on worst objective\n        if worst_obj_idx == 0:\n            d_mat = distance_matrix_1\n        elif worst_obj_idx == 1:\n            d_mat = distance_matrix_2\n        else:\n            d_mat = distance_matrix_3\n\n        # Find the most improving swap\n        best_improvement = 0\n        best_swap = None\n\n        # Check a limited number of random swaps\n        for _ in range(5):\n            a, b = sorted(random.sample(range(n), 2))\n            if a == b:\n                continue\n\n            # Calculate the change in distance\n            old_dist = (d_mat[new_solution[a-1], new_solution[a]] +\n                        d_mat[new_solution[b-1], new_solution[b]] +\n                        (d_mat[new_solution[a], new_solution[a+1]] if a+1 < n else d_mat[new_solution[a], new_solution[0]]) +\n                        (d_mat[new_solution[b], new_solution[b+1]] if b+1 < n else d_mat[new_solution[b], new_solution[0]]))\n\n            new_dist = (d_mat[new_solution[a-1], new_solution[b]] +\n                        d_mat[new_solution[b-1], new_solution[a]] +\n                        (d_mat[new_solution[b], new_solution[a+1]] if a+1 < n else d_mat[new_solution[b], new_solution[0]]) +\n                        (d_mat[new_solution[a], new_solution[b+1]] if b+1 < n else d_mat[new_solution[a], new_solution[0]]))\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6222361711277601,
            1.8582249879837036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, min(5, len(archive) - 1)) if len(archive) > 1 else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # First, perform a standard 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-aware swaps\n    for _ in range(2):  # Limit the number of swaps to maintain diversity\n        # Calculate the current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        )\n\n        # Find the worst objective\n        worst_obj_idx = np.argmax(current_obj)\n\n        # Select matrices based on worst objective\n        if worst_obj_idx == 0:\n            d_mat = distance_matrix_1\n        elif worst_obj_idx == 1:\n            d_mat = distance_matrix_2\n        else:\n            d_mat = distance_matrix_3\n\n        # Find the most improving swap\n        best_improvement = 0\n        best_swap = None\n\n        # Check a limited number of random swaps\n        for _ in range(5):\n            a, b = sorted(random.sample(range(n), 2))\n            if a == b:\n                continue\n\n            # Calculate the change in distance\n            old_dist = (d_mat[new_solution[a-1], new_solution[a]] +\n                        d_mat[new_solution[b-1], new_solution[b]] +\n                        (d_mat[new_solution[a], new_solution[a+1]] if a+1 < n else d_mat[new_solution[a], new_solution[0]]) +\n                        (d_mat[new_solution[b], new_solution[b+1]] if b+1 < n else d_mat[new_solution[b], new_solution[0]]))\n\n            new_dist = (d_mat[new_solution[a-1], new_solution[b]] +\n                        d_mat[new_solution[b-1], new_solution[a]] +\n                        (d_mat[new_solution[b], new_solution[a+1]] if a+1 < n else d_mat[new_solution[b], new_solution[0]]) +\n                        (d_mat[new_solution[a], new_solution[b+1]] if b+1 < n else d_mat[new_solution[a], new_solution[0]]))\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 13,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt swap (basic local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: further optimize based on the most critical objective\n    objectives = [archive[selected_idx][1][k] for k in range(3)]\n    critical_obj = np.argmax(objectives)  # Identify the most critical objective\n\n    # Evaluate the current and potential neighbor solutions\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(len(solution) - 1):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[-1], solution[0]]  # Return to start\n        return cost\n\n    current_costs = [calculate_cost(base_solution, distance_matrix_1),\n                     calculate_cost(base_solution, distance_matrix_2),\n                     calculate_cost(base_solution, distance_matrix_3)]\n\n    neighbor_costs = [calculate_cost(new_solution, distance_matrix_1),\n                      calculate_cost(new_solution, distance_matrix_2),\n                      calculate_cost(new_solution, distance_matrix_3)]\n\n    # If the neighbor is worse in the critical objective, revert to base solution\n    if neighbor_costs[critical_obj] > current_costs[critical_obj]:\n        new_solution = base_solution.copy()\n        # Try another 2-opt swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional swap to diversify the solution\n    if random.random() < 0.3:  # 30% chance of additional swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7070327220170076,
            1.732295858860016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt swap (basic local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: further optimize based on the most critical objective\n    objectives = [archive[selected_idx][1][k] for k in range(3)]\n    critical_obj = np.argmax(objectives)  # Identify the most critical objective\n\n    # Evaluate the current and potential neighbor solutions\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(len(solution) - 1):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[-1], solution[0]]  # Return to start\n        return cost\n\n    current_costs = [calculate_cost(base_solution, distance_matrix_1),\n                     calculate_cost(base_solution, distance_matrix_2),\n                     calculate_cost(base_solution, distance_matrix_3)]\n\n    neighbor_costs = [calculate_cost(new_solution, distance_matrix_1),\n                      calculate_cost(new_solution, distance_matrix_2),\n                      calculate_cost(new_solution, distance_matrix_3)]\n\n    # If the neighbor is worse in the critical objective, revert to base solution\n    if neighbor_costs[critical_obj] > current_costs[critical_obj]:\n        new_solution = base_solution.copy()\n        # Try another 2-opt swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional swap to diversify the solution\n    if random.random() < 0.3:  # 30% chance of additional swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 14,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across all three objectives\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel objective-aware swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current objective values\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Try to find a better swap by considering all three objectives\n    for _ in range(10):  # Limit the number of attempts to keep it efficient\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        temp_obj = calculate_objective(temp_solution)\n\n        # Accept the swap if it improves at least one objective\n        if any(temp_obj[i] < current_obj[i] for i in range(3)):\n            new_solution = temp_solution\n            current_obj = temp_obj\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7116825004347545,
            2.0848198890686036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across all three objectives\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel objective-aware swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current objective values\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Try to find a better swap by considering all three objectives\n    for _ in range(10):  # Limit the number of attempts to keep it efficient\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        temp_obj = calculate_objective(temp_solution)\n\n        # Accept the swap if it improves at least one objective\n        if any(temp_obj[i] < current_obj[i] for i in range(3)):\n            new_solution = temp_solution\n            current_obj = temp_obj\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high deviation from average)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    deviations = np.abs(objectives - avg_objectives)\n    scores = np.sum(deviations, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware edge swap\n    # Calculate the total cost of the current solution\n    def calculate_cost(solution):\n        total_cost = 0\n        for k in range(n):\n            u = solution[k]\n            v = solution[(k+1)%n]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        return total_cost\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try to swap edges that are critical in at least one objective\n    for _ in range(10):  # Limit the number of attempts\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j or (i+1)%n == j or (j+1)%n == i:\n            continue\n\n        # Get the nodes involved\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        # Calculate the cost difference for each objective\n        cost_diff = (\n            (distance_matrix_1[c, a] + distance_matrix_1[b, d] - distance_matrix_1[a, b] - distance_matrix_1[c, d]) +\n            (distance_matrix_2[c, a] + distance_matrix_2[b, d] - distance_matrix_2[a, b] - distance_matrix_2[c, d]) +\n            (distance_matrix_3[c, a] + distance_matrix_3[b, d] - distance_matrix_3[a, b] - distance_matrix_3[c, d])\n        )\n\n        if cost_diff < 0:  # If the swap improves the total cost\n            # Perform the swap\n            new_solution[(i+1)%n], new_solution[j] = new_solution[j], new_solution[(i+1)%n]\n            current_cost += cost_diff\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6471676947185788,
            2.016296076774597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high deviation from average)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    deviations = np.abs(objectives - avg_objectives)\n    scores = np.sum(deviations, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware edge swap\n    # Calculate the total cost of the current solution\n    def calculate_cost(solution):\n        total_cost = 0\n        for k in range(n):\n            u = solution[k]\n            v = solution[(k+1)%n]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        return total_cost\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try to swap edges that are critical in at least one objective\n    for _ in range(10):  # Limit the number of attempts\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j or (i+1)%n == j or (j+1)%n == i:\n            continue\n\n        # Get the nodes involved\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        # Calculate the cost difference for each objective\n        cost_diff = (\n            (distance_matrix_1[c, a] + distance_matrix_1[b, d] - distance_matrix_1[a, b] - distance_matrix_1[c, d]) +\n            (distance_matrix_2[c, a] + distance_matrix_2[b, d] - distance_matrix_2[a, b] - distance_matrix_2[c, d]) +\n            (distance_matrix_3[c, a] + distance_matrix_3[b, d] - distance_matrix_3[a, b] - distance_matrix_3[c, d])\n        )\n\n        if cost_diff < 0:  # If the swap improves the total cost\n            # Perform the swap\n            new_solution[(i+1)%n], new_solution[j] = new_solution[j], new_solution[(i+1)%n]\n            current_cost += cost_diff\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = np.array([sum(obj) for _, obj in archive])\n    weights = weights / np.sum(weights)  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n = len(new_solution)\n\n    # 1. Randomly select one of the three operators\n    operator = np.random.choice(['2opt', 'inversion', 'multi_obj_swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt on a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'inversion':\n        # Invert a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'multi_obj_swap':\n        # Multi-objective edge swap: identify edges that are good in at least two objectives\n        for _ in range(3):  # Try a few swaps\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            a, b = new_solution[i], new_solution[j]\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[a, new_solution[(i-1)%n]] + distance_matrix_1[new_solution[(i+1)%n], b] -\n                     (distance_matrix_1[a, new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(i-1)%n], b]))\n            delta2 = (distance_matrix_2[a, new_solution[(i-1)%n]] + distance_matrix_2[new_solution[(i+1)%n], b] -\n                     (distance_matrix_2[a, new_solution[(i+1)%n]] + distance_matrix_2[new_solution[(i-1)%n], b]))\n            delta3 = (distance_matrix_3[a, new_solution[(i-1)%n]] + distance_matrix_3[new_solution[(i+1)%n], b] -\n                     (distance_matrix_3[a, new_solution[(i+1)%n]] + distance_matrix_3[new_solution[(i-1)%n], b]))\n\n            # Count how many objectives improve\n            improvements = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n\n            # Accept if at least two objectives improve\n            if improvements >= 2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (no duplicates, no missing nodes)\n    assert len(set(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8089039800679443,
            2.0432740569114687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = np.array([sum(obj) for _, obj in archive])\n    weights = weights / np.sum(weights)  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n = len(new_solution)\n\n    # 1. Randomly select one of the three operators\n    operator = np.random.choice(['2opt', 'inversion', 'multi_obj_swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt on a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'inversion':\n        # Invert a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'multi_obj_swap':\n        # Multi-objective edge swap: identify edges that are good in at least two objectives\n        for _ in range(3):  # Try a few swaps\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            a, b = new_solution[i], new_solution[j]\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[a, new_solution[(i-1)%n]] + distance_matrix_1[new_solution[(i+1)%n], b] -\n                     (distance_matrix_1[a, new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(i-1)%n], b]))\n            delta2 = (distance_matrix_2[a, new_solution[(i-1)%n]] + distance_matrix_2[new_solution[(i+1)%n], b] -\n                     (distance_matrix_2[a, new_solution[(i+1)%n]] + distance_matrix_2[new_solution[(i-1)%n], b]))\n            delta3 = (distance_matrix_3[a, new_solution[(i-1)%n]] + distance_matrix_3[new_solution[(i+1)%n], b] -\n                     (distance_matrix_3[a, new_solution[(i+1)%n]] + distance_matrix_3[new_solution[(i-1)%n], b]))\n\n            # Count how many objectives improve\n            improvements = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n\n            # Accept if at least two objectives improve\n            if improvements >= 2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (no duplicates, no missing nodes)\n    assert len(set(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution based on its objective values (lower is better)\n    scores = []\n    for sol, obj in archive:\n        # Normalize objectives to avoid bias towards larger scales\n        norm_obj = np.array(obj) / np.array([distance_matrix_1.max(), distance_matrix_2.max(), distance_matrix_3.max()])\n        score = np.sum(norm_obj)\n        scores.append(score)\n\n    # Select solutions with top 30% scores (higher potential for improvement)\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: combine 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and edge exchange\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge exchange (similar to 3-opt but simpler)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6691681648836815,
            3.932814526557922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution based on its objective values (lower is better)\n    scores = []\n    for sol, obj in archive:\n        # Normalize objectives to avoid bias towards larger scales\n        norm_obj = np.array(obj) / np.array([distance_matrix_1.max(), distance_matrix_2.max(), distance_matrix_3.max()])\n        score = np.sum(norm_obj)\n        scores.append(score)\n\n    # Select solutions with top 30% scores (higher potential for improvement)\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: combine 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and edge exchange\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge exchange (similar to 3-opt but simpler)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 18,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.sum(np.abs(normalized_objectives[:, np.newaxis] - normalized_objectives), axis=2)\n    diversity_scores = np.sum(diversity_scores, axis=1)\n\n    # Select the solution with highest diversity\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance across all objectives\n    edge_importance = np.zeros((n, n))\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_importance[i, (i+1)%n] = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n\n    # Find the worst edge (highest average distance across objectives)\n    worst_edge = np.unravel_index(np.argmax(edge_importance), edge_importance.shape)\n\n    # Perform 2-opt move on the worst edge\n    i, j = worst_edge\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Handle circular case\n        segment1 = new_solution[i:]\n        segment2 = new_solution[:j+1]\n        new_solution = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Verify the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.657891700467997,
            3.5170847177505493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.sum(np.abs(normalized_objectives[:, np.newaxis] - normalized_objectives), axis=2)\n    diversity_scores = np.sum(diversity_scores, axis=1)\n\n    # Select the solution with highest diversity\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance across all objectives\n    edge_importance = np.zeros((n, n))\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_importance[i, (i+1)%n] = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n\n    # Find the worst edge (highest average distance across objectives)\n    worst_edge = np.unravel_index(np.argmax(edge_importance), edge_importance.shape)\n\n    # Perform 2-opt move on the worst edge\n    i, j = worst_edge\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Handle circular case\n        segment1 = new_solution[i:]\n        segment2 = new_solution[:j+1]\n        new_solution = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Verify the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 19,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from typing import List, Tuple\n    import numpy as np\n\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not the best in all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    diversity_scores = np.sum(np.abs(objectives - avg_objectives), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and edge insertion based on randomness\n    if random.random() < 0.5:\n        # 2-opt local search (for one of the objectives)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion (for another objective)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.5188620367872951,
            1.5548370718955993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from typing import List, Tuple\n    import numpy as np\n\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not the best in all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    diversity_scores = np.sum(np.abs(objectives - avg_objectives), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and edge insertion based on randomness\n    if random.random() < 0.5:\n        # 2-opt local search (for one of the objectives)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion (for another objective)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest crowding distance or randomly if all are non-dominated\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware node selection\n    n = len(base_solution)\n    for _ in range(10):  # Perform multiple local search steps\n        # Select two distinct positions with high potential for improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement in all three objectives\n        current_cost = (\n            distance_matrix_1[base_solution[i-1], base_solution[i]] +\n            distance_matrix_2[base_solution[i-1], base_solution[i]] +\n            distance_matrix_3[base_solution[i-1], base_solution[i]] +\n            distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n            distance_matrix_2[base_solution[j], base_solution[(j+1)%n]] +\n            distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n        )\n\n        new_cost = (\n            distance_matrix_1[base_solution[i-1], base_solution[j]] +\n            distance_matrix_2[base_solution[i-1], base_solution[j]] +\n            distance_matrix_3[base_solution[i-1], base_solution[j]] +\n            distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] +\n            distance_matrix_2[base_solution[i], base_solution[(j+1)%n]] +\n            distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n        )\n\n        # Accept if there's improvement in at least one objective\n        if new_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            base_solution = new_solution.copy()\n\n    # Additional improvement: apply a node swap that improves the most underperforming objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmin(objectives)  # 0, 1, or 2\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    max_edge = -1\n    max_edge_idx = -1\n    for idx in range(n):\n        edge_len = dist_matrix[base_solution[idx-1], base_solution[idx]]\n        if edge_len > max_edge:\n            max_edge = edge_len\n            max_edge_idx = idx\n\n    # Try to improve this edge by swapping with another node\n    if max_edge_idx != -1:\n        # Find the best possible swap to improve this edge\n        best_improvement = 0\n        best_swap = None\n        for k in range(n):\n            if k == max_edge_idx or k == max_edge_idx - 1:\n                continue\n\n            # Calculate potential improvement\n            improvement = (\n                dist_matrix[base_solution[max_edge_idx-1], base_solution[max_edge_idx]] +\n                dist_matrix[base_solution[max_edge_idx], base_solution[(max_edge_idx+1)%n]] -\n                dist_matrix[base_solution[max_edge_idx-1], base_solution[k]] -\n                dist_matrix[base_solution[k], base_solution[(max_edge_idx+1)%n]]\n            )\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = k\n\n        if best_swap is not None:\n            # Perform the swap\n            new_solution[max_edge_idx], new_solution[best_swap] = new_solution[best_swap], new_solution[max_edge_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.691706031507522,
            4.045273923873902
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest crowding distance or randomly if all are non-dominated\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware node selection\n    n = len(base_solution)\n    for _ in range(10):  # Perform multiple local search steps\n        # Select two distinct positions with high potential for improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement in all three objectives\n        current_cost = (\n            distance_matrix_1[base_solution[i-1], base_solution[i]] +\n            distance_matrix_2[base_solution[i-1], base_solution[i]] +\n            distance_matrix_3[base_solution[i-1], base_solution[i]] +\n            distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n            distance_matrix_2[base_solution[j], base_solution[(j+1)%n]] +\n            distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n        )\n\n        new_cost = (\n            distance_matrix_1[base_solution[i-1], base_solution[j]] +\n            distance_matrix_2[base_solution[i-1], base_solution[j]] +\n            distance_matrix_3[base_solution[i-1], base_solution[j]] +\n            distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] +\n            distance_matrix_2[base_solution[i], base_solution[(j+1)%n]] +\n            distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n        )\n\n        # Accept if there's improvement in at least one objective\n        if new_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            base_solution = new_solution.copy()\n\n    # Additional improvement: apply a node swap that improves the most underperforming objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmin(objectives)  # 0, 1, or 2\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    max_edge = -1\n    max_edge_idx = -1\n    for idx in range(n):\n        edge_len = dist_matrix[base_solution[idx-1], base_solution[idx]]\n        if edge_len > max_edge:\n            max_edge = edge_len\n            max_edge_idx = idx\n\n    # Try to improve this edge by swapping with another node\n    if max_edge_idx != -1:\n        # Find the best possible swap to improve this edge\n        best_improvement = 0\n        best_swap = None\n        for k in range(n):\n            if k == max_edge_idx or k == max_edge_idx - 1:\n                continue\n\n            # Calculate potential improvement\n            improvement = (\n                dist_matrix[base_solution[max_edge_idx-1], base_solution[max_edge_idx]] +\n                dist_matrix[base_solution[max_edge_idx], base_solution[(max_edge_idx+1)%n]] -\n                dist_matrix[base_solution[max_edge_idx-1], base_solution[k]] -\n                dist_matrix[base_solution[k], base_solution[(max_edge_idx+1)%n]]\n            )\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = k\n\n        if best_swap is not None:\n            # Perform the swap\n            new_solution[max_edge_idx], new_solution[best_swap] = new_solution[best_swap], new_solution[max_edge_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 21,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum indicates potential for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions\n        top_solutions = sorted_archive[:max(1, int(0.2 * len(sorted_archive)))]\n        # Randomly select one from top solutions\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # First, perform a 2-opt move on the solution\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a 3-opt move (more complex local search)\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Finally, perform a swap between nodes with high potential for improvement\n    # Calculate improvement potential for each node\n    improvement_potential = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1) % n]\n\n        # Calculate potential improvement in all three objectives\n        current_cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                        distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n\n        # Find a random candidate to swap with\n        candidate = random.choice([x for x in range(n) if x != i and x != (i+1)%n and x != (i-1)%n])\n        candidate_node = new_solution[candidate]\n        candidate_prev = new_solution[candidate-1]\n        candidate_next = new_solution[(candidate+1)%n]\n\n        # Calculate potential improvement if we swap\n        new_cost = (distance_matrix_1[prev_node, candidate_node] + distance_matrix_1[candidate_node, next_node] +\n                    distance_matrix_1[candidate_prev, node] + distance_matrix_1[node, candidate_next] +\n                    distance_matrix_2[prev_node, candidate_node] + distance_matrix_2[candidate_node, next_node] +\n                    distance_matrix_2[candidate_prev, node] + distance_matrix_2[node, candidate_next] +\n                    distance_matrix_3[prev_node, candidate_node] + distance_matrix_3[candidate_node, next_node] +\n                    distance_matrix_3[candidate_prev, node] + distance_matrix_3[node, candidate_next])\n\n        improvement_potential.append(current_cost - new_cost)\n\n    # Perform the swap with highest improvement potential\n    if improvement_potential:\n        best_swap = np.argmax(improvement_potential)\n        candidate = random.choice([x for x in range(n) if x != best_swap and x != (best_swap+1)%n and x != (best_swap-1)%n])\n        new_solution[best_swap], new_solution[candidate] = new_solution[candidate], new_solution[best_swap]\n\n    return new_solution\n\n",
        "score": [
            -0.7314140741468,
            2.2016550064086915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum indicates potential for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions\n        top_solutions = sorted_archive[:max(1, int(0.2 * len(sorted_archive)))]\n        # Randomly select one from top solutions\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # First, perform a 2-opt move on the solution\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a 3-opt move (more complex local search)\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Finally, perform a swap between nodes with high potential for improvement\n    # Calculate improvement potential for each node\n    improvement_potential = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1) % n]\n\n        # Calculate potential improvement in all three objectives\n        current_cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                        distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n\n        # Find a random candidate to swap with\n        candidate = random.choice([x for x in range(n) if x != i and x != (i+1)%n and x != (i-1)%n])\n        candidate_node = new_solution[candidate]\n        candidate_prev = new_solution[candidate-1]\n        candidate_next = new_solution[(candidate+1)%n]\n\n        # Calculate potential improvement if we swap\n        new_cost = (distance_matrix_1[prev_node, candidate_node] + distance_matrix_1[candidate_node, next_node] +\n                    distance_matrix_1[candidate_prev, node] + distance_matrix_1[node, candidate_next] +\n                    distance_matrix_2[prev_node, candidate_node] + distance_matrix_2[candidate_node, next_node] +\n                    distance_matrix_2[candidate_prev, node] + distance_matrix_2[node, candidate_next] +\n                    distance_matrix_3[prev_node, candidate_node] + distance_matrix_3[candidate_node, next_node] +\n                    distance_matrix_3[candidate_prev, node] + distance_matrix_3[node, candidate_next])\n\n        improvement_potential.append(current_cost - new_cost)\n\n    # Perform the swap with highest improvement potential\n    if improvement_potential:\n        best_swap = np.argmax(improvement_potential)\n        candidate = random.choice([x for x in range(n) if x != best_swap and x != (best_swap+1)%n and x != (best_swap-1)%n])\n        new_solution[best_swap], new_solution[candidate] = new_solution[candidate], new_solution[best_swap]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 22,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    total_variance = np.sum(objective_variances)\n\n    if total_variance > 0:\n        # Weight solutions by their objective variance\n        weights = np.sum(objectives, axis=1) / total_variance\n        selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a segment\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform a 2-opt move\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform an objective-aware swap\n        # Select edges with high potential for improvement\n        edge_costs = []\n        for k in range(n):\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            cost1 = distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, b]\n            cost3 = distance_matrix_3[a, b]\n            edge_costs.append((cost1 + cost2 + cost3, k))\n\n        edge_costs.sort(reverse=True)\n        # Select top 20% edges for potential improvement\n        top_edges = [k for _, k in edge_costs[:max(1, len(edge_costs)//5)]]\n\n        if top_edges:\n            k = np.random.choice(top_edges)\n            a, b = new_solution[k], new_solution[(k+1)%n]\n\n            # Find a node that could improve the tour\n            candidates = []\n            for m in range(n):\n                if m != k and m != (k+1)%n:\n                    c, d = new_solution[m], new_solution[(m+1)%n]\n                    # Calculate potential new costs\n                    new_cost1 = distance_matrix_1[a, d] + distance_matrix_1[c, b]\n                    old_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                    if new_cost1 < old_cost1:\n                        candidates.append(m)\n\n            if candidates:\n                m = np.random.choice(candidates)\n                # Perform the swap\n                if k < m:\n                    new_solution[k+1:m+1] = new_solution[k+1:m+1][::-1]\n                else:\n                    new_solution[m+1:k+1] = new_solution[m+1:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.702174265221571,
            2.4655701994895933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    total_variance = np.sum(objective_variances)\n\n    if total_variance > 0:\n        # Weight solutions by their objective variance\n        weights = np.sum(objectives, axis=1) / total_variance\n        selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a segment\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform a 2-opt move\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform an objective-aware swap\n        # Select edges with high potential for improvement\n        edge_costs = []\n        for k in range(n):\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            cost1 = distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, b]\n            cost3 = distance_matrix_3[a, b]\n            edge_costs.append((cost1 + cost2 + cost3, k))\n\n        edge_costs.sort(reverse=True)\n        # Select top 20% edges for potential improvement\n        top_edges = [k for _, k in edge_costs[:max(1, len(edge_costs)//5)]]\n\n        if top_edges:\n            k = np.random.choice(top_edges)\n            a, b = new_solution[k], new_solution[(k+1)%n]\n\n            # Find a node that could improve the tour\n            candidates = []\n            for m in range(n):\n                if m != k and m != (k+1)%n:\n                    c, d = new_solution[m], new_solution[(m+1)%n]\n                    # Calculate potential new costs\n                    new_cost1 = distance_matrix_1[a, d] + distance_matrix_1[c, b]\n                    old_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                    if new_cost1 < old_cost1:\n                        candidates.append(m)\n\n            if candidates:\n                m = np.random.choice(candidates)\n                # Perform the swap\n                if k < m:\n                    new_solution[k+1:m+1] = new_solution[k+1:m+1][::-1]\n                else:\n                    new_solution[m+1:k+1] = new_solution[m+1:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity (most non-dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct positions\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential objective values\n        current_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        potential_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(potential_obj, current_obj)):\n            # Perform 2-opt swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional objective-aware edge swap\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n\n        # Calculate current and potential objective values\n        current_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        potential_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(potential_obj, current_obj)):\n            # Perform edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8001206962689655,
            2.631164526939392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity (most non-dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct positions\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential objective values\n        current_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        potential_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(potential_obj, current_obj)):\n            # Perform 2-opt swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional objective-aware edge swap\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n\n        # Calculate current and potential objective values\n        current_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        potential_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(potential_obj, current_obj)):\n            # Perform edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 24,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objective_variance * objectives, axis=1)\n    best_idx = np.argmax(weighted_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    for _ in range(3):  # Perform multiple local search steps\n        # Choose a random local search operator\n        operator = np.random.choice(['2-opt', '3-opt', 'multi_obj_swap'])\n\n        if operator == '2-opt':\n            # Standard 2-opt local search\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == '3-opt':\n            # 3-opt local search\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n        elif operator == 'multi_obj_swap':\n            # Multi-objective segment swap: identify segments that improve most objectives\n            best_improvement = -np.inf\n            best_swap = None\n\n            for _ in range(5):  # Try multiple random swaps\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                temp_solution = new_solution.copy()\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n\n                # Calculate improvement across all three objectives\n                old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                old_cost3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost3 = sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2) + (old_cost3 - new_cost3)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, j)\n\n            if best_swap is not None:\n                i, j = best_swap\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6113934928528559,
            3.6024766683578493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objective_variance * objectives, axis=1)\n    best_idx = np.argmax(weighted_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    for _ in range(3):  # Perform multiple local search steps\n        # Choose a random local search operator\n        operator = np.random.choice(['2-opt', '3-opt', 'multi_obj_swap'])\n\n        if operator == '2-opt':\n            # Standard 2-opt local search\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == '3-opt':\n            # 3-opt local search\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n        elif operator == 'multi_obj_swap':\n            # Multi-objective segment swap: identify segments that improve most objectives\n            best_improvement = -np.inf\n            best_swap = None\n\n            for _ in range(5):  # Try multiple random swaps\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                temp_solution = new_solution.copy()\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n\n                # Calculate improvement across all three objectives\n                old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                old_cost3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost3 = sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2) + (old_cost3 - new_cost3)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, j)\n\n            if best_swap is not None:\n                i, j = best_swap\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 25,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from scipy.spatial.distance import cdist\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    if len(archive) > 1:\n        archive_solutions = [sol for sol, _ in archive]\n        # Calculate crowding distance to identify less crowded solutions\n        obj_values = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(obj_values))\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(obj_values[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(obj_values) - 1):\n                crowding_distances[sorted_indices[i]] += (obj_values[sorted_indices[i+1], m] - obj_values[sorted_indices[i-1], m]) / (obj_values[sorted_indices[-1], m] - obj_values[sorted_indices[0], m] + 1e-10)\n        # Select a solution with low crowding distance (promising for improvement)\n        selected_idx = np.argmin(crowding_distances)\n        base_solution = archive_solutions[selected_idx].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a combination of 2-opt and random swap\n        if random.random() < 0.7:\n            # 2-opt move (better for TSP-like problems)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Random swap (helps escape local optima)\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6882359182772442,
            2.907805049419403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from scipy.spatial.distance import cdist\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    if len(archive) > 1:\n        archive_solutions = [sol for sol, _ in archive]\n        # Calculate crowding distance to identify less crowded solutions\n        obj_values = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(obj_values))\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(obj_values[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(obj_values) - 1):\n                crowding_distances[sorted_indices[i]] += (obj_values[sorted_indices[i+1], m] - obj_values[sorted_indices[i-1], m]) / (obj_values[sorted_indices[-1], m] - obj_values[sorted_indices[0], m] + 1e-10)\n        # Select a solution with low crowding distance (promising for improvement)\n        selected_idx = np.argmin(crowding_distances)\n        base_solution = archive_solutions[selected_idx].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a combination of 2-opt and random swap\n        if random.random() < 0.7:\n            # 2-opt move (better for TSP-like problems)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Random swap (helps escape local optima)\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 26,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total distance across all objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate normalized objectives for each solution\n    normalized_objectives = np.array(archive_objectives)\n    normalized_objectives = (normalized_objectives - normalized_objectives.min(axis=0)) / (normalized_objectives.max(axis=0) - normalized_objectives.min(axis=0) + 1e-8)\n    total_normalized = normalized_objectives.sum(axis=1)\n\n    # Select the solution with the highest potential (lowest normalized total)\n    selected_idx = np.argmin(total_normalized)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment to reverse (2-opt)\n    # 2. Randomly select two nodes to swap (swap operator)\n    # 3. Randomly select a node to relocate (insertion)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply one of the three operators randomly\n    operator = np.random.choice(['2opt', 'swap', 'insert'])\n\n    if operator == '2opt':\n        # 2-opt: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator == 'swap':\n        # Swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # insert\n        # Relocate a random node to another position\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Invalid solution (nodes missing or duplicated)\"\n\n    return new_solution\n\n",
        "score": [
            -0.6305337674587217,
            2.182977044582367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total distance across all objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate normalized objectives for each solution\n    normalized_objectives = np.array(archive_objectives)\n    normalized_objectives = (normalized_objectives - normalized_objectives.min(axis=0)) / (normalized_objectives.max(axis=0) - normalized_objectives.min(axis=0) + 1e-8)\n    total_normalized = normalized_objectives.sum(axis=1)\n\n    # Select the solution with the highest potential (lowest normalized total)\n    selected_idx = np.argmin(total_normalized)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment to reverse (2-opt)\n    # 2. Randomly select two nodes to swap (swap operator)\n    # 3. Randomly select a node to relocate (insertion)\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply one of the three operators randomly\n    operator = np.random.choice(['2opt', 'swap', 'insert'])\n\n    if operator == '2opt':\n        # 2-opt: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator == 'swap':\n        # Swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # insert\n        # Relocate a random node to another position\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Invalid solution (nodes missing or duplicated)\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 27,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the worst objective to identify solutions with room for improvement\n        archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n        selected_solution = archive_sorted[random.randint(0, len(archive_sorted) // 2)][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on the objective with the highest improvement potential\n        obj1, obj2, obj3 = archive[0][1]\n        if obj1 >= obj2 and obj1 >= obj3:\n            dm = distance_matrix_1\n        elif obj2 >= obj3:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        if i != 0 or j != n-1:  # Ensure it's a valid 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for 3-opt\n        # Perform 3-opt to explore more complex neighborhoods\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != 0 or k != n-1:  # Ensure it's a valid 3-opt move\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.6553122371087381,
            1.0869554996490478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the worst objective to identify solutions with room for improvement\n        archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n        selected_solution = archive_sorted[random.randint(0, len(archive_sorted) // 2)][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on the objective with the highest improvement potential\n        obj1, obj2, obj3 = archive[0][1]\n        if obj1 >= obj2 and obj1 >= obj3:\n            dm = distance_matrix_1\n        elif obj2 >= obj3:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        if i != 0 or j != n-1:  # Ensure it's a valid 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for 3-opt\n        # Perform 3-opt to explore more complex neighborhoods\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != 0 or k != n-1:  # Ensure it's a valid 3-opt move\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 27,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the worst objective to identify solutions with room for improvement\n        archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n        selected_solution = archive_sorted[random.randint(0, len(archive_sorted) // 2)][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on the objective with the highest improvement potential\n        obj1, obj2, obj3 = archive[0][1]\n        if obj1 >= obj2 and obj1 >= obj3:\n            dm = distance_matrix_1\n        elif obj2 >= obj3:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        if i != 0 or j != n-1:  # Ensure it's a valid 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for 3-opt\n        # Perform 3-opt to explore more complex neighborhoods\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != 0 or k != n-1:  # Ensure it's a valid 3-opt move\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.6553122371087381,
            1.0869554996490478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the worst objective to identify solutions with room for improvement\n        archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n        selected_solution = archive_sorted[random.randint(0, len(archive_sorted) // 2)][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on the objective with the highest improvement potential\n        obj1, obj2, obj3 = archive[0][1]\n        if obj1 >= obj2 and obj1 >= obj3:\n            dm = distance_matrix_1\n        elif obj2 >= obj3:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        if i != 0 or j != n-1:  # Ensure it's a valid 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for 3-opt\n        # Perform 3-opt to explore more complex neighborhoods\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != 0 or k != n-1:  # Ensure it's a valid 3-opt move\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 28,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their crowding distance (or another diversity metric)\n        sorted_archive = sorted(archive, key=lambda x: np.sum(x[1]))\n        # Select a solution from the middle of the archive (not too close to the front)\n        candidate_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[candidate_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply different operators based on the objective space\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n\n    # Randomly choose between 2-opt, 3-opt, or a custom multi-objective operator\n    operator_choice = random.choice(['2-opt', '3-opt', 'multi-objective'])\n\n    if operator_choice == '2-opt':\n        # Standard 2-opt swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif operator_choice == '3-opt':\n        # 3-opt move: select three random positions and reverse the middle segment\n        if i > j:\n            i, j = j, i\n        k = random.randint(i, j)\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n    else:\n        # Custom multi-objective operator: prioritize edges that improve at least one objective\n        best_i, best_j = i, j\n        best_improvement = 0\n\n        for _ in range(10):  # Sample a few neighbors\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i == j:\n                continue\n\n            # Calculate the change in objectives\n            delta_1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                      (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta_2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                      (distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta_3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                       distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_3[new_solution[(j-1)%n], new_solution[i]] +\n                       distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                      (distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] +\n                       distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] +\n                       distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # If at least one objective improves, consider this move\n            if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n                total_improvement = abs(delta_1) + abs(delta_2) + abs(delta_3)\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_i, best_j = i, j\n\n        # Apply the best found move\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.72006002523479,
            2.4139912962913512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their crowding distance (or another diversity metric)\n        sorted_archive = sorted(archive, key=lambda x: np.sum(x[1]))\n        # Select a solution from the middle of the archive (not too close to the front)\n        candidate_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[candidate_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply different operators based on the objective space\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n\n    # Randomly choose between 2-opt, 3-opt, or a custom multi-objective operator\n    operator_choice = random.choice(['2-opt', '3-opt', 'multi-objective'])\n\n    if operator_choice == '2-opt':\n        # Standard 2-opt swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif operator_choice == '3-opt':\n        # 3-opt move: select three random positions and reverse the middle segment\n        if i > j:\n            i, j = j, i\n        k = random.randint(i, j)\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n    else:\n        # Custom multi-objective operator: prioritize edges that improve at least one objective\n        best_i, best_j = i, j\n        best_improvement = 0\n\n        for _ in range(10):  # Sample a few neighbors\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i == j:\n                continue\n\n            # Calculate the change in objectives\n            delta_1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                      (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta_2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                      (distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta_3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                       distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_3[new_solution[(j-1)%n], new_solution[i]] +\n                       distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                      (distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] +\n                       distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] +\n                       distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # If at least one objective improves, consider this move\n            if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n                total_improvement = abs(delta_1) + abs(delta_2) + abs(delta_3)\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_i, best_j = i, j\n\n        # Apply the best found move\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards better solutions)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    worst_obj = np.argmax([obj1, obj2, obj3])\n\n    if worst_obj == 0:\n        # Improve the first objective by selecting the best possible swap\n        best_improvement = 0\n        best_swap = (0, 1)\n        for a in range(n):\n            for b in range(a + 1, n):\n                # Calculate the change in the first objective\n                delta = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[a]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # Improve the second objective\n        best_improvement = 0\n        best_swap = (0, 1)\n        for a in range(n):\n            for b in range(a + 1, n):\n                delta = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[a]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Improve the third objective\n        best_improvement = 0\n        best_swap = (0, 1)\n        for a in range(n):\n            for b in range(a + 1, n):\n                delta = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b], new_solution[a]] -\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7770018242755353,
            2.1847928881645204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards better solutions)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    worst_obj = np.argmax([obj1, obj2, obj3])\n\n    if worst_obj == 0:\n        # Improve the first objective by selecting the best possible swap\n        best_improvement = 0\n        best_swap = (0, 1)\n        for a in range(n):\n            for b in range(a + 1, n):\n                # Calculate the change in the first objective\n                delta = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[a]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # Improve the second objective\n        best_improvement = 0\n        best_swap = (0, 1)\n        for a in range(n):\n            for b in range(a + 1, n):\n                delta = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[a]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Improve the third objective\n        best_improvement = 0\n        best_swap = (0, 1)\n        for a in range(n):\n            for b in range(a + 1, n):\n                delta = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b], new_solution[a]] -\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 30,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in archive_objectives]\n\n    # Select top 20% of solutions with lowest total cost\n    top_indices = np.argsort(total_costs)[:max(1, len(archive) // 5)]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combination of 2-opt and objective-specific swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve the worst objective\n    worst_obj = np.argmax(archive_objectives[selected_idx])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    max_edge_cost = -1\n    i, j = -1, -1\n    for idx in range(n):\n        a = new_solution[idx]\n        b = new_solution[(idx + 1) % n]\n        cost = dist_matrix[a, b]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            i, j = idx, (idx + 1) % n\n\n    # Perform 2-opt on the worst edge\n    if i != -1 and j != -1:\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-specific swaps to balance objectives\n    for _ in range(3):  # Try 3 random swaps\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_costs = [\n            sum([distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]),\n            sum([distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]),\n            sum([distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n)])\n        ]\n\n        # Create potential solution\n        potential_solution = new_solution.copy()\n        potential_solution[a:b+1] = potential_solution[a:b+1][::-1]\n\n        # Calculate potential costs\n        potential_costs = [\n            sum([distance_matrix_1[potential_solution[k], potential_solution[(k+1)%n]] for k in range(n)]),\n            sum([distance_matrix_2[potential_solution[k], potential_solution[(k+1)%n]] for k in range(n)]),\n            sum([distance_matrix_3[potential_solution[k], potential_solution[(k+1)%n]] for k in range(n)])\n        ]\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(potential_costs, current_costs)):\n            new_solution = potential_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8015861661687758,
            2.3355899691581725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in archive_objectives]\n\n    # Select top 20% of solutions with lowest total cost\n    top_indices = np.argsort(total_costs)[:max(1, len(archive) // 5)]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combination of 2-opt and objective-specific swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve the worst objective\n    worst_obj = np.argmax(archive_objectives[selected_idx])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution\n    max_edge_cost = -1\n    i, j = -1, -1\n    for idx in range(n):\n        a = new_solution[idx]\n        b = new_solution[(idx + 1) % n]\n        cost = dist_matrix[a, b]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            i, j = idx, (idx + 1) % n\n\n    # Perform 2-opt on the worst edge\n    if i != -1 and j != -1:\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-specific swaps to balance objectives\n    for _ in range(3):  # Try 3 random swaps\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_costs = [\n            sum([distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]),\n            sum([distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]),\n            sum([distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n)])\n        ]\n\n        # Create potential solution\n        potential_solution = new_solution.copy()\n        potential_solution[a:b+1] = potential_solution[a:b+1][::-1]\n\n        # Calculate potential costs\n        potential_costs = [\n            sum([distance_matrix_1[potential_solution[k], potential_solution[(k+1)%n]] for k in range(n)]),\n            sum([distance_matrix_2[potential_solution[k], potential_solution[(k+1)%n]] for k in range(n)]),\n            sum([distance_matrix_3[potential_solution[k], potential_solution[(k+1)%n]] for k in range(n)])\n        ]\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(potential_costs, current_costs)):\n            new_solution = potential_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 31,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt with multi-objective edge selection\n    n = len(new_solution)\n    improved = False\n\n    # First pass: 2-opt with random edge selection\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate improvement across all three objectives\n            old_edges = [\n                (new_solution[i-1], new_solution[i], distance_matrix_1[new_solution[i-1]][new_solution[i]]),\n                (new_solution[j-1], new_solution[j], distance_matrix_2[new_solution[j-1]][new_solution[j]]),\n                (new_solution[i], new_solution[i+1], distance_matrix_3[new_solution[i]][new_solution[i+1]])\n            ]\n            new_edges = [\n                (new_solution[i-1], new_solution[j], distance_matrix_1[new_solution[i-1]][new_solution[j]]),\n                (new_solution[i], new_solution[j-1], distance_matrix_2[new_solution[i]][new_solution[j-1]]),\n                (new_solution[j], new_solution[(j+1)%n], distance_matrix_3[new_solution[j]][new_solution[(j+1)%n]])\n            ]\n\n            old_cost = sum(edge[2] for edge in old_edges)\n            new_cost = sum(edge[2] for edge in new_edges)\n\n            if new_cost < old_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                improved = True\n\n    # Second pass: Multi-objective edge improvement\n    if not improved:\n        # Calculate edge importance across all objectives\n        edge_importance = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Weighted importance calculation\n            importance = (\n                0.4 * distance_matrix_1[prev_node][node] +\n                0.3 * distance_matrix_2[prev_node][node] +\n                0.3 * distance_matrix_3[node][next_node]\n            )\n            edge_importance[i] = importance\n\n        # Select edges with lowest importance for potential improvement\n        candidate_edges = np.argsort(edge_importance)[:max(2, n//10)]\n\n        for i in candidate_edges:\n            j = (i + random.randint(2, min(5, n-1))) % n\n            if j > i:\n                # Try to improve this edge\n                temp_solution = new_solution.copy()\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[temp_solution[k-1]][temp_solution[k]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k-1]][temp_solution[k]] for k in range(n))\n                new_cost3 = sum(distance_matrix_3[temp_solution[k-1]][temp_solution[k]] for k in range(n))\n\n                # Compare with current best\n                current_cost1 = sum(distance_matrix_1[new_solution[k-1]][new_solution[k]] for k in range(n))\n                current_cost2 = sum(distance_matrix_2[new_solution[k-1]][new_solution[k]] for k in range(n))\n                current_cost3 = sum(distance_matrix_3[new_solution[k-1]][new_solution[k]] for k in range(n))\n\n                # Accept if at least one objective improves\n                if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or (new_cost3 < current_cost3):\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5617452852103659,
            2.4527467608451845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt with multi-objective edge selection\n    n = len(new_solution)\n    improved = False\n\n    # First pass: 2-opt with random edge selection\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate improvement across all three objectives\n            old_edges = [\n                (new_solution[i-1], new_solution[i], distance_matrix_1[new_solution[i-1]][new_solution[i]]),\n                (new_solution[j-1], new_solution[j], distance_matrix_2[new_solution[j-1]][new_solution[j]]),\n                (new_solution[i], new_solution[i+1], distance_matrix_3[new_solution[i]][new_solution[i+1]])\n            ]\n            new_edges = [\n                (new_solution[i-1], new_solution[j], distance_matrix_1[new_solution[i-1]][new_solution[j]]),\n                (new_solution[i], new_solution[j-1], distance_matrix_2[new_solution[i]][new_solution[j-1]]),\n                (new_solution[j], new_solution[(j+1)%n], distance_matrix_3[new_solution[j]][new_solution[(j+1)%n]])\n            ]\n\n            old_cost = sum(edge[2] for edge in old_edges)\n            new_cost = sum(edge[2] for edge in new_edges)\n\n            if new_cost < old_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                improved = True\n\n    # Second pass: Multi-objective edge improvement\n    if not improved:\n        # Calculate edge importance across all objectives\n        edge_importance = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Weighted importance calculation\n            importance = (\n                0.4 * distance_matrix_1[prev_node][node] +\n                0.3 * distance_matrix_2[prev_node][node] +\n                0.3 * distance_matrix_3[node][next_node]\n            )\n            edge_importance[i] = importance\n\n        # Select edges with lowest importance for potential improvement\n        candidate_edges = np.argsort(edge_importance)[:max(2, n//10)]\n\n        for i in candidate_edges:\n            j = (i + random.randint(2, min(5, n-1))) % n\n            if j > i:\n                # Try to improve this edge\n                temp_solution = new_solution.copy()\n                temp_solution[i:j] = temp_solution[i:j][::-1]\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[temp_solution[k-1]][temp_solution[k]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k-1]][temp_solution[k]] for k in range(n))\n                new_cost3 = sum(distance_matrix_3[temp_solution[k-1]][temp_solution[k]] for k in range(n))\n\n                # Compare with current best\n                current_cost1 = sum(distance_matrix_1[new_solution[k-1]][new_solution[k]] for k in range(n))\n                current_cost2 = sum(distance_matrix_2[new_solution[k-1]][new_solution[k]] for k in range(n))\n                current_cost3 = sum(distance_matrix_3[new_solution[k-1]][new_solution[k]] for k in range(n))\n\n                # Accept if at least one objective improves\n                if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or (new_cost3 < current_cost3):\n                    new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        if len(solutions) == 0:\n            return []\n        objectives = np.array([obj for _, obj in solutions])\n        crowding_dist = np.zeros(len(solutions))\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n        return crowding_dist\n\n    crowding_dist = crowding_distance(archive)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or node insertion\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    # Additional improvement: check if the new solution dominates the base solution\n    def dominates(obj1, obj2):\n        return all(o1 <= o2 for o1, o2 in zip(obj1, obj2)) and any(o1 < o2 for o1, o2 in zip(obj1, obj2))\n\n    base_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    )\n\n    if not dominates(new_obj, base_obj):\n        # If the new solution is not better, try another local search\n        if np.random.rand() < 0.5:\n            # Swap two nodes\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Reverse a segment\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6609016211516011,
            3.604437792301178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        if len(solutions) == 0:\n            return []\n        objectives = np.array([obj for _, obj in solutions])\n        crowding_dist = np.zeros(len(solutions))\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n        return crowding_dist\n\n    crowding_dist = crowding_distance(archive)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or node insertion\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    # Additional improvement: check if the new solution dominates the base solution\n    def dominates(obj1, obj2):\n        return all(o1 <= o2 for o1, o2 in zip(obj1, obj2)) and any(o1 < o2 for o1, o2 in zip(obj1, obj2))\n\n    base_obj = archive[selected_idx][1]\n    new_obj = (\n        sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    )\n\n    if not dominates(new_obj, base_obj):\n        # If the new solution is not better, try another local search\n        if np.random.rand() < 0.5:\n            # Swap two nodes\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Reverse a segment\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 33,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Standard 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst edge in any objective and swap it\n    worst_edges = []\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        worst_edges.append((cost1 + cost2 + cost3, k))\n\n    worst_edges.sort(reverse=True)\n    worst_idx = worst_edges[0][1]\n\n    # Swap the worst edge with a random other edge\n    swap_idx = random.randint(0, n-1)\n    while swap_idx == worst_idx or swap_idx == (worst_idx + 1) % n:\n        swap_idx = random.randint(0, n-1)\n\n    # Perform the swap\n    new_solution[worst_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_idx]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if swap causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7930594460477413,
            1.2299349546432494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Standard 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst edge in any objective and swap it\n    worst_edges = []\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        worst_edges.append((cost1 + cost2 + cost3, k))\n\n    worst_edges.sort(reverse=True)\n    worst_idx = worst_edges[0][1]\n\n    # Swap the worst edge with a random other edge\n    swap_idx = random.randint(0, n-1)\n    while swap_idx == worst_idx or swap_idx == (worst_idx + 1) % n:\n        swap_idx = random.randint(0, n-1)\n\n    # Perform the swap\n    new_solution[worst_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_idx]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if swap causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 34,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    for _ in range(3):  # Number of iterations\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Calculate improvement for each objective\n        improvements = [current - potential for current, potential in zip(current_costs, potential_costs)]\n\n        # Accept the swap if it improves at least one objective and doesn't worsen others too much\n        if (any(im > 0 for im in improvements) and\n            not any(im < -0.1 * max(current_costs) for im in improvements)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Objective-aware 2-opt move\n        k, l = sorted(random.sample(range(n), 2))\n        if k != i and l != j:\n            # Calculate current and potential costs\n            current_costs = [\n                distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                distance_matrix_1[new_solution[l-1], new_solution[l]],\n                distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                distance_matrix_2[new_solution[l-1], new_solution[l]],\n                distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                distance_matrix_3[new_solution[l-1], new_solution[l]]\n            ]\n\n            # Reverse the segment between k and l\n            reversed_segment = new_solution[k:l+1][::-1]\n            potential_costs = [\n                distance_matrix_1[new_solution[k-1], reversed_segment[0]] +\n                distance_matrix_1[reversed_segment[-1], new_solution[l]],\n                distance_matrix_2[new_solution[k-1], reversed_segment[0]] +\n                distance_matrix_2[reversed_segment[-1], new_solution[l]],\n                distance_matrix_3[new_solution[k-1], reversed_segment[0]] +\n                distance_matrix_3[reversed_segment[-1], new_solution[l]]\n            ]\n\n            improvements = [current - potential for current, potential in zip(current_costs, potential_costs)]\n\n            if (any(im > 0 for im in improvements) and\n                not any(im < -0.1 * max(current_costs) for im in improvements)):\n                new_solution[k:l+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7015677116172949,
            4.067511200904846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    for _ in range(3):  # Number of iterations\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Calculate improvement for each objective\n        improvements = [current - potential for current, potential in zip(current_costs, potential_costs)]\n\n        # Accept the swap if it improves at least one objective and doesn't worsen others too much\n        if (any(im > 0 for im in improvements) and\n            not any(im < -0.1 * max(current_costs) for im in improvements)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Objective-aware 2-opt move\n        k, l = sorted(random.sample(range(n), 2))\n        if k != i and l != j:\n            # Calculate current and potential costs\n            current_costs = [\n                distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                distance_matrix_1[new_solution[l-1], new_solution[l]],\n                distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                distance_matrix_2[new_solution[l-1], new_solution[l]],\n                distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                distance_matrix_3[new_solution[l-1], new_solution[l]]\n            ]\n\n            # Reverse the segment between k and l\n            reversed_segment = new_solution[k:l+1][::-1]\n            potential_costs = [\n                distance_matrix_1[new_solution[k-1], reversed_segment[0]] +\n                distance_matrix_1[reversed_segment[-1], new_solution[l]],\n                distance_matrix_2[new_solution[k-1], reversed_segment[0]] +\n                distance_matrix_2[reversed_segment[-1], new_solution[l]],\n                distance_matrix_3[new_solution[k-1], reversed_segment[0]] +\n                distance_matrix_3[reversed_segment[-1], new_solution[l]]\n            ]\n\n            improvements = [current - potential for current, potential in zip(current_costs, potential_costs)]\n\n            if (any(im > 0 for im in improvements) and\n                not any(im < -0.1 * max(current_costs) for im in improvements)):\n                new_solution[k:l+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 35,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] + obj[2] for _, obj in archive)\n    weights = [1 - (obj[0] + obj[1] + obj[2]) / total_cost for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with objective-aware edge selection\n    n_nodes = len(base_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Select three distinct edges to consider for 3-opt\n        i, j, k = sorted(random.sample(range(n_nodes), 3))\n\n        # Evaluate all possible 3-opt moves and select the one that improves the most across objectives\n        best_move = None\n        best_improvement = 0\n\n        # Possible 3-opt configurations\n        for config in [(i, j, k), (i, k, j)]:\n            a, b, c = config\n            # Current edges: (a, a+1), (b, b+1), (c, c+1)\n            # New edges: (a, b), (b, c), (c, a+1)\n            old_edges = [(base_solution[a], base_solution[(a+1)%n_nodes]),\n                         (base_solution[b], base_solution[(b+1)%n_nodes]),\n                         (base_solution[c], base_solution[(c+1)%n_nodes])]\n            new_edges = [(base_solution[a], base_solution[b]),\n                         (base_solution[b], base_solution[c]),\n                         (base_solution[c], base_solution[(a+1)%n_nodes])]\n\n            # Calculate improvement across all objectives\n            improvement = 0\n            for old, new in zip(old_edges, new_edges):\n                improvement += (distance_matrix_1[old[0], old[1]] - distance_matrix_1[new[0], new[1]]) + \\\n                              (distance_matrix_2[old[0], old[1]] - distance_matrix_2[new[0], new[1]]) + \\\n                              (distance_matrix_3[old[0], old[1]] - distance_matrix_3[new[0], new[1]])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = (a, b, c)\n\n        if best_move:\n            a, b, c = best_move\n            # Apply the best move\n            new_solution[a+1:b+1] = base_solution[a+1:b+1][::-1]\n            new_solution[b+1:c+1] = base_solution[b+1:c+1][::-1]\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8573281741275561,
            2.2858215808868407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] + obj[2] for _, obj in archive)\n    weights = [1 - (obj[0] + obj[1] + obj[2]) / total_cost for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with objective-aware edge selection\n    n_nodes = len(base_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Select three distinct edges to consider for 3-opt\n        i, j, k = sorted(random.sample(range(n_nodes), 3))\n\n        # Evaluate all possible 3-opt moves and select the one that improves the most across objectives\n        best_move = None\n        best_improvement = 0\n\n        # Possible 3-opt configurations\n        for config in [(i, j, k), (i, k, j)]:\n            a, b, c = config\n            # Current edges: (a, a+1), (b, b+1), (c, c+1)\n            # New edges: (a, b), (b, c), (c, a+1)\n            old_edges = [(base_solution[a], base_solution[(a+1)%n_nodes]),\n                         (base_solution[b], base_solution[(b+1)%n_nodes]),\n                         (base_solution[c], base_solution[(c+1)%n_nodes])]\n            new_edges = [(base_solution[a], base_solution[b]),\n                         (base_solution[b], base_solution[c]),\n                         (base_solution[c], base_solution[(a+1)%n_nodes])]\n\n            # Calculate improvement across all objectives\n            improvement = 0\n            for old, new in zip(old_edges, new_edges):\n                improvement += (distance_matrix_1[old[0], old[1]] - distance_matrix_1[new[0], new[1]]) + \\\n                              (distance_matrix_2[old[0], old[1]] - distance_matrix_2[new[0], new[1]]) + \\\n                              (distance_matrix_3[old[0], old[1]] - distance_matrix_3[new[0], new[1]])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = (a, b, c)\n\n        if best_move:\n            a, b, c = best_move\n            # Apply the best move\n            new_solution[a+1:b+1] = base_solution[a+1:b+1][::-1]\n            new_solution[b+1:c+1] = base_solution[b+1:c+1][::-1]\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 35,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] + obj[2] for _, obj in archive)\n    weights = [1 - (obj[0] + obj[1] + obj[2]) / total_cost for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with objective-aware edge selection\n    n_nodes = len(base_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Select three distinct edges to consider for 3-opt\n        i, j, k = sorted(random.sample(range(n_nodes), 3))\n\n        # Evaluate all possible 3-opt moves and select the one that improves the most across objectives\n        best_move = None\n        best_improvement = 0\n\n        # Possible 3-opt configurations\n        for config in [(i, j, k), (i, k, j)]:\n            a, b, c = config\n            # Current edges: (a, a+1), (b, b+1), (c, c+1)\n            # New edges: (a, b), (b, c), (c, a+1)\n            old_edges = [(base_solution[a], base_solution[(a+1)%n_nodes]),\n                         (base_solution[b], base_solution[(b+1)%n_nodes]),\n                         (base_solution[c], base_solution[(c+1)%n_nodes])]\n            new_edges = [(base_solution[a], base_solution[b]),\n                         (base_solution[b], base_solution[c]),\n                         (base_solution[c], base_solution[(a+1)%n_nodes])]\n\n            # Calculate improvement across all objectives\n            improvement = 0\n            for old, new in zip(old_edges, new_edges):\n                improvement += (distance_matrix_1[old[0], old[1]] - distance_matrix_1[new[0], new[1]]) + \\\n                              (distance_matrix_2[old[0], old[1]] - distance_matrix_2[new[0], new[1]]) + \\\n                              (distance_matrix_3[old[0], old[1]] - distance_matrix_3[new[0], new[1]])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = (a, b, c)\n\n        if best_move:\n            a, b, c = best_move\n            # Apply the best move\n            new_solution[a+1:b+1] = base_solution[a+1:b+1][::-1]\n            new_solution[b+1:c+1] = base_solution[b+1:c+1][::-1]\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8573281741275561,
            2.2858215808868407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] + obj[2] for _, obj in archive)\n    weights = [1 - (obj[0] + obj[1] + obj[2]) / total_cost for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with objective-aware edge selection\n    n_nodes = len(base_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Select three distinct edges to consider for 3-opt\n        i, j, k = sorted(random.sample(range(n_nodes), 3))\n\n        # Evaluate all possible 3-opt moves and select the one that improves the most across objectives\n        best_move = None\n        best_improvement = 0\n\n        # Possible 3-opt configurations\n        for config in [(i, j, k), (i, k, j)]:\n            a, b, c = config\n            # Current edges: (a, a+1), (b, b+1), (c, c+1)\n            # New edges: (a, b), (b, c), (c, a+1)\n            old_edges = [(base_solution[a], base_solution[(a+1)%n_nodes]),\n                         (base_solution[b], base_solution[(b+1)%n_nodes]),\n                         (base_solution[c], base_solution[(c+1)%n_nodes])]\n            new_edges = [(base_solution[a], base_solution[b]),\n                         (base_solution[b], base_solution[c]),\n                         (base_solution[c], base_solution[(a+1)%n_nodes])]\n\n            # Calculate improvement across all objectives\n            improvement = 0\n            for old, new in zip(old_edges, new_edges):\n                improvement += (distance_matrix_1[old[0], old[1]] - distance_matrix_1[new[0], new[1]]) + \\\n                              (distance_matrix_2[old[0], old[1]] - distance_matrix_2[new[0], new[1]]) + \\\n                              (distance_matrix_3[old[0], old[1]] - distance_matrix_3[new[0], new[1]])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = (a, b, c)\n\n        if best_move:\n            a, b, c = best_move\n            # Apply the best move\n            new_solution[a+1:b+1] = base_solution[a+1:b+1][::-1]\n            new_solution[b+1:c+1] = base_solution[b+1:c+1][::-1]\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 36,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the standard deviation of objectives to find diverse solutions\n        objectives = np.array([obj for _, obj in archive])\n        std_dev = np.std(objectives, axis=0)\n        # Select a solution with highest combined standard deviation\n        selected_idx = np.argmax(np.sum(objectives * std_dev, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt for one objective\n    # 2. Apply 3-opt for another objective\n    # 3. Apply edge exchange for the third objective\n\n    # Randomly select which objective to prioritize for each operation\n    obj_order = random.sample([0, 1, 2], 3)\n\n    for obj in obj_order:\n        if obj == 0:\n            # 2-opt for first objective\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            if i + 1 < j:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        elif obj == 1:\n            # 3-opt for second objective\n            i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n            if i + 1 < j < k:\n                segment1 = new_solution[i+1:j+1]\n                segment2 = new_solution[j+1:k+1]\n                new_solution[i+1:k+1] = np.concatenate([segment2, segment1[::-1]])\n        else:\n            # Edge exchange for third objective\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            if i + 1 < j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.648157186461988,
            1.9490224719047546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the standard deviation of objectives to find diverse solutions\n        objectives = np.array([obj for _, obj in archive])\n        std_dev = np.std(objectives, axis=0)\n        # Select a solution with highest combined standard deviation\n        selected_idx = np.argmax(np.sum(objectives * std_dev, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt for one objective\n    # 2. Apply 3-opt for another objective\n    # 3. Apply edge exchange for the third objective\n\n    # Randomly select which objective to prioritize for each operation\n    obj_order = random.sample([0, 1, 2], 3)\n\n    for obj in obj_order:\n        if obj == 0:\n            # 2-opt for first objective\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            if i + 1 < j:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        elif obj == 1:\n            # 3-opt for second objective\n            i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n            if i + 1 < j < k:\n                segment1 = new_solution[i+1:j+1]\n                segment2 = new_solution[j+1:k+1]\n                new_solution[i+1:k+1] = np.concatenate([segment2, segment1[::-1]])\n        else:\n            # Edge exchange for third objective\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            if i + 1 < j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 37,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by choosing one with the highest sum of objectives (worst solution)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest cost\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 >= max(obj2, obj3):\n        # 2-opt in the first objective space\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2 >= max(obj1, obj3):\n        # 2-opt in the second objective space\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 2-opt in the third objective space\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional multi-objective aware swap\n    # Select two nodes that are close in all three spaces\n    node1, node2 = np.random.choice(n, 2, replace=False)\n    if (distance_matrix_1[node1, node2] < np.mean(distance_matrix_1) and\n        distance_matrix_2[node1, node2] < np.mean(distance_matrix_2) and\n        distance_matrix_3[node1, node2] < np.mean(distance_matrix_3)):\n        new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n",
        "score": [
            -0.7591942800136782,
            1.938974964618683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by choosing one with the highest sum of objectives (worst solution)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest cost\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 >= max(obj2, obj3):\n        # 2-opt in the first objective space\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2 >= max(obj1, obj3):\n        # 2-opt in the second objective space\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 2-opt in the third objective space\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional multi-objective aware swap\n    # Select two nodes that are close in all three spaces\n    node1, node2 = np.random.choice(n, 2, replace=False)\n    if (distance_matrix_1[node1, node2] < np.mean(distance_matrix_1) and\n        distance_matrix_2[node1, node2] < np.mean(distance_matrix_2) and\n        distance_matrix_3[node1, node2] < np.mean(distance_matrix_3)):\n        new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 38,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve multiple objectives\n    # Calculate the current total cost in each objective space\n    current_cost_1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_cost_2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_cost_3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Identify edges with high contribution to any objective\n    edge_contributions = []\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        edge_contributions.append((distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v], k))\n\n    # Sort edges by their contribution to the worst objective\n    edge_contributions.sort(key=lambda x: max(x[0], x[1], x[2]), reverse=True)\n\n    # Try to improve by swapping nodes in high-contribution edges\n    for _, _, _, k in edge_contributions[:3]:  # Consider top 3 worst edges\n        u, v = new_solution[k], new_solution[(k+1)%n]\n\n        # Find a node to swap with that improves at least one objective\n        for l in range(n):\n            if l == k or l == (k+1)%n:\n                continue\n\n            w = new_solution[l]\n\n            # Calculate potential new costs\n            new_cost_1 = current_cost_1 - distance_matrix_1[u, v] - distance_matrix_1[w, new_solution[(l+1)%n]] + distance_matrix_1[u, w] + distance_matrix_1[v, new_solution[(l+1)%n]]\n            new_cost_2 = current_cost_2 - distance_matrix_2[u, v] - distance_matrix_2[w, new_solution[(l+1)%n]] + distance_matrix_2[u, w] + distance_matrix_2[v, new_solution[(l+1)%n]]\n            new_cost_3 = current_cost_3 - distance_matrix_3[u, v] - distance_matrix_3[w, new_solution[(l+1)%n]] + distance_matrix_3[u, w] + distance_matrix_3[v, new_solution[(l+1)%n]]\n\n            # If at least one objective improves, perform the swap\n            if new_cost_1 < current_cost_1 or new_cost_2 < current_cost_2 or new_cost_3 < current_cost_3:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7158086250931237,
            1.9265105724334717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve multiple objectives\n    # Calculate the current total cost in each objective space\n    current_cost_1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_cost_2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_cost_3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Identify edges with high contribution to any objective\n    edge_contributions = []\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        edge_contributions.append((distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v], k))\n\n    # Sort edges by their contribution to the worst objective\n    edge_contributions.sort(key=lambda x: max(x[0], x[1], x[2]), reverse=True)\n\n    # Try to improve by swapping nodes in high-contribution edges\n    for _, _, _, k in edge_contributions[:3]:  # Consider top 3 worst edges\n        u, v = new_solution[k], new_solution[(k+1)%n]\n\n        # Find a node to swap with that improves at least one objective\n        for l in range(n):\n            if l == k or l == (k+1)%n:\n                continue\n\n            w = new_solution[l]\n\n            # Calculate potential new costs\n            new_cost_1 = current_cost_1 - distance_matrix_1[u, v] - distance_matrix_1[w, new_solution[(l+1)%n]] + distance_matrix_1[u, w] + distance_matrix_1[v, new_solution[(l+1)%n]]\n            new_cost_2 = current_cost_2 - distance_matrix_2[u, v] - distance_matrix_2[w, new_solution[(l+1)%n]] + distance_matrix_2[u, w] + distance_matrix_2[v, new_solution[(l+1)%n]]\n            new_cost_3 = current_cost_3 - distance_matrix_3[u, v] - distance_matrix_3[w, new_solution[(l+1)%n]] + distance_matrix_3[u, w] + distance_matrix_3[v, new_solution[(l+1)%n]]\n\n            # If at least one objective improves, perform the swap\n            if new_cost_1 < current_cost_1 or new_cost_2 < current_cost_2 or new_cost_3 < current_cost_3:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 39,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the lowest objective values)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move (reverse the segment between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst edge in any of the three objectives\n    worst_obj = -1\n    worst_edge = -1\n    for k in range(n):\n        next_k = (k + 1) % n\n        current_edges = (distance_matrix_1[new_solution[k], new_solution[next_k]],\n                         distance_matrix_2[new_solution[k], new_solution[next_k]],\n                         distance_matrix_3[new_solution[k], new_solution[next_k]])\n        current_obj = sum(current_edges)\n\n        if current_obj > worst_obj:\n            worst_obj = current_obj\n            worst_edge = k\n\n    if worst_edge != -1:\n        # Find the best possible swap to replace the worst edge\n        best_improvement = 0\n        best_swap = -1\n        for m in range(n):\n            if m == worst_edge or m == (worst_edge + 1) % n:\n                continue\n            # Calculate the improvement if we swap (worst_edge) with (m)\n            new_edges = (distance_matrix_1[new_solution[worst_edge], new_solution[m]],\n                        distance_matrix_2[new_solution[worst_edge], new_solution[m]],\n                        distance_matrix_3[new_solution[worst_edge], new_solution[m]])\n            new_obj = sum(new_edges)\n\n            original_edges = (distance_matrix_1[new_solution[worst_edge], new_solution[(worst_edge + 1) % n]],\n                            distance_matrix_2[new_solution[worst_edge], new_solution[(worst_edge + 1) % n]],\n                            distance_matrix_3[new_solution[worst_edge], new_solution[(worst_edge + 1) % n]])\n            original_obj = sum(original_edges)\n\n            improvement = original_obj - new_obj\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = m\n\n        if best_swap != -1:\n            # Perform the swap\n            new_solution[worst_edge], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.6852610793663381,
            2.0706849694252014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the lowest objective values)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move (reverse the segment between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst edge in any of the three objectives\n    worst_obj = -1\n    worst_edge = -1\n    for k in range(n):\n        next_k = (k + 1) % n\n        current_edges = (distance_matrix_1[new_solution[k], new_solution[next_k]],\n                         distance_matrix_2[new_solution[k], new_solution[next_k]],\n                         distance_matrix_3[new_solution[k], new_solution[next_k]])\n        current_obj = sum(current_edges)\n\n        if current_obj > worst_obj:\n            worst_obj = current_obj\n            worst_edge = k\n\n    if worst_edge != -1:\n        # Find the best possible swap to replace the worst edge\n        best_improvement = 0\n        best_swap = -1\n        for m in range(n):\n            if m == worst_edge or m == (worst_edge + 1) % n:\n                continue\n            # Calculate the improvement if we swap (worst_edge) with (m)\n            new_edges = (distance_matrix_1[new_solution[worst_edge], new_solution[m]],\n                        distance_matrix_2[new_solution[worst_edge], new_solution[m]],\n                        distance_matrix_3[new_solution[worst_edge], new_solution[m]])\n            new_obj = sum(new_edges)\n\n            original_edges = (distance_matrix_1[new_solution[worst_edge], new_solution[(worst_edge + 1) % n]],\n                            distance_matrix_2[new_solution[worst_edge], new_solution[(worst_edge + 1) % n]],\n                            distance_matrix_3[new_solution[worst_edge], new_solution[(worst_edge + 1) % n]])\n            original_obj = sum(original_edges)\n\n            improvement = original_obj - new_obj\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = m\n\n        if best_swap != -1:\n            # Perform the swap\n            new_solution[worst_edge], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 40,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and insertion with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Choose between 2-opt and insertion based on objective diversity\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt with objective-aware edge selection\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            return new_solution  # Avoid trivial cases\n\n        # Evaluate potential improvement across all objectives\n        old_edges = [\n            (selected_solution[i-1], selected_solution[i]),\n            (selected_solution[j], selected_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (selected_solution[i-1], selected_solution[j]),\n            (selected_solution[i], selected_solution[(j+1)%n])\n        ]\n\n        # Calculate improvement potential\n        improvement = 0\n        for (u1, v1), (u2, v2) in zip(old_edges, new_edges):\n            improvement += (distance_matrix_1[u1, v1] + distance_matrix_2[u1, v1] + distance_matrix_3[u1, v1]) - \\\n                          (distance_matrix_1[u2, v2] + distance_matrix_2[u2, v2] + distance_matrix_3[u2, v2])\n\n        if improvement > 0:  # Only apply if it improves at least one objective\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insertion move with objective-aware node selection\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            return new_solution\n\n        # Remove node at position i and insert at position j\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6727289745336413,
            2.216854822635651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and insertion with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Choose between 2-opt and insertion based on objective diversity\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt with objective-aware edge selection\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            return new_solution  # Avoid trivial cases\n\n        # Evaluate potential improvement across all objectives\n        old_edges = [\n            (selected_solution[i-1], selected_solution[i]),\n            (selected_solution[j], selected_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (selected_solution[i-1], selected_solution[j]),\n            (selected_solution[i], selected_solution[(j+1)%n])\n        ]\n\n        # Calculate improvement potential\n        improvement = 0\n        for (u1, v1), (u2, v2) in zip(old_edges, new_edges):\n            improvement += (distance_matrix_1[u1, v1] + distance_matrix_2[u1, v1] + distance_matrix_3[u1, v1]) - \\\n                          (distance_matrix_1[u2, v2] + distance_matrix_2[u2, v2] + distance_matrix_3[u2, v2])\n\n        if improvement > 0:  # Only apply if it improves at least one objective\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insertion move with objective-aware node selection\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            return new_solution\n\n        # Remove node at position i and insert at position j\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 41,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Determine the best permutation of the selected edges considering all three objectives\n    # We evaluate all possible permutations (6) and select the one that improves the most in the combined objectives\n    permutations = [\n        (i, j, k), (i, k, j),\n        (j, i, k), (j, k, i),\n        (k, i, j), (k, j, i)\n    ]\n\n    best_permutation = None\n    best_improvement = 0\n\n    for perm in permutations:\n        a, b, c = perm\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_1[new_solution[c-1], new_solution[a]]) - \\\n                     (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[c-1], new_solution[a]]) - \\\n                     (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_3[new_solution[c-1], new_solution[a]]) - \\\n                     (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        # Combined improvement (simple sum of improvements)\n        improvement = -delta_obj1 - delta_obj2 - delta_obj3\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_permutation = perm\n\n    if best_permutation is not None:\n        a, b, c = best_permutation\n        # Reverse the segment between a and b, then between b and c\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7040648666567871,
            2.5523098945617675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Determine the best permutation of the selected edges considering all three objectives\n    # We evaluate all possible permutations (6) and select the one that improves the most in the combined objectives\n    permutations = [\n        (i, j, k), (i, k, j),\n        (j, i, k), (j, k, i),\n        (k, i, j), (k, j, i)\n    ]\n\n    best_permutation = None\n    best_improvement = 0\n\n    for perm in permutations:\n        a, b, c = perm\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_1[new_solution[c-1], new_solution[a]]) - \\\n                     (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[c-1], new_solution[a]]) - \\\n                     (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_3[new_solution[c-1], new_solution[a]]) - \\\n                     (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        # Combined improvement (simple sum of improvements)\n        improvement = -delta_obj1 - delta_obj2 - delta_obj3\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_permutation = perm\n\n    if best_permutation is not None:\n        a, b, c = best_permutation\n        # Reverse the segment between a and b, then between b and c\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 42,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives (promising for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # 2-opt: reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Objective-aware edge swap: try to improve the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # For the worst objective, try to find a better edge swap\n    for _ in range(10):  # Limited attempts to maintain efficiency\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost = 0\n        if worst_obj == 0:\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        elif worst_obj == 1:\n            current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        else:\n            current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        if new_cost < current_cost:\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8130247393621678,
            1.6047731041908264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives (promising for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # 2-opt: reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Objective-aware edge swap: try to improve the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # For the worst objective, try to find a better edge swap\n    for _ in range(10):  # Limited attempts to maintain efficiency\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost = 0\n        if worst_obj == 0:\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        elif worst_obj == 1:\n            current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        else:\n            current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        if new_cost < current_cost:\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 43,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one candidate\n        base_solution, _ = random.choice(candidate_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse the order\n        new_solution = new_solution[::-1]\n        return new_solution\n\n    # Choose between 2-opt and objective-aware operations with 70% probability for 2-opt\n    if random.random() < 0.7:\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware edge swap: identify edges that are Pareto-dominated in at least one objective\n        # and replace them with better edges\n        for _ in range(3):  # Try a few times\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i == j:\n                continue\n\n            # Get current edges\n            a, b = new_solution[i-1], new_solution[i]\n            c, d = new_solution[j-1], new_solution[j]\n\n            # Calculate edge costs in all three objectives\n            cost_ab = (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n            cost_cd = (distance_matrix_1[c, d], distance_matrix_2[c, d], distance_matrix_3[c, d])\n\n            # Find potential better edges\n            candidates = []\n            for k in range(n):\n                if k == i or k == j or k == i-1 or k == j-1:\n                    continue\n                e = new_solution[k]\n                f = new_solution[(k+1) % n]\n\n                # Check if this edge is better in at least one objective\n                cost_ef = (distance_matrix_1[e, f], distance_matrix_2[e, f], distance_matrix_3[e, f])\n                if any(ef < ab for ef, ab in zip(cost_ef, cost_ab)) or any(ef < cd for ef, cd in zip(cost_ef, cost_cd)):\n                    candidates.append((k, cost_ef))\n\n            if candidates:\n                # Select the best candidate based on Pareto dominance\n                best_k, _ = min(candidates, key=lambda x: sum(x[1]))\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[best_k], new_solution[(best_k+1) % n]\n\n    return new_solution\n\n",
        "score": [
            -0.7541499200865227,
            1.5136615991592408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one candidate\n        base_solution, _ = random.choice(candidate_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse the order\n        new_solution = new_solution[::-1]\n        return new_solution\n\n    # Choose between 2-opt and objective-aware operations with 70% probability for 2-opt\n    if random.random() < 0.7:\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware edge swap: identify edges that are Pareto-dominated in at least one objective\n        # and replace them with better edges\n        for _ in range(3):  # Try a few times\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i == j:\n                continue\n\n            # Get current edges\n            a, b = new_solution[i-1], new_solution[i]\n            c, d = new_solution[j-1], new_solution[j]\n\n            # Calculate edge costs in all three objectives\n            cost_ab = (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n            cost_cd = (distance_matrix_1[c, d], distance_matrix_2[c, d], distance_matrix_3[c, d])\n\n            # Find potential better edges\n            candidates = []\n            for k in range(n):\n                if k == i or k == j or k == i-1 or k == j-1:\n                    continue\n                e = new_solution[k]\n                f = new_solution[(k+1) % n]\n\n                # Check if this edge is better in at least one objective\n                cost_ef = (distance_matrix_1[e, f], distance_matrix_2[e, f], distance_matrix_3[e, f])\n                if any(ef < ab for ef, ab in zip(cost_ef, cost_ab)) or any(ef < cd for ef, cd in zip(cost_ef, cost_cd)):\n                    candidates.append((k, cost_ef))\n\n            if candidates:\n                # Select the best candidate based on Pareto dominance\n                best_k, _ = min(candidates, key=lambda x: sum(x[1]))\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[best_k], new_solution[(best_k+1) % n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 44,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most diverse solution based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt (for two objectives)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge insertion (for the third objective)\n    if n > 2:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l:\n            # Insert node at l after k\n            node = new_solution[l]\n            new_solution = np.concatenate([new_solution[:l], new_solution[l+1:]])\n            insert_pos = (k + 1) % (n - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7539221980756604,
            1.9520873188972474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most diverse solution based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt (for two objectives)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge insertion (for the third objective)\n    if n > 2:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l:\n            # Insert node at l after k\n            node = new_solution[l]\n            new_solution = np.concatenate([new_solution[:l], new_solution[l+1:]])\n            insert_pos = (k + 1) % (n - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 45,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the current best)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple local search steps\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and swapped costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        current_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        swapped_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n        # Accept if at least one objective improves\n        if (swapped_cost1 < current_cost1) or (swapped_cost2 < current_cost2) or (swapped_cost3 < current_cost3):\n            # Perform the swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional improvement: try to move a node to a better position based on all objectives\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate the change in all objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                     distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[(i+1)%n], new_solution[j]])\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[(i+1)%n], new_solution[j]])\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                     distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[(i+1)%n], new_solution[j]])\n\n            # Accept if at least one objective improves\n            if (delta1 < 0) or (delta2 < 0) or (delta3 < 0):\n                # Perform the move\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7950419868656458,
            2.9650565505027773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the current best)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple local search steps\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and swapped costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        current_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        swapped_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n        # Accept if at least one objective improves\n        if (swapped_cost1 < current_cost1) or (swapped_cost2 < current_cost2) or (swapped_cost3 < current_cost3):\n            # Perform the swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional improvement: try to move a node to a better position based on all objectives\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate the change in all objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                     distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[(i+1)%n], new_solution[j]])\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[(i+1)%n], new_solution[j]])\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                     distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[(i+1)%n], new_solution[j]])\n\n            # Accept if at least one objective improves\n            if (delta1 < 0) or (delta2 < 0) or (delta3 < 0):\n                # Perform the move\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 46,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    base_solution, _ = random.choices(archive, weights=normalized_weights, k=1)[0]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations for local search\n        # Select two distinct edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the change in each objective\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Perform the 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional diversification: apply a random 2-opt move if no improvement was made\n    if np.array_equal(new_solution, base_solution):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7597579828437696,
            1.7048830389976501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    base_solution, _ = random.choices(archive, weights=normalized_weights, k=1)[0]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations for local search\n        # Select two distinct edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the change in each objective\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Perform the 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional diversification: apply a random 2-opt move if no improvement was made\n    if np.array_equal(new_solution, base_solution):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 47,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their worst objective value (to prioritize those with room for improvement)\n        sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n        # Select a solution from the top 30% with the highest worst objective\n        candidate_solutions = sorted_archive[int(0.7 * len(archive)):]\n        selected_idx = np.random.choice(len(candidate_solutions))\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware refinement: swap nodes that improve at least one objective\n    for _ in range(3):  # Limit the number of refinement steps\n        a, b = np.random.choice(n, 2, replace=False)\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        )\n\n        # Try swapping a and b\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        new_obj = (\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        )\n\n        # Accept if at least one objective improves\n        if any(new_obj[i] < current_obj[i] for i in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6754934029171241,
            2.424430763721466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their worst objective value (to prioritize those with room for improvement)\n        sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n        # Select a solution from the top 30% with the highest worst objective\n        candidate_solutions = sorted_archive[int(0.7 * len(archive)):]\n        selected_idx = np.random.choice(len(candidate_solutions))\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware refinement: swap nodes that improve at least one objective\n    for _ in range(3):  # Limit the number of refinement steps\n        a, b = np.random.choice(n, 2, replace=False)\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        )\n\n        # Try swapping a and b\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        new_obj = (\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        )\n\n        # Accept if at least one objective improves\n        if any(new_obj[i] < current_obj[i] for i in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 48,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability for those with lower objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 - np.mean(normalized_objectives, axis=1)  # Higher score for better solutions\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then perform objective-aware edge swaps\n    for _ in range(2):  # Perform 2 edge swaps\n        # Select edges based on their potential to improve multiple objectives\n        edge_indices = random.sample(range(n), 2)\n        i, j = sorted(edge_indices)\n\n        # Calculate current edge costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        current_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate potential new edge costs\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or new_cost3 < current_cost3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8000423369855604,
            2.0548349738121034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability for those with lower objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 - np.mean(normalized_objectives, axis=1)  # Higher score for better solutions\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then perform objective-aware edge swaps\n    for _ in range(2):  # Perform 2 edge swaps\n        # Select edges based on their potential to improve multiple objectives\n        edge_indices = random.sample(range(n), 2)\n        i, j = sorted(edge_indices)\n\n        # Calculate current edge costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        current_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate potential new edge costs\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or new_cost3 < current_cost3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 49,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1.0 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly choose one of three operators with equal probability\n    operator = random.choice(['2-opt', 'swap', 'insert'])\n\n    if operator == '2-opt':\n        # 2-opt: Select two random edges and reverse the segment between them\n        i, j = sorted(random.sample(range(len(base_solution)), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'swap':\n        # Swap: Select two random nodes and swap their positions\n        i, j = random.sample(range(len(base_solution)), 2)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # insert\n        # Insert: Select a random node and insert it at a random position\n        i, j = random.sample(range(len(base_solution)), 2)\n        new_solution = base_solution.copy()\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.726258813471276,
            2.0050147414207458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1.0 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly choose one of three operators with equal probability\n    operator = random.choice(['2-opt', 'swap', 'insert'])\n\n    if operator == '2-opt':\n        # 2-opt: Select two random edges and reverse the segment between them\n        i, j = sorted(random.sample(range(len(base_solution)), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'swap':\n        # Swap: Select two random nodes and swap their positions\n        i, j = random.sample(range(len(base_solution)), 2)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # insert\n        # Insert: Select a random node and insert it at a random position\n        i, j = random.sample(range(len(base_solution)), 2)\n        new_solution = base_solution.copy()\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 50,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest average objective value)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj) / 3 for obj in archive_objectives]\n\n    # Select the solution with the lowest average objective value (most promising for improvement)\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Hybrid local search operator: 2-opt with multi-objective edge selection\n    for _ in range(10):  # Limit the number of attempts to prevent excessive computation\n        # Select two distinct edges to reverse (2-opt)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_3[base_solution[j], base_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective (non-dominated improvement)\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # If no improvement found, perform a random swap as fallback\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.602268782300083,
            3.1365795731544495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest average objective value)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj) / 3 for obj in archive_objectives]\n\n    # Select the solution with the lowest average objective value (most promising for improvement)\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Hybrid local search operator: 2-opt with multi-objective edge selection\n    for _ in range(10):  # Limit the number of attempts to prevent excessive computation\n        # Select two distinct edges to reverse (2-opt)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_3[base_solution[j], base_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective (non-dominated improvement)\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # If no improvement found, perform a random swap as fallback\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 51,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to improve the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Calculate current and potential costs\n    current_cost = (distance_matrix[new_solution[i-1], new_solution[i]] +\n                     distance_matrix[new_solution[j-1], new_solution[j]])\n    potential_cost = (distance_matrix[new_solution[i-1], new_solution[j-1]] +\n                      distance_matrix[new_solution[i], new_solution[j]])\n\n    if potential_cost < current_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional swap for multi-objective improvement\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if k != i and k != j and l != i and l != j:\n        # Calculate combined cost improvement\n        cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]])\n        cost2 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[k], new_solution[l-1]])\n\n        if cost2 < cost1:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6871996763092169,
            2.6361549615859987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to improve the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Calculate current and potential costs\n    current_cost = (distance_matrix[new_solution[i-1], new_solution[i]] +\n                     distance_matrix[new_solution[j-1], new_solution[j]])\n    potential_cost = (distance_matrix[new_solution[i-1], new_solution[j-1]] +\n                      distance_matrix[new_solution[i], new_solution[j]])\n\n    if potential_cost < current_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional swap for multi-objective improvement\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if k != i and k != j and l != i and l != j:\n        # Calculate combined cost improvement\n        cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]])\n        cost2 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[k], new_solution[l-1]])\n\n        if cost2 < cost1:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 52,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware perturbations\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply an objective-aware perturbation\n    # Calculate the current objective values\n    current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Find the worst objective and try to improve it\n    obj_values = [current_obj1, current_obj2, current_obj3]\n    worst_obj_idx = np.argmax(obj_values)\n\n    # For the worst objective, try to find a better segment\n    for _ in range(10):  # Limited attempts to keep it efficient\n        a, b = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[a:b+1][::-1]\n\n        # Calculate new objective values\n        new_obj1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_obj2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_obj3 = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if it improves the worst objective or doesn't worsen others\n        if (new_obj1 <= current_obj1 and new_obj2 <= current_obj2 and new_obj3 <= current_obj3 and\n            (new_obj1 < current_obj1 or new_obj2 < current_obj2 or new_obj3 < current_obj3)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8043285023935294,
            3.0577275156974792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware perturbations\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply an objective-aware perturbation\n    # Calculate the current objective values\n    current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Find the worst objective and try to improve it\n    obj_values = [current_obj1, current_obj2, current_obj3]\n    worst_obj_idx = np.argmax(obj_values)\n\n    # For the worst objective, try to find a better segment\n    for _ in range(10):  # Limited attempts to keep it efficient\n        a, b = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[a:b+1][::-1]\n\n        # Calculate new objective values\n        new_obj1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_obj2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_obj3 = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if it improves the worst objective or doesn't worsen others\n        if (new_obj1 <= current_obj1 and new_obj2 <= current_obj2 and new_obj3 <= current_obj3 and\n            (new_obj1 < current_obj1 or new_obj2 < current_obj2 or new_obj3 < current_obj3)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 53,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)  # Higher weight for worse solutions\n    weights /= weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt, 3-opt, and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to operate on\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Apply 2-opt or 3-opt with probability\n    if random.random() < 0.5:\n        # 2-opt: reverse a segment\n        segment = segment[::-1]\n    else:\n        # 3-opt: rotate a segment\n        k = random.randint(1, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    # Apply objective-aware swaps: swap nodes that are far apart in at least one objective space\n    for i in range(len(segment)):\n        for j in range(i+1, len(segment)):\n            node_i = segment[i]\n            node_j = segment[j]\n            # Check if nodes are far apart in any objective space\n            if (distance_matrix_1[node_i, node_j] > np.mean(distance_matrix_1) or\n                distance_matrix_2[node_i, node_j] > np.mean(distance_matrix_2) or\n                distance_matrix_3[node_i, node_j] > np.mean(distance_matrix_3)):\n                segment[i], segment[j] = segment[j], segment[i]\n                break\n\n    # Update the solution\n    new_solution[a:b+1] = segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7983543822359013,
            2.648827815055847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)  # Higher weight for worse solutions\n    weights /= weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt, 3-opt, and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to operate on\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Apply 2-opt or 3-opt with probability\n    if random.random() < 0.5:\n        # 2-opt: reverse a segment\n        segment = segment[::-1]\n    else:\n        # 3-opt: rotate a segment\n        k = random.randint(1, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    # Apply objective-aware swaps: swap nodes that are far apart in at least one objective space\n    for i in range(len(segment)):\n        for j in range(i+1, len(segment)):\n            node_i = segment[i]\n            node_j = segment[j]\n            # Check if nodes are far apart in any objective space\n            if (distance_matrix_1[node_i, node_j] > np.mean(distance_matrix_1) or\n                distance_matrix_2[node_i, node_j] > np.mean(distance_matrix_2) or\n                distance_matrix_3[node_i, node_j] > np.mean(distance_matrix_3)):\n                segment[i], segment[j] = segment[j], segment[i]\n                break\n\n    # Update the solution\n    new_solution[a:b+1] = segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 54,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(obj_ranges - (objectives - np.min(objectives, axis=0)), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps\n    for _ in range(2):  # Number of swaps to attempt\n        # Calculate current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        )\n\n        # Find the worst objective and try to improve it\n        worst_obj_idx = np.argmax(current_obj)\n        if worst_obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the best possible 2-opt move to improve the worst objective\n        best_improvement = 0\n        best_i, best_j = -1, -1\n\n        for i in range(n):\n            for j in range(i+1, n):\n                # Calculate the change in the worst objective\n                a, b, c, d = new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]\n                old_cost = dist_matrix[a, b] + dist_matrix[c, d]\n                new_cost = dist_matrix[a, c] + dist_matrix[b, d]\n                improvement = old_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6247004460032423,
            4.3116872906684875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(obj_ranges - (objectives - np.min(objectives, axis=0)), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps\n    for _ in range(2):  # Number of swaps to attempt\n        # Calculate current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        )\n\n        # Find the worst objective and try to improve it\n        worst_obj_idx = np.argmax(current_obj)\n        if worst_obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the best possible 2-opt move to improve the worst objective\n        best_improvement = 0\n        best_i, best_j = -1, -1\n\n        for i in range(n):\n            for j in range(i+1, n):\n                # Calculate the change in the worst objective\n                a, b, c, d = new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]\n                old_cost = dist_matrix[a, b] + dist_matrix[c, d]\n                new_cost = dist_matrix[a, c] + dist_matrix[b, d]\n                improvement = old_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_i != -1 and best_j != -1:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 55,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.std(objectives, axis=0))  # Sum of standard deviations across objectives\n    if diversity == 0:\n        base_idx = np.random.choice(len(archive))\n    else:\n        # Prefer solutions with higher diversity\n        weights = np.std(objectives, axis=0) / np.sum(np.std(objectives, axis=0))\n        weighted_scores = np.dot(objectives, weights)\n        base_idx = np.argmax(weighted_scores)\n\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Choose between 2-opt or insertion based on objective diversity\n    if np.random.rand() < 0.5:  # 50% chance for 2-opt\n        # 2-opt: select two random edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Insertion: remove a random node and insert it at another position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion causes duplicates\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional objective-aware perturbation\n    # Calculate objective differences for segments\n    def calculate_segment_cost(solution, start, end):\n        cost1 = distance_matrix_1[solution[start-1], solution[start]] + distance_matrix_1[solution[end], solution[(end+1)%n]]\n        cost2 = distance_matrix_2[solution[start-1], solution[start]] + distance_matrix_2[solution[end], solution[(end+1)%n]]\n        cost3 = distance_matrix_3[solution[start-1], solution[start]] + distance_matrix_3[solution[end], solution[(end+1)%n]]\n        return (cost1, cost2, cost3)\n\n    # Try to improve the worst objective\n    worst_obj = np.argmax(archive[base_idx][1])\n    if worst_obj == 0:\n        # Improve first objective\n        for _ in range(10):  # Limited attempts to avoid slowdown\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            old_cost = calculate_segment_cost(new_solution, i, j)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n            new_cost = calculate_segment_cost(temp_solution, i, j)\n            if new_cost[0] < old_cost[0]:\n                new_solution = temp_solution\n                break\n    elif worst_obj == 1:\n        # Improve second objective\n        for _ in range(10):\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            temp_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(temp_solution))\n            temp_solution = np.insert(temp_solution, pos, node)\n            old_cost = calculate_segment_cost(new_solution, k, k)\n            new_cost = calculate_segment_cost(temp_solution, pos, pos)\n            if new_cost[1] < old_cost[1]:\n                new_solution = temp_solution\n                break\n    else:\n        # Improve third objective\n        for _ in range(10):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            old_cost = calculate_segment_cost(new_solution, i, j)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n            new_cost = calculate_segment_cost(temp_solution, i, j)\n            if new_cost[2] < old_cost[2]:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7034680151105206,
            2.314683699607849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.std(objectives, axis=0))  # Sum of standard deviations across objectives\n    if diversity == 0:\n        base_idx = np.random.choice(len(archive))\n    else:\n        # Prefer solutions with higher diversity\n        weights = np.std(objectives, axis=0) / np.sum(np.std(objectives, axis=0))\n        weighted_scores = np.dot(objectives, weights)\n        base_idx = np.argmax(weighted_scores)\n\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Choose between 2-opt or insertion based on objective diversity\n    if np.random.rand() < 0.5:  # 50% chance for 2-opt\n        # 2-opt: select two random edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Insertion: remove a random node and insert it at another position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion causes duplicates\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional objective-aware perturbation\n    # Calculate objective differences for segments\n    def calculate_segment_cost(solution, start, end):\n        cost1 = distance_matrix_1[solution[start-1], solution[start]] + distance_matrix_1[solution[end], solution[(end+1)%n]]\n        cost2 = distance_matrix_2[solution[start-1], solution[start]] + distance_matrix_2[solution[end], solution[(end+1)%n]]\n        cost3 = distance_matrix_3[solution[start-1], solution[start]] + distance_matrix_3[solution[end], solution[(end+1)%n]]\n        return (cost1, cost2, cost3)\n\n    # Try to improve the worst objective\n    worst_obj = np.argmax(archive[base_idx][1])\n    if worst_obj == 0:\n        # Improve first objective\n        for _ in range(10):  # Limited attempts to avoid slowdown\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            old_cost = calculate_segment_cost(new_solution, i, j)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n            new_cost = calculate_segment_cost(temp_solution, i, j)\n            if new_cost[0] < old_cost[0]:\n                new_solution = temp_solution\n                break\n    elif worst_obj == 1:\n        # Improve second objective\n        for _ in range(10):\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            temp_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(temp_solution))\n            temp_solution = np.insert(temp_solution, pos, node)\n            old_cost = calculate_segment_cost(new_solution, k, k)\n            new_cost = calculate_segment_cost(temp_solution, pos, pos)\n            if new_cost[1] < old_cost[1]:\n                new_solution = temp_solution\n                break\n    else:\n        # Improve third objective\n        for _ in range(10):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            old_cost = calculate_segment_cost(new_solution, i, j)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n            new_cost = calculate_segment_cost(temp_solution, i, j)\n            if new_cost[2] < old_cost[2]:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 56,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware perturbation\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple 2-opt iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Evaluate the current and proposed segments\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        proposed_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[j-1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j-1]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j-1]]\n        )\n\n        # Accept if both objectives improve\n        if proposed_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware perturbation\n        if np.random.random() < 0.3:  # 30% chance to perturb\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k != l:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8047998122434252,
            1.9123841166496276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware perturbation\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple 2-opt iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Evaluate the current and proposed segments\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        proposed_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[j-1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j-1]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j-1]]\n        )\n\n        # Accept if both objectives improve\n        if proposed_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware perturbation\n        if np.random.random() < 0.3:  # 30% chance to perturb\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k != l:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 57,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high objective values)\n    objectives = [obj for _, obj in archive]\n    max_obj = max(objectives, key=lambda x: sum(x))  # Select solution with highest total objective value\n    base_solution = [sol for sol, obj in archive if obj == max_obj][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt within the selected segment\n    segment = new_solution[i:j]\n    if len(segment) > 1:\n        segment = segment[::-1]  # Reverse the segment\n        new_solution[i:j] = segment\n\n    # Apply edge insertion between segments\n    if i > 0 and j < n - 1:\n        # Try inserting a node from the segment into another position\n        if len(segment) > 0:\n            node = segment[0]\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            insert_pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.6470799348156966,
            1.0760141253471374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high objective values)\n    objectives = [obj for _, obj in archive]\n    max_obj = max(objectives, key=lambda x: sum(x))  # Select solution with highest total objective value\n    base_solution = [sol for sol, obj in archive if obj == max_obj][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt within the selected segment\n    segment = new_solution[i:j]\n    if len(segment) > 1:\n        segment = segment[::-1]  # Reverse the segment\n        new_solution[i:j] = segment\n\n    # Apply edge insertion between segments\n    if i > 0 and j < n - 1:\n        # Try inserting a node from the segment into another position\n        if len(segment) > 0:\n            node = segment[0]\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            insert_pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 57,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high objective values)\n    objectives = [obj for _, obj in archive]\n    max_obj = max(objectives, key=lambda x: sum(x))  # Select solution with highest total objective value\n    base_solution = [sol for sol, obj in archive if obj == max_obj][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt within the selected segment\n    segment = new_solution[i:j]\n    if len(segment) > 1:\n        segment = segment[::-1]  # Reverse the segment\n        new_solution[i:j] = segment\n\n    # Apply edge insertion between segments\n    if i > 0 and j < n - 1:\n        # Try inserting a node from the segment into another position\n        if len(segment) > 0:\n            node = segment[0]\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            insert_pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.6470799348156966,
            1.0760141253471374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high objective values)\n    objectives = [obj for _, obj in archive]\n    max_obj = max(objectives, key=lambda x: sum(x))  # Select solution with highest total objective value\n    base_solution = [sol for sol, obj in archive if obj == max_obj][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt within the selected segment\n    segment = new_solution[i:j]\n    if len(segment) > 1:\n        segment = segment[::-1]  # Reverse the segment\n        new_solution[i:j] = segment\n\n    # Apply edge insertion between segments\n    if i > 0 and j < n - 1:\n        # Try inserting a node from the segment into another position\n        if len(segment) > 0:\n            node = segment[0]\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            insert_pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 58,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by inverse objective values)\n    objectives = np.array([obj for (sol, obj) in archive])\n    inv_objectives = 1.0 / (objectives + 1e-6)  # Avoid division by zero\n    weights = np.sum(inv_objectives, axis=1)  # Sum of inverse objectives\n    weights = weights / np.sum(weights)  # Normalize\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k = (j + 1) % n\n\n    # Determine the best edge to reconnect based on all three objectives\n    best_obj = float('inf')\n    best_l = -1\n\n    # Evaluate all possible reconnections\n    for l in range(n):\n        if l == i or l == j or l == (i - 1) % n or l == (j + 1) % n:\n            continue\n\n        # Calculate the change in all three objectives\n        obj1 = (distance_matrix_1[new_solution[i], new_solution[l]] +\n                distance_matrix_1[new_solution[j], new_solution[(l + 1) % n]])\n        obj2 = (distance_matrix_2[new_solution[i], new_solution[l]] +\n                distance_matrix_2[new_solution[j], new_solution[(l + 1) % n]])\n        obj3 = (distance_matrix_3[new_solution[i], new_solution[l]] +\n                distance_matrix_3[new_solution[j], new_solution[(l + 1) % n]])\n\n        # Weighted sum of objectives (could be replaced with more sophisticated weighting)\n        total_obj = obj1 + obj2 + obj3\n\n        if total_obj < best_obj:\n            best_obj = total_obj\n            best_l = l\n\n    if best_l != -1:\n        # Perform the 2-opt move\n        if i < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            part1 = new_solution[i+1:]\n            part2 = new_solution[:j+1]\n            new_solution = np.concatenate([part1, part2[::-1]])\n\n    # With 50% probability, apply a second operation (either 2-opt or swap)\n    if random.random() < 0.5:\n        # 2-opt on a different segment\n        i, j = sorted(random.sample(range(n), 2))\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            part1 = new_solution[i:]\n            part2 = new_solution[:j+1]\n            new_solution = np.concatenate([part1[::-1], part2[::-1]])\n    else:\n        # Swap two nodes that are far apart in the objective spaces\n        swap_candidates = []\n        for idx in range(n):\n            node = new_solution[idx]\n            neighbors = [new_solution[(idx-1)%n], new_solution[(idx+1)%n]]\n\n            # Calculate the \"distance\" in all three objectives\n            dist1 = sum(distance_matrix_1[node, neighbor] for neighbor in neighbors)\n            dist2 = sum(distance_matrix_2[node, neighbor] for neighbor in neighbors)\n            dist3 = sum(distance_matrix_3[node, neighbor] for neighbor in neighbors)\n\n            swap_candidates.append((idx, dist1 + dist2 + dist3))\n\n        # Sort by \"distance\" and select the two farthest nodes\n        swap_candidates.sort(key=lambda x: x[1], reverse=True)\n        if len(swap_candidates) >= 2:\n            a, b = swap_candidates[0][0], swap_candidates[1][0]\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7286979688249252,
            1.8900344967842102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by inverse objective values)\n    objectives = np.array([obj for (sol, obj) in archive])\n    inv_objectives = 1.0 / (objectives + 1e-6)  # Avoid division by zero\n    weights = np.sum(inv_objectives, axis=1)  # Sum of inverse objectives\n    weights = weights / np.sum(weights)  # Normalize\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k = (j + 1) % n\n\n    # Determine the best edge to reconnect based on all three objectives\n    best_obj = float('inf')\n    best_l = -1\n\n    # Evaluate all possible reconnections\n    for l in range(n):\n        if l == i or l == j or l == (i - 1) % n or l == (j + 1) % n:\n            continue\n\n        # Calculate the change in all three objectives\n        obj1 = (distance_matrix_1[new_solution[i], new_solution[l]] +\n                distance_matrix_1[new_solution[j], new_solution[(l + 1) % n]])\n        obj2 = (distance_matrix_2[new_solution[i], new_solution[l]] +\n                distance_matrix_2[new_solution[j], new_solution[(l + 1) % n]])\n        obj3 = (distance_matrix_3[new_solution[i], new_solution[l]] +\n                distance_matrix_3[new_solution[j], new_solution[(l + 1) % n]])\n\n        # Weighted sum of objectives (could be replaced with more sophisticated weighting)\n        total_obj = obj1 + obj2 + obj3\n\n        if total_obj < best_obj:\n            best_obj = total_obj\n            best_l = l\n\n    if best_l != -1:\n        # Perform the 2-opt move\n        if i < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            part1 = new_solution[i+1:]\n            part2 = new_solution[:j+1]\n            new_solution = np.concatenate([part1, part2[::-1]])\n\n    # With 50% probability, apply a second operation (either 2-opt or swap)\n    if random.random() < 0.5:\n        # 2-opt on a different segment\n        i, j = sorted(random.sample(range(n), 2))\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            part1 = new_solution[i:]\n            part2 = new_solution[:j+1]\n            new_solution = np.concatenate([part1[::-1], part2[::-1]])\n    else:\n        # Swap two nodes that are far apart in the objective spaces\n        swap_candidates = []\n        for idx in range(n):\n            node = new_solution[idx]\n            neighbors = [new_solution[(idx-1)%n], new_solution[(idx+1)%n]]\n\n            # Calculate the \"distance\" in all three objectives\n            dist1 = sum(distance_matrix_1[node, neighbor] for neighbor in neighbors)\n            dist2 = sum(distance_matrix_2[node, neighbor] for neighbor in neighbors)\n            dist3 = sum(distance_matrix_3[node, neighbor] for neighbor in neighbors)\n\n            swap_candidates.append((idx, dist1 + dist2 + dist3))\n\n        # Sort by \"distance\" and select the two farthest nodes\n        swap_candidates.sort(key=lambda x: x[1], reverse=True)\n        if len(swap_candidates) >= 2:\n            a, b = swap_candidates[0][0], swap_candidates[1][0]\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 59,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Decide between 2-opt or edge insertion based on objective diversity\n        if np.random.rand() < 0.5:\n            # 2-opt: select two non-adjacent edges and reverse the segment between them\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i + 1 < j:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # Edge insertion: remove a node and reinsert it in a different position\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid tour length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.8317515874262529,
            1.8714964628219604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Decide between 2-opt or edge insertion based on objective diversity\n        if np.random.rand() < 0.5:\n            # 2-opt: select two non-adjacent edges and reverse the segment between them\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i + 1 < j:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # Edge insertion: remove a node and reinsert it in a different position\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid tour length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 60,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., with high diversity or low objective values)\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and objective-aware swaps\n    n = len(base_solution)\n\n    # 1. Random 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Objective-aware swap: swap nodes that are far apart in at least one objective space\n    if random.random() < 0.5:  # 50% chance to apply this\n        for _ in range(2):  # Try a few swaps\n            a, b = random.sample(range(n), 2)\n            node_a, node_b = new_solution[a], new_solution[b]\n\n            # Calculate distances in all three objective spaces\n            dist1 = distance_matrix_1[node_a, node_b]\n            dist2 = distance_matrix_2[node_a, node_b]\n            dist3 = distance_matrix_3[node_a, node_b]\n\n            # If nodes are far apart in at least one space, swap them\n            if max(dist1, dist2, dist3) > np.median(distance_matrix_1):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid.\"\n\n    return new_solution\n\n",
        "score": [
            -0.7954304412240394,
            1.4243033528327942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., with high diversity or low objective values)\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and objective-aware swaps\n    n = len(base_solution)\n\n    # 1. Random 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Objective-aware swap: swap nodes that are far apart in at least one objective space\n    if random.random() < 0.5:  # 50% chance to apply this\n        for _ in range(2):  # Try a few swaps\n            a, b = random.sample(range(n), 2)\n            node_a, node_b = new_solution[a], new_solution[b]\n\n            # Calculate distances in all three objective spaces\n            dist1 = distance_matrix_1[node_a, node_b]\n            dist2 = distance_matrix_2[node_a, node_b]\n            dist3 = distance_matrix_3[node_a, node_b]\n\n            # If nodes are far apart in at least one space, swap them\n            if max(dist1, dist2, dist3) > np.median(distance_matrix_1):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 61,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., randomly select from top 20% of archive)\n    selection_pool = sorted(archive, key=lambda x: sum(x[1]))[:max(1, len(archive) // 5)]\n    selected_solution, _ = random.choice(selection_pool)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a tailored 3-opt for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between 2-opt and 3-opt with probability favoring 3-opt for multi-objective\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # 3-opt: choose three random edges to reconfigure\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        # Create all possible 3-opt neighbors and select the one with the best combined improvement\n        neighbors = [\n            new_solution.copy(),\n            new_solution.copy(),\n            new_solution.copy()\n        ]\n\n        # Neighbor 1: reverse segment i to j\n        neighbors[0][i:j+1] = neighbors[0][i:j+1][::-1]\n        # Neighbor 2: reverse segment j to k\n        neighbors[1][j:k+1] = neighbors[1][j:k+1][::-1]\n        # Neighbor 3: reverse segment i to k\n        neighbors[2][i:k+1] = neighbors[2][i:k+1][::-1]\n\n        # Evaluate each neighbor based on all three objectives\n        best_neighbor = None\n        best_score = float('inf')\n\n        for neighbor in neighbors:\n            cost1 = sum(distance_matrix_1[neighbor[i], neighbor[i+1]] for i in range(n-1)) + distance_matrix_1[neighbor[-1], neighbor[0]]\n            cost2 = sum(distance_matrix_2[neighbor[i], neighbor[i+1]] for i in range(n-1)) + distance_matrix_2[neighbor[-1], neighbor[0]]\n            cost3 = sum(distance_matrix_3[neighbor[i], neighbor[i+1]] for i in range(n-1)) + distance_matrix_3[neighbor[-1], neighbor[0]]\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_neighbor = neighbor\n\n        if best_neighbor is not None:\n            new_solution = best_neighbor.copy()\n    else:\n        # 2-opt: choose two random edges to reconfigure\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6324960702136356,
            2.12015882730484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., randomly select from top 20% of archive)\n    selection_pool = sorted(archive, key=lambda x: sum(x[1]))[:max(1, len(archive) // 5)]\n    selected_solution, _ = random.choice(selection_pool)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a tailored 3-opt for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between 2-opt and 3-opt with probability favoring 3-opt for multi-objective\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # 3-opt: choose three random edges to reconfigure\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        # Create all possible 3-opt neighbors and select the one with the best combined improvement\n        neighbors = [\n            new_solution.copy(),\n            new_solution.copy(),\n            new_solution.copy()\n        ]\n\n        # Neighbor 1: reverse segment i to j\n        neighbors[0][i:j+1] = neighbors[0][i:j+1][::-1]\n        # Neighbor 2: reverse segment j to k\n        neighbors[1][j:k+1] = neighbors[1][j:k+1][::-1]\n        # Neighbor 3: reverse segment i to k\n        neighbors[2][i:k+1] = neighbors[2][i:k+1][::-1]\n\n        # Evaluate each neighbor based on all three objectives\n        best_neighbor = None\n        best_score = float('inf')\n\n        for neighbor in neighbors:\n            cost1 = sum(distance_matrix_1[neighbor[i], neighbor[i+1]] for i in range(n-1)) + distance_matrix_1[neighbor[-1], neighbor[0]]\n            cost2 = sum(distance_matrix_2[neighbor[i], neighbor[i+1]] for i in range(n-1)) + distance_matrix_2[neighbor[-1], neighbor[0]]\n            cost3 = sum(distance_matrix_3[neighbor[i], neighbor[i+1]] for i in range(n-1)) + distance_matrix_3[neighbor[-1], neighbor[0]]\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_neighbor = neighbor\n\n        if best_neighbor is not None:\n            new_solution = best_neighbor.copy()\n    else:\n        # 2-opt: choose two random edges to reconfigure\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 62,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, objective_variances)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve the worst-performing objective\n    worst_obj_idx = np.argmax(objectives[selected_idx])\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the worst objective\n    best_improvement = 0\n    best_i, best_j = 0, 0\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            if j == n - 1 and i == 0:\n                continue  # Skip full cycle reversal\n            old_dist = dist_matrix[new_solution[i], new_solution[i+1]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n            new_dist = dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[i+1], new_solution[(j+1)%n]]\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Perform objective-aware swaps for other objectives\n    for _ in range(2):  # Limit to a few swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement for all objectives\n        improvements = []\n        for k in range(3):\n            if k == 0:\n                dm = distance_matrix_1\n            elif k == 1:\n                dm = distance_matrix_2\n            else:\n                dm = distance_matrix_3\n\n            old_dist = dm[new_solution[i], new_solution[(i+1)%n]] + dm[new_solution[j], new_solution[(j+1)%n]]\n            new_dist = dm[new_solution[i], new_solution[j]] + dm[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            improvements.append(old_dist - new_dist)\n\n        # Accept if improves at least one objective\n        if any(imp > 0 for imp in improvements):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5816328764449173,
            3.265143942832947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, objective_variances)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve the worst-performing objective\n    worst_obj_idx = np.argmax(objectives[selected_idx])\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the worst objective\n    best_improvement = 0\n    best_i, best_j = 0, 0\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            if j == n - 1 and i == 0:\n                continue  # Skip full cycle reversal\n            old_dist = dist_matrix[new_solution[i], new_solution[i+1]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n            new_dist = dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[i+1], new_solution[(j+1)%n]]\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Perform objective-aware swaps for other objectives\n    for _ in range(2):  # Limit to a few swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement for all objectives\n        improvements = []\n        for k in range(3):\n            if k == 0:\n                dm = distance_matrix_1\n            elif k == 1:\n                dm = distance_matrix_2\n            else:\n                dm = distance_matrix_3\n\n            old_dist = dm[new_solution[i], new_solution[(i+1)%n]] + dm[new_solution[j], new_solution[(j+1)%n]]\n            new_dist = dm[new_solution[i], new_solution[j]] + dm[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            improvements.append(old_dist - new_dist)\n\n        # Accept if improves at least one objective\n        if any(imp > 0 for imp in improvements):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 63,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between two operators\n    if random.random() < 0.5:\n        # 2-opt: swap two edges\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware edge swap: find the worst edge in any objective and swap it\n        worst_edge = -1\n        worst_obj = -1\n        for i in range(n):\n            j = (i + 1) % n\n            node_i, node_j = new_solution[i], new_solution[j]\n            # Calculate edge costs in all three objectives\n            cost1 = distance_matrix_1[node_i, node_j]\n            cost2 = distance_matrix_2[node_i, node_j]\n            cost3 = distance_matrix_3[node_i, node_j]\n            total_cost = cost1 + cost2 + cost3\n            if total_cost > worst_obj:\n                worst_obj = total_cost\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Find the best possible swap for this edge\n            best_improvement = 0\n            best_swap = None\n            for i in range(n):\n                if i == worst_edge or (i + 1) % n == worst_edge:\n                    continue\n                # Try swapping worst_edge with i\n                temp_solution = new_solution.copy()\n                temp_solution[worst_edge], temp_solution[i] = temp_solution[i], temp_solution[worst_edge]\n                # Calculate new costs\n                new_cost1 = (distance_matrix_1[temp_solution[worst_edge], temp_solution[(worst_edge+1)%n]] +\n                            distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]])\n                old_cost1 = (distance_matrix_1[new_solution[worst_edge], new_solution[(worst_edge+1)%n]] +\n                            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n                improvement1 = old_cost1 - new_cost1\n\n                new_cost2 = (distance_matrix_2[temp_solution[worst_edge], temp_solution[(worst_edge+1)%n]] +\n                            distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]])\n                old_cost2 = (distance_matrix_2[new_solution[worst_edge], new_solution[(worst_edge+1)%n]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n                improvement2 = old_cost2 - new_cost2\n\n                new_cost3 = (distance_matrix_3[temp_solution[worst_edge], temp_solution[(worst_edge+1)%n]] +\n                            distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]])\n                old_cost3 = (distance_matrix_3[new_solution[worst_edge], new_solution[(worst_edge+1)%n]] +\n                            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n                improvement3 = old_cost3 - new_cost3\n\n                total_improvement = improvement1 + improvement2 + improvement3\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_swap = i\n\n            if best_swap is not None:\n                new_solution[worst_edge], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.7520848813014106,
            1.4973788499832152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between two operators\n    if random.random() < 0.5:\n        # 2-opt: swap two edges\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware edge swap: find the worst edge in any objective and swap it\n        worst_edge = -1\n        worst_obj = -1\n        for i in range(n):\n            j = (i + 1) % n\n            node_i, node_j = new_solution[i], new_solution[j]\n            # Calculate edge costs in all three objectives\n            cost1 = distance_matrix_1[node_i, node_j]\n            cost2 = distance_matrix_2[node_i, node_j]\n            cost3 = distance_matrix_3[node_i, node_j]\n            total_cost = cost1 + cost2 + cost3\n            if total_cost > worst_obj:\n                worst_obj = total_cost\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Find the best possible swap for this edge\n            best_improvement = 0\n            best_swap = None\n            for i in range(n):\n                if i == worst_edge or (i + 1) % n == worst_edge:\n                    continue\n                # Try swapping worst_edge with i\n                temp_solution = new_solution.copy()\n                temp_solution[worst_edge], temp_solution[i] = temp_solution[i], temp_solution[worst_edge]\n                # Calculate new costs\n                new_cost1 = (distance_matrix_1[temp_solution[worst_edge], temp_solution[(worst_edge+1)%n]] +\n                            distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]])\n                old_cost1 = (distance_matrix_1[new_solution[worst_edge], new_solution[(worst_edge+1)%n]] +\n                            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n                improvement1 = old_cost1 - new_cost1\n\n                new_cost2 = (distance_matrix_2[temp_solution[worst_edge], temp_solution[(worst_edge+1)%n]] +\n                            distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]])\n                old_cost2 = (distance_matrix_2[new_solution[worst_edge], new_solution[(worst_edge+1)%n]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n                improvement2 = old_cost2 - new_cost2\n\n                new_cost3 = (distance_matrix_3[temp_solution[worst_edge], temp_solution[(worst_edge+1)%n]] +\n                            distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]])\n                old_cost3 = (distance_matrix_3[new_solution[worst_edge], new_solution[(worst_edge+1)%n]] +\n                            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n                improvement3 = old_cost3 - new_cost3\n\n                total_improvement = improvement1 + improvement2 + improvement3\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_swap = i\n\n            if best_swap is not None:\n                new_solution[worst_edge], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 64,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% to encourage exploration\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one solution from the pool\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution, _ = archive[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. With 70% probability, perform a 2-opt move\n    # 2. With 30% probability, perform a 3-opt move\n    if random.random() < 0.7:\n        # 2-opt move\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Generated solution is not feasible\"\n    assert len(new_solution) == len(instance), \"Generated solution is not a complete tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.6974511603531321,
            1.6895817995071412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% to encourage exploration\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one solution from the pool\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution, _ = archive[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. With 70% probability, perform a 2-opt move\n    # 2. With 30% probability, perform a 3-opt move\n    if random.random() < 0.7:\n        # 2-opt move\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Generated solution is not feasible\"\n    assert len(new_solution) == len(instance), \"Generated solution is not a complete tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 65,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with high potential for improvement\n    # Here, we select a solution that has the highest sum of objectives, as it likely has room for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform a 2-opt move (local improvement for one objective)\n    # 2. Apply a segment inversion (local improvement for another objective)\n    # 3. Combine with a random swap for the third objective\n\n    # 1. 2-opt move for the first objective\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Segment inversion for the second objective\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # 3. Random swap for the third objective\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If duplicates exist, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5303006333702256,
            1.7999713659286498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with high potential for improvement\n    # Here, we select a solution that has the highest sum of objectives, as it likely has room for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform a 2-opt move (local improvement for one objective)\n    # 2. Apply a segment inversion (local improvement for another objective)\n    # 3. Combine with a random swap for the third objective\n\n    # 1. 2-opt move for the first objective\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Segment inversion for the second objective\n    segment_size = max(2, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # 3. Random swap for the third objective\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If duplicates exist, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 66,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional objective-aware refinement: swap nodes that improve at least one objective\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate original and swapped costs for all three objectives\n        orig_cost1 = distance_matrix_1[new_solution[a-1], node_a] + distance_matrix_1[node_a, new_solution[(a+1)%n]]\n        orig_cost2 = distance_matrix_2[new_solution[a-1], node_a] + distance_matrix_2[node_a, new_solution[(a+1)%n]]\n        orig_cost3 = distance_matrix_3[new_solution[a-1], node_a] + distance_matrix_3[node_a, new_solution[(a+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], node_b] + distance_matrix_1[node_b, new_solution[(a+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], node_b] + distance_matrix_2[node_b, new_solution[(a+1)%n]]\n        new_cost3 = distance_matrix_3[new_solution[a-1], node_b] + distance_matrix_3[node_b, new_solution[(a+1)%n]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < orig_cost1 or new_cost2 < orig_cost2 or new_cost3 < orig_cost3):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7017603325405698,
            1.7629212856292724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional objective-aware refinement: swap nodes that improve at least one objective\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate original and swapped costs for all three objectives\n        orig_cost1 = distance_matrix_1[new_solution[a-1], node_a] + distance_matrix_1[node_a, new_solution[(a+1)%n]]\n        orig_cost2 = distance_matrix_2[new_solution[a-1], node_a] + distance_matrix_2[node_a, new_solution[(a+1)%n]]\n        orig_cost3 = distance_matrix_3[new_solution[a-1], node_a] + distance_matrix_3[node_a, new_solution[(a+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], node_b] + distance_matrix_1[node_b, new_solution[(a+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], node_b] + distance_matrix_2[node_b, new_solution[(a+1)%n]]\n        new_cost3 = distance_matrix_3[new_solution[a-1], node_b] + distance_matrix_3[node_b, new_solution[(a+1)%n]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < orig_cost1 or new_cost2 < orig_cost2 or new_cost3 < orig_cost3):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 67,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already well-optimized in all objectives)\n    selected = max(archive, key=lambda x: sum(x[1]) / max(x[1]) if max(x[1]) != 0 else 0)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: 2-opt with objective-aware perturbation\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate potential improvement in each objective\n    obj1_before = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2_before = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3_before = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate new objectives\n    obj1_after = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2_after = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3_after = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # If no improvement in any objective, try a different operator\n    if (obj1_after >= obj1_before and obj2_after >= obj2_before and obj3_after >= obj3_before):\n        # Try a 3-opt move (more disruptive but potentially better)\n        a, b, c = np.random.choice(n, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.6763933301001875,
            1.7064177632331847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already well-optimized in all objectives)\n    selected = max(archive, key=lambda x: sum(x[1]) / max(x[1]) if max(x[1]) != 0 else 0)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: 2-opt with objective-aware perturbation\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate potential improvement in each objective\n    obj1_before = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2_before = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3_before = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate new objectives\n    obj1_after = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2_after = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3_after = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # If no improvement in any objective, try a different operator\n    if (obj1_after >= obj1_before and obj2_after >= obj2_before and obj3_after >= obj3_before):\n        # Try a 3-opt move (more disruptive but potentially better)\n        a, b, c = np.random.choice(n, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 68,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Criteria: solutions with higher total distance in any objective space\n    max_total = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        total = sum(obj)\n        if total > max_total:\n            max_total = total\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Determine which objective space has the highest distance\n        obj = archive[selected_idx][1]\n        max_obj_idx = np.argmax(obj)\n\n        # Use 2-opt with the distance matrix corresponding to the worst objective\n        if max_obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif max_obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Select two random edges to swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure we're not selecting adjacent edges\n        if abs(a - b) > 1 and abs(c - d) > 1:\n            # Perform 2-opt swap\n            new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n            new_solution[c:d+1] = np.flip(new_solution[c:d+1])\n        else:\n            # Fallback to segment reversal if edges are adjacent\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.6778585376250928,
            1.7016661405563354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Criteria: solutions with higher total distance in any objective space\n    max_total = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        total = sum(obj)\n        if total > max_total:\n            max_total = total\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Determine which objective space has the highest distance\n        obj = archive[selected_idx][1]\n        max_obj_idx = np.argmax(obj)\n\n        # Use 2-opt with the distance matrix corresponding to the worst objective\n        if max_obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif max_obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Select two random edges to swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure we're not selecting adjacent edges\n        if abs(a - b) > 1 and abs(c - d) > 1:\n            # Perform 2-opt swap\n            new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n            new_solution[c:d+1] = np.flip(new_solution[c:d+1])\n        else:\n            # Fallback to segment reversal if edges are adjacent\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 69,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    candidate_indices = [i for i, obj in enumerate(objectives) if any(o > avg for o, avg in zip(obj, avg_objectives))]\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to improve the worst objective\n    worst_obj = np.argmax(archive[selected_idx][1])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Calculate potential improvement\n    a, b = new_solution[i-1], new_solution[i]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n    current_cost = dist_matrix[a, b] + dist_matrix[c, d]\n    new_cost = dist_matrix[a, c] + dist_matrix[b, d]\n\n    if new_cost < current_cost:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: swap nodes that are improving at least one objective\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    a, b = new_solution[k], new_solution[l]\n\n    # Check if swap improves any objective\n    cost1 = (distance_matrix_1[new_solution[k-1], a] + distance_matrix_1[a, new_solution[(k+1)%n]] +\n             distance_matrix_1[new_solution[l-1], b] + distance_matrix_1[b, new_solution[(l+1)%n]])\n    cost2 = (distance_matrix_1[new_solution[k-1], b] + distance_matrix_1[b, new_solution[(k+1)%n]] +\n             distance_matrix_1[new_solution[l-1], a] + distance_matrix_1[a, new_solution[(l+1)%n]])\n\n    if cost2 < cost1:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6850910951375258,
            3.2984283447265623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    candidate_indices = [i for i, obj in enumerate(objectives) if any(o > avg for o, avg in zip(obj, avg_objectives))]\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to improve the worst objective\n    worst_obj = np.argmax(archive[selected_idx][1])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Calculate potential improvement\n    a, b = new_solution[i-1], new_solution[i]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n    current_cost = dist_matrix[a, b] + dist_matrix[c, d]\n    new_cost = dist_matrix[a, c] + dist_matrix[b, d]\n\n    if new_cost < current_cost:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: swap nodes that are improving at least one objective\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    a, b = new_solution[k], new_solution[l]\n\n    # Check if swap improves any objective\n    cost1 = (distance_matrix_1[new_solution[k-1], a] + distance_matrix_1[a, new_solution[(k+1)%n]] +\n             distance_matrix_1[new_solution[l-1], b] + distance_matrix_1[b, new_solution[(l+1)%n]])\n    cost2 = (distance_matrix_1[new_solution[k-1], b] + distance_matrix_1[b, new_solution[(k+1)%n]] +\n             distance_matrix_1[new_solution[l-1], a] + distance_matrix_1[a, new_solution[(l+1)%n]])\n\n    if cost2 < cost1:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 70,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives to focus on less optimized solutions\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    objective_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(objective_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt for one objective and 3-opt for another\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose which objective to focus on for the local search\n    objective_choice = np.random.choice([0, 1, 2])\n\n    if objective_choice == 0:\n        # 2-opt for the first objective\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif objective_choice == 1:\n        # 3-opt for the second objective\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n    else:\n        # Mixed 2-opt and 3-opt for the third objective\n        if np.random.random() < 0.5:\n            # 2-opt\n            i, j = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt\n            i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.6870458796911628,
            1.9886632204055785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives to focus on less optimized solutions\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    objective_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(objective_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt for one objective and 3-opt for another\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose which objective to focus on for the local search\n    objective_choice = np.random.choice([0, 1, 2])\n\n    if objective_choice == 0:\n        # 2-opt for the first objective\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif objective_choice == 1:\n        # 3-opt for the second objective\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n    else:\n        # Mixed 2-opt and 3-opt for the third objective\n        if np.random.random() < 0.5:\n            # 2-opt\n            i, j = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt\n            i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 71,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    if len(archive) > 1:\n        # Sort solutions by a combination of objectives (e.g., sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the archive (not too good, not too bad)\n        base_solution = archive_sorted[min(len(archive_sorted) // 2, len(archive_sorted) - 1)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a segment\n        i, j = random.sample(range(n), 2)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware edge selection: choose edges that could improve multiple objectives\n        # Calculate edge costs in all three objectives\n        edge_costs = np.zeros((n, 3))\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i + 1) % n]\n            edge_costs[i, 0] = distance_matrix_1[u, v]\n            edge_costs[i, 1] = distance_matrix_2[u, v]\n            edge_costs[i, 2] = distance_matrix_3[u, v]\n\n        # Find edges that are relatively worse in multiple objectives\n        worst_edges = np.where(np.sum(edge_costs > np.percentile(edge_costs, 75, axis=0), axis=1) >= 2)[0]\n\n        if len(worst_edges) > 0:\n            # Select a random edge from the worst edges\n            edge_idx = random.choice(worst_edges)\n            i, j = edge_idx, (edge_idx + 1) % n\n\n            # Perform 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # If no edges are worse in multiple objectives, perform a random 2-opt\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7120551015849855,
            1.8843611359596253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    if len(archive) > 1:\n        # Sort solutions by a combination of objectives (e.g., sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the archive (not too good, not too bad)\n        base_solution = archive_sorted[min(len(archive_sorted) // 2, len(archive_sorted) - 1)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a segment\n        i, j = random.sample(range(n), 2)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware edge selection: choose edges that could improve multiple objectives\n        # Calculate edge costs in all three objectives\n        edge_costs = np.zeros((n, 3))\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i + 1) % n]\n            edge_costs[i, 0] = distance_matrix_1[u, v]\n            edge_costs[i, 1] = distance_matrix_2[u, v]\n            edge_costs[i, 2] = distance_matrix_3[u, v]\n\n        # Find edges that are relatively worse in multiple objectives\n        worst_edges = np.where(np.sum(edge_costs > np.percentile(edge_costs, 75, axis=0), axis=1) >= 2)[0]\n\n        if len(worst_edges) > 0:\n            # Select a random edge from the worst edges\n            edge_idx = random.choice(worst_edges)\n            i, j = edge_idx, (edge_idx + 1) % n\n\n            # Perform 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # If no edges are worse in multiple objectives, perform a random 2-opt\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 72,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances for each objective\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for i in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            sorted_objectives = objectives[sorted_indices, i]\n\n            # Handle edge cases\n            if len(sorted_indices) == 1:\n                crowding_distances[sorted_indices[0]] += 1.0\n                continue\n\n            # Calculate crowding distance for each solution\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            for j in range(1, len(sorted_indices) - 1):\n                if sorted_objectives[-1] == sorted_objectives[0]:\n                    crowding_distances[sorted_indices[j]] += 0.0\n                else:\n                    crowding_distances[sorted_indices[j]] += (sorted_objectives[j+1] - sorted_objectives[j-1]) / (sorted_objectives[-1] - sorted_objectives[0])\n\n        # Select the solution with the highest crowding distance (most diverse)\n        selected_index = np.argmax(crowding_distances)\n        base_solution = archive[selected_index][0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(np.random.choice(n_nodes, 3, replace=False))\n\n    # Determine the best possible reconnection based on all three objectives\n    # We consider all possible reconnections and choose the one that improves the most objectives\n    best_reconnection = None\n    best_improvement = -np.inf\n\n    # Try all possible 3-opt moves\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a == b:\n                continue\n            for c in [i, j, k]:\n                if c in [a, b]:\n                    continue\n\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                candidate[a:b] = np.flip(candidate[a:b])\n                candidate[b:c] = np.flip(candidate[b:c])\n\n                # Calculate the change in all three objectives\n                old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n                old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n                old_cost3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]] + distance_matrix_3[new_solution[c-1], new_solution[c]]\n\n                new_cost1 = distance_matrix_1[candidate[a-1], candidate[a]] + distance_matrix_1[candidate[b-1], candidate[b]] + distance_matrix_1[candidate[c-1], candidate[c]]\n                new_cost2 = distance_matrix_2[candidate[a-1], candidate[a]] + distance_matrix_2[candidate[b-1], candidate[b]] + distance_matrix_2[candidate[c-1], candidate[c]]\n                new_cost3 = distance_matrix_3[candidate[a-1], candidate[a]] + distance_matrix_3[candidate[b-1], candidate[b]] + distance_matrix_3[candidate[c-1], candidate[c]]\n\n                # Calculate the number of objectives improved\n                improvement = (old_cost1 - new_cost1 > 0) + (old_cost2 - new_cost2 > 0) + (old_cost3 - new_cost3 > 0)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_reconnection = candidate.copy()\n\n    if best_reconnection is not None:\n        new_solution = best_reconnection\n\n    return new_solution\n\n",
        "score": [
            -0.4609051209275169,
            2.9577832341194155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances for each objective\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for i in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            sorted_objectives = objectives[sorted_indices, i]\n\n            # Handle edge cases\n            if len(sorted_indices) == 1:\n                crowding_distances[sorted_indices[0]] += 1.0\n                continue\n\n            # Calculate crowding distance for each solution\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            for j in range(1, len(sorted_indices) - 1):\n                if sorted_objectives[-1] == sorted_objectives[0]:\n                    crowding_distances[sorted_indices[j]] += 0.0\n                else:\n                    crowding_distances[sorted_indices[j]] += (sorted_objectives[j+1] - sorted_objectives[j-1]) / (sorted_objectives[-1] - sorted_objectives[0])\n\n        # Select the solution with the highest crowding distance (most diverse)\n        selected_index = np.argmax(crowding_distances)\n        base_solution = archive[selected_index][0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(np.random.choice(n_nodes, 3, replace=False))\n\n    # Determine the best possible reconnection based on all three objectives\n    # We consider all possible reconnections and choose the one that improves the most objectives\n    best_reconnection = None\n    best_improvement = -np.inf\n\n    # Try all possible 3-opt moves\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a == b:\n                continue\n            for c in [i, j, k]:\n                if c in [a, b]:\n                    continue\n\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                candidate[a:b] = np.flip(candidate[a:b])\n                candidate[b:c] = np.flip(candidate[b:c])\n\n                # Calculate the change in all three objectives\n                old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n                old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n                old_cost3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]] + distance_matrix_3[new_solution[c-1], new_solution[c]]\n\n                new_cost1 = distance_matrix_1[candidate[a-1], candidate[a]] + distance_matrix_1[candidate[b-1], candidate[b]] + distance_matrix_1[candidate[c-1], candidate[c]]\n                new_cost2 = distance_matrix_2[candidate[a-1], candidate[a]] + distance_matrix_2[candidate[b-1], candidate[b]] + distance_matrix_2[candidate[c-1], candidate[c]]\n                new_cost3 = distance_matrix_3[candidate[a-1], candidate[a]] + distance_matrix_3[candidate[b-1], candidate[b]] + distance_matrix_3[candidate[c-1], candidate[c]]\n\n                # Calculate the number of objectives improved\n                improvement = (old_cost1 - new_cost1 > 0) + (old_cost2 - new_cost2 > 0) + (old_cost3 - new_cost3 > 0)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_reconnection = candidate.copy()\n\n    if best_reconnection is not None:\n        new_solution = best_reconnection\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 73,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., worst in one objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap\n        candidate = new_solution.copy()\n        candidate[i:j+1] = np.flip(candidate[i:j+1])\n\n        # Objective-aware swap\n        if np.random.rand() < 0.5:\n            candidate[k], candidate[l] = candidate[l], candidate[k]\n\n        # Check feasibility and improvement\n        if len(np.unique(candidate)) == n:  # Valid tour\n            # Calculate new objectives\n            obj1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            obj2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            obj3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Accept if better in at least one objective\n            if obj1 <= archive[selected_idx][1][0] or obj2 <= archive[selected_idx][1][1] or obj3 <= archive[selected_idx][1][2]:\n                new_solution = candidate\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5157349446151447,
            2.0931026339530945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., worst in one objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap\n        candidate = new_solution.copy()\n        candidate[i:j+1] = np.flip(candidate[i:j+1])\n\n        # Objective-aware swap\n        if np.random.rand() < 0.5:\n            candidate[k], candidate[l] = candidate[l], candidate[k]\n\n        # Check feasibility and improvement\n        if len(np.unique(candidate)) == n:  # Valid tour\n            # Calculate new objectives\n            obj1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            obj2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            obj3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Accept if better in at least one objective\n            if obj1 <= archive[selected_idx][1][0] or obj2 <= archive[selected_idx][1][1] or obj3 <= archive[selected_idx][1][2]:\n                new_solution = candidate\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 74,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_indices = np.argmax(objectives, axis=0)  # Find indices of worst solutions for each objective\n    candidate_indices = np.unique(worst_obj_indices)  # Get unique candidate solutions\n\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(archive))\n\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware edge swap\n    # Calculate the current objective values\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Try to find a better edge swap by considering all three objectives\n    for _ in range(10):  # Limit the number of attempts to keep it efficient\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        if a == c and b == d:\n            continue  # Skip if same edges\n\n        # Create a candidate solution\n        candidate_solution = new_solution.copy()\n        candidate_solution[a], candidate_solution[b] = candidate_solution[b], candidate_solution[a]\n        candidate_solution[c], candidate_solution[d] = candidate_solution[d], candidate_solution[c]\n\n        # Calculate the new objective\n        candidate_obj = calculate_objective(candidate_solution)\n\n        # Accept if at least one objective improves\n        if any(candidate_obj[i] < current_obj[i] for i in range(3)):\n            new_solution = candidate_solution\n            current_obj = candidate_obj\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7045856198305029,
            1.7683941960334777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the worst-performing objective\n    objectives = np.array([obj for _, obj in archive])\n    worst_obj_indices = np.argmax(objectives, axis=0)  # Find indices of worst solutions for each objective\n    candidate_indices = np.unique(worst_obj_indices)  # Get unique candidate solutions\n\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(archive))\n\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware edge swap\n    # Calculate the current objective values\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Try to find a better edge swap by considering all three objectives\n    for _ in range(10):  # Limit the number of attempts to keep it efficient\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        if a == c and b == d:\n            continue  # Skip if same edges\n\n        # Create a candidate solution\n        candidate_solution = new_solution.copy()\n        candidate_solution[a], candidate_solution[b] = candidate_solution[b], candidate_solution[a]\n        candidate_solution[c], candidate_solution[d] = candidate_solution[d], candidate_solution[c]\n\n        # Calculate the new objective\n        candidate_obj = calculate_objective(candidate_solution)\n\n        # Accept if at least one objective improves\n        if any(candidate_obj[i] < current_obj[i] for i in range(3)):\n            new_solution = candidate_solution\n            current_obj = candidate_obj\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 75,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest average distance)\n    objectives = np.array([obj for _, obj in archive])\n    avg_distances = np.mean(objectives, axis=1)\n    selected_idx = np.argmin(avg_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move on the edge with the highest combined distance across objectives\n    max_edge_idx = -1\n    max_edge_cost = -1\n\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        cost = distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            max_edge_idx = i\n\n    # Perform the 2-opt move\n    if max_edge_idx != -1:\n        i = max_edge_idx\n        j = (i + 1) % n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then, perform an objective-aware edge swap to balance the objectives\n    # Find the edge that has the highest difference between the three objectives\n    max_diff_idx = -1\n    max_diff = -1\n\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        costs = [\n            distance_matrix_1[u, v],\n            distance_matrix_2[u, v],\n            distance_matrix_3[u, v]\n        ]\n        diff = max(costs) - min(costs)\n        if diff > max_diff:\n            max_diff = diff\n            max_diff_idx = i\n\n    # Perform the swap if it improves the most imbalanced edge\n    if max_diff_idx != -1:\n        i = max_diff_idx\n        j = (i + 1) % n\n        # Try swapping with a random node that could potentially balance the objectives\n        k = np.random.randint(0, n)\n        if k != i and k != j and k != (i - 1) % n and k != (j + 1) % n:\n            # Perform a 2-opt between i and k\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5065810357399113,
            2.376887011528015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest average distance)\n    objectives = np.array([obj for _, obj in archive])\n    avg_distances = np.mean(objectives, axis=1)\n    selected_idx = np.argmin(avg_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move on the edge with the highest combined distance across objectives\n    max_edge_idx = -1\n    max_edge_cost = -1\n\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        cost = distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            max_edge_idx = i\n\n    # Perform the 2-opt move\n    if max_edge_idx != -1:\n        i = max_edge_idx\n        j = (i + 1) % n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then, perform an objective-aware edge swap to balance the objectives\n    # Find the edge that has the highest difference between the three objectives\n    max_diff_idx = -1\n    max_diff = -1\n\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        costs = [\n            distance_matrix_1[u, v],\n            distance_matrix_2[u, v],\n            distance_matrix_3[u, v]\n        ]\n        diff = max(costs) - min(costs)\n        if diff > max_diff:\n            max_diff = diff\n            max_diff_idx = i\n\n    # Perform the swap if it improves the most imbalanced edge\n    if max_diff_idx != -1:\n        i = max_diff_idx\n        j = (i + 1) % n\n        # Try swapping with a random node that could potentially balance the objectives\n        k = np.random.randint(0, n)\n        if k != i and k != j and k != (i - 1) % n and k != (j + 1) % n:\n            # Perform a 2-opt between i and k\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 76,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with higher costs)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Apply 2-opt on the selected segment\n        if i != j and k != l:\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n            # Check if the new solution is valid (no duplicate nodes)\n            if len(set(new_solution)) == n:\n                break\n\n    # Additional edge exchange to improve multi-objective quality\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            # Evaluate the impact on all three objectives\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[i]])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7627531442662138,
            1.9756036162376405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with higher costs)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Apply 2-opt on the selected segment\n        if i != j and k != l:\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n            # Check if the new solution is valid (no duplicate nodes)\n            if len(set(new_solution)) == n:\n                break\n\n    # Additional edge exchange to improve multi-objective quality\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            # Evaluate the impact on all three objectives\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[i]])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 77,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the crowding distance for each solution in the archive\n    def calculate_crowding_distance(solutions, objectives):\n        num_obj = len(objectives[0])\n        num_sol = len(solutions)\n        crowding_distance = np.zeros(num_sol)\n\n        for m in range(num_obj):\n            # Sort solutions by the m-th objective\n            sorted_indices = np.argsort([obj[m] for obj in objectives])\n            sorted_solutions = [solutions[i] for i in sorted_indices]\n            sorted_objectives = [objectives[i] for i in sorted_indices]\n\n            # Assign infinite crowding distance to boundary solutions\n            crowding_distance[sorted_indices[0]] = np.inf\n            crowding_distance[sorted_indices[-1]] = np.inf\n\n            # Calculate the range of the m-th objective\n            f_min = sorted_objectives[0][m]\n            f_max = sorted_objectives[-1][m]\n            if f_max == f_min:\n                continue\n\n            # Calculate crowding distance for intermediate solutions\n            for i in range(1, num_sol - 1):\n                idx = sorted_indices[i]\n                crowding_distance[idx] += (sorted_objectives[i+1][m] - sorted_objectives[i-1][m]) / (f_max - f_min)\n\n        return crowding_distance\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    crowding_distances = calculate_crowding_distance(solutions, objectives)\n\n    # Select solutions with the highest crowding distance (promising for improvement)\n    max_crowding = np.max(crowding_distances)\n    candidates = [sol for i, sol in enumerate(solutions) if crowding_distances[i] == max_crowding]\n\n    # Randomly select one candidate\n    base_solution = random.choice(candidates)\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to balance the three objectives\n    # Calculate the current objective values\n    def calculate_objective(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Find the worst objective (to be improved)\n    worst_obj_index = np.argmax(current_obj)\n\n    # Perform a swap that improves the worst objective\n    for _ in range(10):  # Try up to 10 random swaps\n        a, b = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        temp_obj = calculate_objective(temp_solution)\n\n        if temp_obj[worst_obj_index] < current_obj[worst_obj_index]:\n            new_solution = temp_solution\n            current_obj = temp_obj\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7588977013608637,
            2.807521378993988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the crowding distance for each solution in the archive\n    def calculate_crowding_distance(solutions, objectives):\n        num_obj = len(objectives[0])\n        num_sol = len(solutions)\n        crowding_distance = np.zeros(num_sol)\n\n        for m in range(num_obj):\n            # Sort solutions by the m-th objective\n            sorted_indices = np.argsort([obj[m] for obj in objectives])\n            sorted_solutions = [solutions[i] for i in sorted_indices]\n            sorted_objectives = [objectives[i] for i in sorted_indices]\n\n            # Assign infinite crowding distance to boundary solutions\n            crowding_distance[sorted_indices[0]] = np.inf\n            crowding_distance[sorted_indices[-1]] = np.inf\n\n            # Calculate the range of the m-th objective\n            f_min = sorted_objectives[0][m]\n            f_max = sorted_objectives[-1][m]\n            if f_max == f_min:\n                continue\n\n            # Calculate crowding distance for intermediate solutions\n            for i in range(1, num_sol - 1):\n                idx = sorted_indices[i]\n                crowding_distance[idx] += (sorted_objectives[i+1][m] - sorted_objectives[i-1][m]) / (f_max - f_min)\n\n        return crowding_distance\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    crowding_distances = calculate_crowding_distance(solutions, objectives)\n\n    # Select solutions with the highest crowding distance (promising for improvement)\n    max_crowding = np.max(crowding_distances)\n    candidates = [sol for i, sol in enumerate(solutions) if crowding_distances[i] == max_crowding]\n\n    # Randomly select one candidate\n    base_solution = random.choice(candidates)\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to balance the three objectives\n    # Calculate the current objective values\n    def calculate_objective(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Find the worst objective (to be improved)\n    worst_obj_index = np.argmax(current_obj)\n\n    # Perform a swap that improves the worst objective\n    for _ in range(10):  # Try up to 10 random swaps\n        a, b = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        temp_obj = calculate_objective(temp_solution)\n\n        if temp_obj[worst_obj_index] < current_obj[worst_obj_index]:\n            new_solution = temp_solution\n            current_obj = temp_obj\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 78,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n_nodes = len(new_solution)\n    i, j = np.random.choice(n_nodes, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate objective improvements\n    def calculate_objective(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n_nodes-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n_nodes-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n_nodes-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    original_obj = archive[selected_idx][1]\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, try another operator\n    if all(new_o >= orig_o for new_o, orig_o in zip(new_obj, original_obj)):\n        # Try a different operator: swap segments based on objective diversity\n        k = np.random.randint(1, n_nodes//2)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n\n        # Ensure feasibility\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n",
        "score": [
            -0.7092600563045798,
            1.800836205482483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n_nodes = len(new_solution)\n    i, j = np.random.choice(n_nodes, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate objective improvements\n    def calculate_objective(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n_nodes-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n_nodes-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n_nodes-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    original_obj = archive[selected_idx][1]\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, try another operator\n    if all(new_o >= orig_o for new_o, orig_o in zip(new_obj, original_obj)):\n        # Try a different operator: swap segments based on objective diversity\n        k = np.random.randint(1, n_nodes//2)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n\n        # Ensure feasibility\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 79,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1 / (1 + sum(obj)) for _, obj in archive]  # Higher weight for solutions with lower total cost\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining multiple operators\n    operators = [\n        'swap',  # Standard 2-opt swap\n        'insert',  # Insertion move\n        'reverse',  # Reverse a segment\n        'multi_swap'  # Multi-city swap\n    ]\n\n    operator = random.choice(operators)\n\n    if operator == 'swap':\n        # Randomly select two distinct positions\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'insert':\n        # Randomly select two distinct positions\n        i, j = random.sample(range(len(new_solution)), 2)\n        # Insert node at position i into position j\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'reverse':\n        # Randomly select a segment to reverse\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'multi_swap':\n        # Randomly select 3 distinct positions\n        i, j, k = random.sample(range(len(new_solution)), 3)\n        # Perform a cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8147436218303534,
            1.6969072580337525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1 / (1 + sum(obj)) for _, obj in archive]  # Higher weight for solutions with lower total cost\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining multiple operators\n    operators = [\n        'swap',  # Standard 2-opt swap\n        'insert',  # Insertion move\n        'reverse',  # Reverse a segment\n        'multi_swap'  # Multi-city swap\n    ]\n\n    operator = random.choice(operators)\n\n    if operator == 'swap':\n        # Randomly select two distinct positions\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'insert':\n        # Randomly select two distinct positions\n        i, j = random.sample(range(len(new_solution)), 2)\n        # Insert node at position i into position j\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'reverse':\n        # Randomly select a segment to reverse\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'multi_swap':\n        # Randomly select 3 distinct positions\n        i, j, k = random.sample(range(len(new_solution)), 3)\n        # Perform a cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 80,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search strategy: 2-opt with objective-aware perturbation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply an objective-aware perturbation\n    # Identify the worst objective space\n    objectives = [sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                  sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                  sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))]\n\n    worst_obj = np.argmax(objectives)\n\n    # Perturb the solution based on the worst objective\n    if worst_obj == 0:\n        # For the worst objective, try to find a better 2-opt move\n        best_improvement = 0\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+2, n):\n                delta = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                         distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_i, best_j = i, j\n        if best_improvement < 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n    elif worst_obj == 1:\n        # For the worst objective, try a different perturbation strategy\n        # Swap two nodes that are far apart in this objective space\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if max_dist > 0:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    else:\n        # For the worst objective, try to insert a node in a better position\n        # Choose a random node and find its best position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        best_pos = 0\n        best_delta = float('inf')\n        for i in range(n-1):\n            delta = (distance_matrix_3[node, new_solution[i]] +\n                     distance_matrix_3[new_solution[(i+1)%(n-1)], node] -\n                     distance_matrix_3[new_solution[i], new_solution[(i+1)%(n-1)]])\n            if delta < best_delta:\n                best_delta = delta\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6859059539134372,
            2.559286963939667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search strategy: 2-opt with objective-aware perturbation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply an objective-aware perturbation\n    # Identify the worst objective space\n    objectives = [sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                  sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                  sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))]\n\n    worst_obj = np.argmax(objectives)\n\n    # Perturb the solution based on the worst objective\n    if worst_obj == 0:\n        # For the worst objective, try to find a better 2-opt move\n        best_improvement = 0\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+2, n):\n                delta = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                         distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_i, best_j = i, j\n        if best_improvement < 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n    elif worst_obj == 1:\n        # For the worst objective, try a different perturbation strategy\n        # Swap two nodes that are far apart in this objective space\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        if max_dist > 0:\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    else:\n        # For the worst objective, try to insert a node in a better position\n        # Choose a random node and find its best position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        best_pos = 0\n        best_delta = float('inf')\n        for i in range(n-1):\n            delta = (distance_matrix_3[node, new_solution[i]] +\n                     distance_matrix_3[new_solution[(i+1)%(n-1)], node] -\n                     distance_matrix_3[new_solution[i], new_solution[(i+1)%(n-1)]])\n            if delta < best_delta:\n                best_delta = delta\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 81,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., random selection with some bias)\n    selected = random.choices(\n        archive,\n        weights=[1 / (1 + obj[0] + obj[1] + obj[2]) for (sol, obj) in archive],\n        k=1\n    )[0][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and objective-aware swaps\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select a segment to optimize\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    # Apply 2-opt within the segment\n    if len(segment) > 2:\n        k, l = sorted(random.sample(range(len(segment)), 2))\n        segment[k], segment[l] = segment[l], segment[k]\n\n    # Apply objective-aware swap based on the worst objective\n    objectives = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        # Improve worst objective by swapping nodes that are far apart in this objective\n        farthest_pair = max(\n            [(i, j) for i in range(n) for j in range(i+1, n)],\n            key=lambda pair: distance_matrix_1[pair[0], pair[1]]\n        )\n        new_solution[farthest_pair[0]], new_solution[farthest_pair[1]] = new_solution[farthest_pair[1]], new_solution[farthest_pair[0]]\n    elif worst_obj == 1:\n        # Improve worst objective by reversing a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Improve worst objective by inserting a node at a better position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.roll(new_solution, 1) if random.random() > 0.5 else new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6038922562283334,
            1.7900782585144044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., random selection with some bias)\n    selected = random.choices(\n        archive,\n        weights=[1 / (1 + obj[0] + obj[1] + obj[2]) for (sol, obj) in archive],\n        k=1\n    )[0][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and objective-aware swaps\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select a segment to optimize\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    # Apply 2-opt within the segment\n    if len(segment) > 2:\n        k, l = sorted(random.sample(range(len(segment)), 2))\n        segment[k], segment[l] = segment[l], segment[k]\n\n    # Apply objective-aware swap based on the worst objective\n    objectives = [\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n    ]\n\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        # Improve worst objective by swapping nodes that are far apart in this objective\n        farthest_pair = max(\n            [(i, j) for i in range(n) for j in range(i+1, n)],\n            key=lambda pair: distance_matrix_1[pair[0], pair[1]]\n        )\n        new_solution[farthest_pair[0]], new_solution[farthest_pair[1]] = new_solution[farthest_pair[1]], new_solution[farthest_pair[0]]\n    elif worst_obj == 1:\n        # Improve worst objective by reversing a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Improve worst objective by inserting a node at a better position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.roll(new_solution, 1) if random.random() > 0.5 else new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 82,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average objective value (promising for improvement)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a segment\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Choose between 2-opt or node insertion with probability 0.7/0.3\n        if np.random.random() < 0.7:\n            # 2-opt: select two edges and reverse the segment between them\n            i, j = np.random.choice(n, size=2, replace=False)\n            i, j = min(i, j), max(i, j)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion: remove a node and reinsert it at a different position\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If duplicates exist, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7003542559611357,
            1.9261809706687927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average objective value (promising for improvement)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a segment\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Choose between 2-opt or node insertion with probability 0.7/0.3\n        if np.random.random() < 0.7:\n            # 2-opt: select two edges and reverse the segment between them\n            i, j = np.random.choice(n, size=2, replace=False)\n            i, j = min(i, j), max(i, j)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion: remove a node and reinsert it at a different position\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If duplicates exist, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 83,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.mean(axis=1)\n    probabilities = 1 / (combined_scores + 1e-10)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and segment inversion\n    n = len(base_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, apply segment inversion\n            seg_length = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - seg_length)\n            new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(set(new_solution)) == len(base_solution), \"Generated solution is not a valid tour\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Generated solution contains invalid nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8024432706318011,
            1.8056642293930054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.mean(axis=1)\n    probabilities = 1 / (combined_scores + 1e-10)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and segment inversion\n    n = len(base_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, apply segment inversion\n            seg_length = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - seg_length)\n            new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(set(new_solution)) == len(base_solution), \"Generated solution is not a valid tour\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Generated solution contains invalid nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 84,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the sum of distances for the current solution\n        total_dist = sum(obj)\n        candidates.append((sol, total_dist))\n\n    # Sort candidates by total distance (ascending) to prioritize solutions with lower total distance\n    candidates.sort(key=lambda x: x[1])\n    # Select the top 20% of solutions with the lowest total distance\n    top_candidates = candidates[:max(1, len(candidates) // 5)]\n    # Randomly select one from the top candidates\n    base_solution = random.choice(top_candidates)[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + n // 4, n - 1))\n\n    # Extract the segment\n    segment = new_solution[start:end+1]\n\n    # Apply different operators based on the segment length\n    if len(segment) == 2:\n        # Swap two nodes if segment is small\n        segment[0], segment[1] = segment[1], segment[0]\n    else:\n        # Reverse the segment for larger segments\n        segment = segment[::-1]\n\n    # Insert the modified segment back\n    new_solution[start:end+1] = segment\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    # Verify by checking if all nodes are present exactly once\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6610772812443338,
            1.698178231716156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the sum of distances for the current solution\n        total_dist = sum(obj)\n        candidates.append((sol, total_dist))\n\n    # Sort candidates by total distance (ascending) to prioritize solutions with lower total distance\n    candidates.sort(key=lambda x: x[1])\n    # Select the top 20% of solutions with the lowest total distance\n    top_candidates = candidates[:max(1, len(candidates) // 5)]\n    # Randomly select one from the top candidates\n    base_solution = random.choice(top_candidates)[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + n // 4, n - 1))\n\n    # Extract the segment\n    segment = new_solution[start:end+1]\n\n    # Apply different operators based on the segment length\n    if len(segment) == 2:\n        # Swap two nodes if segment is small\n        segment[0], segment[1] = segment[1], segment[0]\n    else:\n        # Reverse the segment for larger segments\n        segment = segment[::-1]\n\n    # Insert the modified segment back\n    new_solution[start:end+1] = segment\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    # Verify by checking if all nodes are present exactly once\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 85,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (descending) to prioritize solutions with higher costs\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% of solutions\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Perform 2-opt with objective-aware selection\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue  # Skip adjacent nodes to avoid trivial swaps\n\n        # Evaluate the current and proposed segments\n        current_segment = [new_solution[k % n] for k in range(i, j+1)]\n        proposed_segment = current_segment[::-1]  # Reverse the segment\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[(i-1)%n], proposed_segment[0]] +\n                      distance_matrix_1[proposed_segment[-1], new_solution[j%n]] -\n                      distance_matrix_1[new_solution[(i-1)%n], current_segment[0]] -\n                      distance_matrix_1[current_segment[-1], new_solution[j%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[(i-1)%n], proposed_segment[0]] +\n                      distance_matrix_2[proposed_segment[-1], new_solution[j%n]] -\n                      distance_matrix_2[new_solution[(i-1)%n], current_segment[0]] -\n                      distance_matrix_2[current_segment[-1], new_solution[j%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[(i-1)%n], proposed_segment[0]] +\n                      distance_matrix_3[proposed_segment[-1], new_solution[j%n]] -\n                      distance_matrix_3[new_solution[(i-1)%n], current_segment[0]] -\n                      distance_matrix_3[current_segment[-1], new_solution[j%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = proposed_segment\n\n    # Additional objective-aware 2-opt for the worst objective\n    worst_obj = np.argmax(selected[1])\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    for _ in range(5):  # Additional iterations focused on the worst objective\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue\n\n        current_segment = [new_solution[k % n] for k in range(i, j+1)]\n        proposed_segment = current_segment[::-1]\n\n        delta = (distance_matrix[new_solution[(i-1)%n], proposed_segment[0]] +\n                 distance_matrix[proposed_segment[-1], new_solution[j%n]] -\n                 distance_matrix[new_solution[(i-1)%n], current_segment[0]] -\n                 distance_matrix[current_segment[-1], new_solution[j%n]])\n\n        if delta < 0:\n            new_solution[i:j+1] = proposed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.6077476891446535,
            2.1085430145263673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (descending) to prioritize solutions with higher costs\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% of solutions\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Perform 2-opt with objective-aware selection\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue  # Skip adjacent nodes to avoid trivial swaps\n\n        # Evaluate the current and proposed segments\n        current_segment = [new_solution[k % n] for k in range(i, j+1)]\n        proposed_segment = current_segment[::-1]  # Reverse the segment\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[(i-1)%n], proposed_segment[0]] +\n                      distance_matrix_1[proposed_segment[-1], new_solution[j%n]] -\n                      distance_matrix_1[new_solution[(i-1)%n], current_segment[0]] -\n                      distance_matrix_1[current_segment[-1], new_solution[j%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[(i-1)%n], proposed_segment[0]] +\n                      distance_matrix_2[proposed_segment[-1], new_solution[j%n]] -\n                      distance_matrix_2[new_solution[(i-1)%n], current_segment[0]] -\n                      distance_matrix_2[current_segment[-1], new_solution[j%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[(i-1)%n], proposed_segment[0]] +\n                      distance_matrix_3[proposed_segment[-1], new_solution[j%n]] -\n                      distance_matrix_3[new_solution[(i-1)%n], current_segment[0]] -\n                      distance_matrix_3[current_segment[-1], new_solution[j%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = proposed_segment\n\n    # Additional objective-aware 2-opt for the worst objective\n    worst_obj = np.argmax(selected[1])\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    for _ in range(5):  # Additional iterations focused on the worst objective\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue\n\n        current_segment = [new_solution[k % n] for k in range(i, j+1)]\n        proposed_segment = current_segment[::-1]\n\n        delta = (distance_matrix[new_solution[(i-1)%n], proposed_segment[0]] +\n                 distance_matrix[proposed_segment[-1], new_solution[j%n]] -\n                 distance_matrix[new_solution[(i-1)%n], current_segment[0]] -\n                 distance_matrix[current_segment[-1], new_solution[j%n]])\n\n        if delta < 0:\n            new_solution[i:j+1] = proposed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 86,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the \"potential\" of each solution as the sum of its normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    potentials = np.sum(normalized_obj, axis=1)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to modify\n    segment_size = max(2, min(5, n // 4))  # Dynamic segment size\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Apply different operators based on the segment length\n    if segment_size == 2:\n        # Swap two nodes\n        new_solution[start], new_solution[end-1] = new_solution[end-1], new_solution[start]\n    elif segment_size == 3:\n        # Reverse a small segment\n        new_solution[start:end] = segment[::-1]\n    else:\n        # Apply a more complex operator: 2-opt with consideration for all three objectives\n        i, j = np.random.choice(range(start, end), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7048249611773795,
            1.8487017750740051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the \"potential\" of each solution as the sum of its normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    potentials = np.sum(normalized_obj, axis=1)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to modify\n    segment_size = max(2, min(5, n // 4))  # Dynamic segment size\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Apply different operators based on the segment length\n    if segment_size == 2:\n        # Swap two nodes\n        new_solution[start], new_solution[end-1] = new_solution[end-1], new_solution[start]\n    elif segment_size == 3:\n        # Reverse a small segment\n        new_solution[start:end] = segment[::-1]\n    else:\n        # Apply a more complex operator: 2-opt with consideration for all three objectives\n        i, j = np.random.choice(range(start, end), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 87,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values for potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: swap nodes that are outliers in any objective space\n    for _ in range(2):  # Perform a few swaps\n        # Calculate the cost of each node in the current solution\n        costs = []\n        for idx in range(n):\n            node = new_solution[idx]\n            prev_node = new_solution[idx - 1]\n            next_node = new_solution[(idx + 1) % n]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n            costs.append((cost1, cost2, cost3))\n\n        # Find nodes with highest cost in any objective (potential outliers)\n        max_costs = [max(cost) for cost in costs]\n        outliers = np.argsort(max_costs)[-2:]  # Select top 2 outliers\n\n        if len(outliers) >= 2:\n            # Swap the two outliers\n            a, b = outliers\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8044669434484671,
            1.562622106075287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values for potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: swap nodes that are outliers in any objective space\n    for _ in range(2):  # Perform a few swaps\n        # Calculate the cost of each node in the current solution\n        costs = []\n        for idx in range(n):\n            node = new_solution[idx]\n            prev_node = new_solution[idx - 1]\n            next_node = new_solution[(idx + 1) % n]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            cost3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n            costs.append((cost1, cost2, cost3))\n\n        # Find nodes with highest cost in any objective (potential outliers)\n        max_costs = [max(cost) for cost in costs]\n        outliers = np.argsort(max_costs)[-2:]  # Select top 2 outliers\n\n        if len(outliers) >= 2:\n            # Swap the two outliers\n            a, b = outliers\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 88,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest total objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Parameters for the hybrid local search\n    max_iterations = min(10, len(new_solution) // 2)\n    objective_weights = [1.0, 1.0, 1.0]  # Equal weights for all objectives\n\n    for _ in range(max_iterations):\n        # Randomly decide between 2-opt and 3-opt move\n        if np.random.rand() < 0.7:  # Higher probability for 2-opt\n            # Apply 2-opt move\n            i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Apply 3-opt move (more disruptive)\n            a, b, c = sorted(np.random.choice(len(new_solution), 3, replace=False))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            new_solution[a:c+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n        # Calculate the new objective values\n        total_cost = 0\n        for k in range(len(new_solution)):\n            u = new_solution[k]\n            v = new_solution[(k+1) % len(new_solution)]\n            total_cost += (objective_weights[0] * distance_matrix_1[u, v] +\n                          objective_weights[1] * distance_matrix_2[u, v] +\n                          objective_weights[2] * distance_matrix_3[u, v])\n\n        # Accept the move if it improves the total cost\n        if total_cost < sum(archive[0][1]):\n            base_solution = new_solution.copy()\n\n    # Apply a biased random walk to escape local optima\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7906006197816685,
            3.2131198763847353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest total objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Parameters for the hybrid local search\n    max_iterations = min(10, len(new_solution) // 2)\n    objective_weights = [1.0, 1.0, 1.0]  # Equal weights for all objectives\n\n    for _ in range(max_iterations):\n        # Randomly decide between 2-opt and 3-opt move\n        if np.random.rand() < 0.7:  # Higher probability for 2-opt\n            # Apply 2-opt move\n            i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Apply 3-opt move (more disruptive)\n            a, b, c = sorted(np.random.choice(len(new_solution), 3, replace=False))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            new_solution[a:c+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n        # Calculate the new objective values\n        total_cost = 0\n        for k in range(len(new_solution)):\n            u = new_solution[k]\n            v = new_solution[(k+1) % len(new_solution)]\n            total_cost += (objective_weights[0] * distance_matrix_1[u, v] +\n                          objective_weights[1] * distance_matrix_2[u, v] +\n                          objective_weights[2] * distance_matrix_3[u, v])\n\n        # Accept the move if it improves the total cost\n        if total_cost < sum(archive[0][1]):\n            base_solution = new_solution.copy()\n\n    # Apply a biased random walk to escape local optima\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 89,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted random choice based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    # Normalize objectives to avoid bias towards larger values\n    normalized = np.array(objectives)\n    normalized = (normalized - normalized.min(axis=0)) / (normalized.max(axis=0) - normalized.min(axis=0) + 1e-8)\n    # Calculate a combined score (e.g., sum of normalized objectives)\n    scores = normalized.sum(axis=1)\n    # Select a solution with probability inversely proportional to its score (better solutions have lower scores)\n    probabilities = 1 / (scores + 1e-8)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment of the tour and reverse it (2-opt)\n    # 2. Randomly swap two edges if it improves the combined objective\n    # 3. Randomly insert a node in a different position if it improves the combined objective\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move (reverse a random segment)\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swap if beneficial\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j and j != (i+1)%n and i != (j+1)%n:\n            # Calculate current and potential new distances\n            current_dist = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            new_dist = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[j]] +\n                        distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n            if new_dist < current_dist:\n                # Perform the swap\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Node insertion if beneficial\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and abs(i-j) > 1:\n            # Calculate current and potential new distances\n            current_dist = (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                            distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                            distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n            new_dist = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                        distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                        distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(i+1)%n]])\n\n            if new_dist < current_dist:\n                # Perform the insertion\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                if j > i:\n                    new_solution = np.concatenate([new_solution[:j-1], [node], new_solution[j-1:]])\n                else:\n                    new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7745419878417371,
            1.717372989654541
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted random choice based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    # Normalize objectives to avoid bias towards larger values\n    normalized = np.array(objectives)\n    normalized = (normalized - normalized.min(axis=0)) / (normalized.max(axis=0) - normalized.min(axis=0) + 1e-8)\n    # Calculate a combined score (e.g., sum of normalized objectives)\n    scores = normalized.sum(axis=1)\n    # Select a solution with probability inversely proportional to its score (better solutions have lower scores)\n    probabilities = 1 / (scores + 1e-8)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment of the tour and reverse it (2-opt)\n    # 2. Randomly swap two edges if it improves the combined objective\n    # 3. Randomly insert a node in a different position if it improves the combined objective\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move (reverse a random segment)\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swap if beneficial\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j and j != (i+1)%n and i != (j+1)%n:\n            # Calculate current and potential new distances\n            current_dist = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            new_dist = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[j]] +\n                        distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n            if new_dist < current_dist:\n                # Perform the swap\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Node insertion if beneficial\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and abs(i-j) > 1:\n            # Calculate current and potential new distances\n            current_dist = (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                            distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                            distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n            new_dist = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                        distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                        distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(i+1)%n]])\n\n            if new_dist < current_dist:\n                # Perform the insertion\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                if j > i:\n                    new_solution = np.concatenate([new_solution[:j-1], [node], new_solution[j-1:]])\n                else:\n                    new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 90,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a solution with high diversity in objectives to encourage exploration\n    def diversity_score(solution_obj):\n        return sum(abs(solution_obj[i] - solution_obj[j]) for i in range(3) for j in range(i+1, 3))\n\n    if len(archive) > 1:\n        archive_with_score = [(sol, obj, diversity_score(obj)) for sol, obj in archive]\n        archive_with_score.sort(key=lambda x: -x[2])  # Sort by diversity score\n        selected = random.choices(archive_with_score, weights=[x[2] for x in archive_with_score], k=1)[0][0]\n    else:\n        selected = archive[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective perturbation\n    if n > 3:\n        # Perform 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Multi-objective perturbation: swap a segment with a different segment based on objective priorities\n        if random.random() < 0.3:  # 30% chance to apply perturbation\n            # Identify which objective has the highest improvement potential\n            obj1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            obj3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n            # Find the worst objective and try to improve it\n            worst_obj = max([(obj1, 0), (obj2, 1), (obj3, 2)], key=lambda x: x[0])[1]\n\n            if worst_obj == 0:\n                # Find the segment that improves the first objective\n                best_improvement = 0\n                best_segment = None\n                for a in range(n):\n                    for b in range(a+2, min(a+10, n)):  # Limit segment size for efficiency\n                        candidate = new_solution.copy()\n                        candidate[a:b] = candidate[a:b][::-1]\n                        current_obj = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n                        improvement = obj1 - current_obj\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_segment = (a, b)\n                if best_segment:\n                    a, b = best_segment\n                    new_solution[a:b] = new_solution[a:b][::-1]\n            elif worst_obj == 1:\n                # Similar logic for the second objective\n                best_improvement = 0\n                best_segment = None\n                for a in range(n):\n                    for b in range(a+2, min(a+10, n)):\n                        candidate = new_solution.copy()\n                        candidate[a:b] = candidate[a:b][::-1]\n                        current_obj = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n                        improvement = obj2 - current_obj\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_segment = (a, b)\n                if best_segment:\n                    a, b = best_segment\n                    new_solution[a:b] = new_solution[a:b][::-1]\n            else:\n                # Similar logic for the third objective\n                best_improvement = 0\n                best_segment = None\n                for a in range(n):\n                    for b in range(a+2, min(a+10, n)):\n                        candidate = new_solution.copy()\n                        candidate[a:b] = candidate[a:b][::-1]\n                        current_obj = sum(distance_matrix_3[candidate[k-1], candidate[k]] for k in range(n))\n                        improvement = obj3 - current_obj\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_segment = (a, b)\n                if best_segment:\n                    a, b = best_segment\n                    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.743418893517098,
            4.408053922653198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a solution with high diversity in objectives to encourage exploration\n    def diversity_score(solution_obj):\n        return sum(abs(solution_obj[i] - solution_obj[j]) for i in range(3) for j in range(i+1, 3))\n\n    if len(archive) > 1:\n        archive_with_score = [(sol, obj, diversity_score(obj)) for sol, obj in archive]\n        archive_with_score.sort(key=lambda x: -x[2])  # Sort by diversity score\n        selected = random.choices(archive_with_score, weights=[x[2] for x in archive_with_score], k=1)[0][0]\n    else:\n        selected = archive[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective perturbation\n    if n > 3:\n        # Perform 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Multi-objective perturbation: swap a segment with a different segment based on objective priorities\n        if random.random() < 0.3:  # 30% chance to apply perturbation\n            # Identify which objective has the highest improvement potential\n            obj1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            obj3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n            # Find the worst objective and try to improve it\n            worst_obj = max([(obj1, 0), (obj2, 1), (obj3, 2)], key=lambda x: x[0])[1]\n\n            if worst_obj == 0:\n                # Find the segment that improves the first objective\n                best_improvement = 0\n                best_segment = None\n                for a in range(n):\n                    for b in range(a+2, min(a+10, n)):  # Limit segment size for efficiency\n                        candidate = new_solution.copy()\n                        candidate[a:b] = candidate[a:b][::-1]\n                        current_obj = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n                        improvement = obj1 - current_obj\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_segment = (a, b)\n                if best_segment:\n                    a, b = best_segment\n                    new_solution[a:b] = new_solution[a:b][::-1]\n            elif worst_obj == 1:\n                # Similar logic for the second objective\n                best_improvement = 0\n                best_segment = None\n                for a in range(n):\n                    for b in range(a+2, min(a+10, n)):\n                        candidate = new_solution.copy()\n                        candidate[a:b] = candidate[a:b][::-1]\n                        current_obj = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n                        improvement = obj2 - current_obj\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_segment = (a, b)\n                if best_segment:\n                    a, b = best_segment\n                    new_solution[a:b] = new_solution[a:b][::-1]\n            else:\n                # Similar logic for the third objective\n                best_improvement = 0\n                best_segment = None\n                for a in range(n):\n                    for b in range(a+2, min(a+10, n)):\n                        candidate = new_solution.copy()\n                        candidate[a:b] = candidate[a:b][::-1]\n                        current_obj = sum(distance_matrix_3[candidate[k-1], candidate[k]] for k in range(n))\n                        improvement = obj3 - current_obj\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_segment = (a, b)\n                if best_segment:\n                    a, b = best_segment\n                    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 91,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (e.g., lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized improvement potential (lower is better)\n    normalized_objectives = np.array(archive_objectives)\n    normalized_objectives = (normalized_objectives - normalized_objectives.min(axis=0)) / (normalized_objectives.max(axis=0) - normalized_objectives.min(axis=0) + 1e-8)\n    improvement_potential = normalized_objectives.mean(axis=1)\n\n    # Select the solution with the lowest improvement potential (most promising for further improvement)\n    selected_idx = np.argmin(improvement_potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Check if the swap improves at least one objective\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]]\n        )\n\n        if new_cost < original_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel multi-objective edge swap: swap edges that improve at least two objectives\n    for _ in range(5):  # Limit iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Check improvement in all three objectives\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]) <\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]) <\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]) <\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        if sum(improvements) >= 2:  # Require improvement in at least two objectives\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6169868460497601,
            3.1003459334373473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (e.g., lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized improvement potential (lower is better)\n    normalized_objectives = np.array(archive_objectives)\n    normalized_objectives = (normalized_objectives - normalized_objectives.min(axis=0)) / (normalized_objectives.max(axis=0) - normalized_objectives.min(axis=0) + 1e-8)\n    improvement_potential = normalized_objectives.mean(axis=1)\n\n    # Select the solution with the lowest improvement potential (most promising for further improvement)\n    selected_idx = np.argmin(improvement_potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Check if the swap improves at least one objective\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]]\n        )\n\n        if new_cost < original_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel multi-objective edge swap: swap edges that improve at least two objectives\n    for _ in range(5):  # Limit iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Check improvement in all three objectives\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]) <\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]) <\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]) <\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        if sum(improvements) >= 2:  # Require improvement in at least two objectives\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 92,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their total objective value (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% solutions and pick one randomly\n        top_candidates = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        selected_idx = random.randint(0, len(top_candidates) - 1)\n        base_solution = top_candidates[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: combination of 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective space to prioritize for the local search\n    objectives = archive[0][1]  # Using first archive entry's objectives as reference\n    obj_weights = np.array(objectives) / sum(objectives) if sum(objectives) > 0 else np.ones(3) / 3\n\n    # Choose between 2-opt or 3-opt based on weighted random selection\n    if random.random() < 0.7:  # Higher chance for 2-opt as it's simpler and faster\n        # 2-opt local search with objective-aware edge selection\n        for _ in range(10):  # Limit iterations to avoid excessive computation\n            i, j = sorted(random.sample(range(n), 2))\n            # Calculate improvement for each objective\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[j-1]])\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[j-1]])\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[j-1]])\n\n            # Weighted improvement score\n            improvement = obj_weights[0] * delta1 + obj_weights[1] * delta2 + obj_weights[2] * delta3\n\n            if improvement < 0:  # If improvement is positive (we want to minimize)\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt local search with objective-aware edge selection\n        for _ in range(5):  # Fewer iterations as 3-opt is more complex\n            a, b, c = sorted(random.sample(range(n), 3))\n            # There are 8 possible ways to reconnect the edges in 3-opt\n            # We'll evaluate all 8 possibilities and pick the best one\n            options = [\n                (new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:]),\n                (new_solution[:a], new_solution[a:b], new_solution[b:c][::-1], new_solution[c:]),\n                (new_solution[:a], new_solution[a:b][::-1], new_solution[b:c][::-1], new_solution[c:]),\n                (new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:][::-1]),\n                (new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:][::-1]),\n                (new_solution[:a], new_solution[a:b], new_solution[b:c][::-1], new_solution[c:][::-1]),\n                (new_solution[:a][::-1], new_solution[a:b], new_solution[b:c], new_solution[c:]),\n                (new_solution[:a], new_solution[a:b], new_solution[b:c][::-1], new_solution[c:][::-1])\n            ]\n\n            best_option = None\n            best_improvement = 0\n\n            for option in options:\n                # Reconstruct the new solution\n                temp_solution = np.concatenate(option)\n\n                # Calculate improvement for each objective\n                delta1 = (distance_matrix_1[temp_solution[-1], temp_solution[0]] -\n                         distance_matrix_1[new_solution[-1], new_solution[0]])\n                delta2 = (distance_matrix_2[temp_solution[-1], temp_solution[0]] -\n                         distance_matrix_2[new_solution[-1], new_solution[0]])\n                delta3 = (distance_matrix_3[temp_solution[-1], temp_solution[0]] -\n                         distance_matrix_3[new_solution[-1], new_solution[0]])\n\n                # Weighted improvement score\n                improvement = obj_weights[0] * delta1 + obj_weights[1] * delta2 + obj_weights[2] * delta3\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_option = option\n\n            if best_option is not None:\n                new_solution = np.concatenate(best_option)\n\n    return new_solution\n\n",
        "score": [
            -0.6972938890726191,
            3.108425772190094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their total objective value (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% solutions and pick one randomly\n        top_candidates = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        selected_idx = random.randint(0, len(top_candidates) - 1)\n        base_solution = top_candidates[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: combination of 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective space to prioritize for the local search\n    objectives = archive[0][1]  # Using first archive entry's objectives as reference\n    obj_weights = np.array(objectives) / sum(objectives) if sum(objectives) > 0 else np.ones(3) / 3\n\n    # Choose between 2-opt or 3-opt based on weighted random selection\n    if random.random() < 0.7:  # Higher chance for 2-opt as it's simpler and faster\n        # 2-opt local search with objective-aware edge selection\n        for _ in range(10):  # Limit iterations to avoid excessive computation\n            i, j = sorted(random.sample(range(n), 2))\n            # Calculate improvement for each objective\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[j-1]])\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[j-1]])\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[j-1]])\n\n            # Weighted improvement score\n            improvement = obj_weights[0] * delta1 + obj_weights[1] * delta2 + obj_weights[2] * delta3\n\n            if improvement < 0:  # If improvement is positive (we want to minimize)\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt local search with objective-aware edge selection\n        for _ in range(5):  # Fewer iterations as 3-opt is more complex\n            a, b, c = sorted(random.sample(range(n), 3))\n            # There are 8 possible ways to reconnect the edges in 3-opt\n            # We'll evaluate all 8 possibilities and pick the best one\n            options = [\n                (new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:]),\n                (new_solution[:a], new_solution[a:b], new_solution[b:c][::-1], new_solution[c:]),\n                (new_solution[:a], new_solution[a:b][::-1], new_solution[b:c][::-1], new_solution[c:]),\n                (new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:][::-1]),\n                (new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:][::-1]),\n                (new_solution[:a], new_solution[a:b], new_solution[b:c][::-1], new_solution[c:][::-1]),\n                (new_solution[:a][::-1], new_solution[a:b], new_solution[b:c], new_solution[c:]),\n                (new_solution[:a], new_solution[a:b], new_solution[b:c][::-1], new_solution[c:][::-1])\n            ]\n\n            best_option = None\n            best_improvement = 0\n\n            for option in options:\n                # Reconstruct the new solution\n                temp_solution = np.concatenate(option)\n\n                # Calculate improvement for each objective\n                delta1 = (distance_matrix_1[temp_solution[-1], temp_solution[0]] -\n                         distance_matrix_1[new_solution[-1], new_solution[0]])\n                delta2 = (distance_matrix_2[temp_solution[-1], temp_solution[0]] -\n                         distance_matrix_2[new_solution[-1], new_solution[0]])\n                delta3 = (distance_matrix_3[temp_solution[-1], temp_solution[0]] -\n                         distance_matrix_3[new_solution[-1], new_solution[0]])\n\n                # Weighted improvement score\n                improvement = obj_weights[0] * delta1 + obj_weights[1] * delta2 + obj_weights[2] * delta3\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_option = option\n\n            if best_option is not None:\n                new_solution = np.concatenate(best_option)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 93,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest sum of normalized objective values (promising for improvement)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select edges to swap based on the worst objective contribution\n    def get_edge_contribution(sol, i, j):\n        # Calculate the contribution of edge (i, j) to each objective\n        contrib_1 = distance_matrix_1[sol[i], sol[j]]\n        contrib_2 = distance_matrix_2[sol[i], sol[j]]\n        contrib_3 = distance_matrix_3[sol[i], sol[j]]\n        return contrib_1, contrib_2, contrib_3\n\n    # Find the worst edge in each objective\n    worst_edge_idx = [0, 0, 0]\n    worst_edge_contrib = [0, 0, 0]\n\n    for i in range(n):\n        j = (i + 1) % n\n        contrib_1, contrib_2, contrib_3 = get_edge_contribution(new_solution, i, j)\n\n        if contrib_1 > worst_edge_contrib[0]:\n            worst_edge_contrib[0] = contrib_1\n            worst_edge_idx[0] = i\n\n        if contrib_2 > worst_edge_contrib[1]:\n            worst_edge_contrib[1] = contrib_2\n            worst_edge_idx[1] = i\n\n        if contrib_3 > worst_edge_contrib[2]:\n            worst_edge_contrib[2] = contrib_3\n            worst_edge_idx[2] = i\n\n    # Select the worst edge from the objective with the highest contribution\n    objective_to_improve = np.argmax(worst_edge_contrib)\n    edge_to_swap = worst_edge_idx[objective_to_improve]\n\n    # Perform 2-opt swap\n    i, j = edge_to_swap, (edge_to_swap + 1) % n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6798366403006889,
            1.9321607232093811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest sum of normalized objective values (promising for improvement)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select edges to swap based on the worst objective contribution\n    def get_edge_contribution(sol, i, j):\n        # Calculate the contribution of edge (i, j) to each objective\n        contrib_1 = distance_matrix_1[sol[i], sol[j]]\n        contrib_2 = distance_matrix_2[sol[i], sol[j]]\n        contrib_3 = distance_matrix_3[sol[i], sol[j]]\n        return contrib_1, contrib_2, contrib_3\n\n    # Find the worst edge in each objective\n    worst_edge_idx = [0, 0, 0]\n    worst_edge_contrib = [0, 0, 0]\n\n    for i in range(n):\n        j = (i + 1) % n\n        contrib_1, contrib_2, contrib_3 = get_edge_contribution(new_solution, i, j)\n\n        if contrib_1 > worst_edge_contrib[0]:\n            worst_edge_contrib[0] = contrib_1\n            worst_edge_idx[0] = i\n\n        if contrib_2 > worst_edge_contrib[1]:\n            worst_edge_contrib[1] = contrib_2\n            worst_edge_idx[1] = i\n\n        if contrib_3 > worst_edge_contrib[2]:\n            worst_edge_contrib[2] = contrib_3\n            worst_edge_idx[2] = i\n\n    # Select the worst edge from the objective with the highest contribution\n    objective_to_improve = np.argmax(worst_edge_contrib)\n    edge_to_swap = worst_edge_idx[objective_to_improve]\n\n    # Perform 2-opt swap\n    i, j = edge_to_swap, (edge_to_swap + 1) % n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 94,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that improve the most objectives\n    if np.random.rand() < 0.3:  # 30% chance to perform objective-aware swap\n        for _ in range(3):  # Try a few random swaps\n            a, b = np.random.choice(n, 2, replace=False)\n            old_obj = (\n                distance_matrix_1[base_solution[a-1], base_solution[a]] + distance_matrix_1[base_solution[b-1], base_solution[b]],\n                distance_matrix_2[base_solution[a-1], base_solution[a]] + distance_matrix_2[base_solution[b-1], base_solution[b]],\n                distance_matrix_3[base_solution[a-1], base_solution[a]] + distance_matrix_3[base_solution[b-1], base_solution[b]]\n            )\n            new_obj = (\n                distance_matrix_1[base_solution[a-1], base_solution[b]] + distance_matrix_1[base_solution[b-1], base_solution[a]],\n                distance_matrix_2[base_solution[a-1], base_solution[b]] + distance_matrix_2[base_solution[b-1], base_solution[a]],\n                distance_matrix_3[base_solution[a-1], base_solution[b]] + distance_matrix_3[base_solution[b-1], base_solution[a]]\n            )\n            improvements = sum(1 for x, y in zip(old_obj, new_obj) if y < x)\n            if improvements >= 2:  # If at least two objectives improve\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7623718316197233,
            1.6456451058387755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that improve the most objectives\n    if np.random.rand() < 0.3:  # 30% chance to perform objective-aware swap\n        for _ in range(3):  # Try a few random swaps\n            a, b = np.random.choice(n, 2, replace=False)\n            old_obj = (\n                distance_matrix_1[base_solution[a-1], base_solution[a]] + distance_matrix_1[base_solution[b-1], base_solution[b]],\n                distance_matrix_2[base_solution[a-1], base_solution[a]] + distance_matrix_2[base_solution[b-1], base_solution[b]],\n                distance_matrix_3[base_solution[a-1], base_solution[a]] + distance_matrix_3[base_solution[b-1], base_solution[b]]\n            )\n            new_obj = (\n                distance_matrix_1[base_solution[a-1], base_solution[b]] + distance_matrix_1[base_solution[b-1], base_solution[a]],\n                distance_matrix_2[base_solution[a-1], base_solution[b]] + distance_matrix_2[base_solution[b-1], base_solution[a]],\n                distance_matrix_3[base_solution[a-1], base_solution[b]] + distance_matrix_3[base_solution[b-1], base_solution[a]]\n            )\n            improvements = sum(1 for x, y in zip(old_obj, new_obj) if y < x)\n            if improvements >= 2:  # If at least two objectives improve\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 95,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (simplified: solutions with higher objectives have more potential)\n    potentials = [sum(obj) for obj in objectives]\n    total_potential = sum(potentials)\n    if total_potential == 0:\n        selected_idx = random.randint(0, len(solutions) - 1)\n    else:\n        probabilities = [p / total_potential for p in potentials]\n        selected_idx = np.random.choice(len(solutions), p=probabilities)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Choose between 2-opt or objective-aware swap based on current objectives\n        current_obj = objectives[selected_idx]\n        obj_weights = [1.0, 1.0, 1.0]  # Equal weights for simplicity\n\n        # Calculate objective differences for possible swaps\n        def calculate_swap_difference(i, j):\n            # Original edges\n            orig_edges = [\n                (new_solution[i-1], new_solution[i]),\n                (new_solution[j], new_solution[(j+1)%n])\n            ]\n            # New edges after swap\n            new_edges = [\n                (new_solution[i-1], new_solution[j]),\n                (new_solution[i], new_solution[(j+1)%n])\n            ]\n\n            # Calculate objective differences\n            delta_obj = [0.0, 0.0, 0.0]\n            for (u1, v1), (u2, v2) in zip(orig_edges, new_edges):\n                delta_obj[0] += distance_matrix_1[u2, v2] - distance_matrix_1[u1, v1]\n                delta_obj[1] += distance_matrix_2[u2, v2] - distance_matrix_2[u1, v1]\n                delta_obj[2] += distance_matrix_3[u2, v2] - distance_matrix_3[u1, v1]\n\n            return delta_obj\n\n        # Try multiple candidate swaps and select the one that improves most objectives\n        best_improvement = float('inf')\n        best_swap = None\n\n        # Limit the number of candidates to explore for efficiency\n        num_candidates = min(20, n * (n-1) // 2)\n        candidates = random.sample([(i, j) for i in range(n) for j in range(i+1, n)], num_candidates)\n\n        for i, j in candidates:\n            delta_obj = calculate_swap_difference(i, j)\n            # Weighted improvement score\n            improvement = sum(w * d for w, d in zip(obj_weights, delta_obj))\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            # Perform the swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7285643141516868,
            2.9424004316329957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (simplified: solutions with higher objectives have more potential)\n    potentials = [sum(obj) for obj in objectives]\n    total_potential = sum(potentials)\n    if total_potential == 0:\n        selected_idx = random.randint(0, len(solutions) - 1)\n    else:\n        probabilities = [p / total_potential for p in potentials]\n        selected_idx = np.random.choice(len(solutions), p=probabilities)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Choose between 2-opt or objective-aware swap based on current objectives\n        current_obj = objectives[selected_idx]\n        obj_weights = [1.0, 1.0, 1.0]  # Equal weights for simplicity\n\n        # Calculate objective differences for possible swaps\n        def calculate_swap_difference(i, j):\n            # Original edges\n            orig_edges = [\n                (new_solution[i-1], new_solution[i]),\n                (new_solution[j], new_solution[(j+1)%n])\n            ]\n            # New edges after swap\n            new_edges = [\n                (new_solution[i-1], new_solution[j]),\n                (new_solution[i], new_solution[(j+1)%n])\n            ]\n\n            # Calculate objective differences\n            delta_obj = [0.0, 0.0, 0.0]\n            for (u1, v1), (u2, v2) in zip(orig_edges, new_edges):\n                delta_obj[0] += distance_matrix_1[u2, v2] - distance_matrix_1[u1, v1]\n                delta_obj[1] += distance_matrix_2[u2, v2] - distance_matrix_2[u1, v1]\n                delta_obj[2] += distance_matrix_3[u2, v2] - distance_matrix_3[u1, v1]\n\n            return delta_obj\n\n        # Try multiple candidate swaps and select the one that improves most objectives\n        best_improvement = float('inf')\n        best_swap = None\n\n        # Limit the number of candidates to explore for efficiency\n        num_candidates = min(20, n * (n-1) // 2)\n        candidates = random.sample([(i, j) for i in range(n) for j in range(i+1, n)], num_candidates)\n\n        for i, j in candidates:\n            delta_obj = calculate_swap_difference(i, j)\n            # Weighted improvement score\n            improvement = sum(w * d for w, d in zip(obj_weights, delta_obj))\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            # Perform the swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 96,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with above-average objective values)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n\n    # Identify solutions that are above average in at least one objective\n    promising_indices = []\n    for i, obj in enumerate(objectives):\n        if any(obj[j] > mean_obj[j] + 0.5 * std_obj[j] for j in range(3)):\n            promising_indices.append(i)\n\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Standard 2-opt move\n    new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Objective-aware edge swap: consider edges that improve multiple objectives\n    for _ in range(3):  # Perform multiple swaps to explore different objectives\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != i and l != j:  # Ensure we don't interfere with the 2-opt move\n            # Calculate objective improvements\n            old_edges = [\n                (base_solution[k-1], base_solution[k]),\n                (base_solution[l-1], base_solution[l])\n            ]\n            new_edges = [\n                (base_solution[k-1], base_solution[l]),\n                (base_solution[l-1], base_solution[k])\n            ]\n\n            # Calculate potential improvement in all three objectives\n            improvements = [\n                sum(distance_matrix_1[a][b] - distance_matrix_1[c][d] for (a,b), (c,d) in zip(old_edges, new_edges)),\n                sum(distance_matrix_2[a][b] - distance_matrix_2[c][d] for (a,b), (c,d) in zip(old_edges, new_edges)),\n                sum(distance_matrix_3[a][b] - distance_matrix_3[c][d] for (a,b), (c,d) in zip(old_edges, new_edges))\n            ]\n\n            # Accept if it improves at least one objective\n            if any(delta < 0 for delta in improvements):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7098387069473007,
            1.983192777633667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with above-average objective values)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    std_obj = np.std(objectives, axis=0)\n\n    # Identify solutions that are above average in at least one objective\n    promising_indices = []\n    for i, obj in enumerate(objectives):\n        if any(obj[j] > mean_obj[j] + 0.5 * std_obj[j] for j in range(3)):\n            promising_indices.append(i)\n\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Standard 2-opt move\n    new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Objective-aware edge swap: consider edges that improve multiple objectives\n    for _ in range(3):  # Perform multiple swaps to explore different objectives\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != i and l != j:  # Ensure we don't interfere with the 2-opt move\n            # Calculate objective improvements\n            old_edges = [\n                (base_solution[k-1], base_solution[k]),\n                (base_solution[l-1], base_solution[l])\n            ]\n            new_edges = [\n                (base_solution[k-1], base_solution[l]),\n                (base_solution[l-1], base_solution[k])\n            ]\n\n            # Calculate potential improvement in all three objectives\n            improvements = [\n                sum(distance_matrix_1[a][b] - distance_matrix_1[c][d] for (a,b), (c,d) in zip(old_edges, new_edges)),\n                sum(distance_matrix_2[a][b] - distance_matrix_2[c][d] for (a,b), (c,d) in zip(old_edges, new_edges)),\n                sum(distance_matrix_3[a][b] - distance_matrix_3[c][d] for (a,b), (c,d) in zip(old_edges, new_edges))\n            ]\n\n            # Accept if it improves at least one objective\n            if any(delta < 0 for delta in improvements):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 97,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment and reverse it (2-opt)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a 3-opt move to further improve the solution\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1])\n\n    # 3. Check if the new solution is better in at least one objective\n    def calculate_objective(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective(base_solution)\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, revert to the original\n    if all(new > current for new, current in zip(new_obj, current_obj)):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6475072045588076,
            2.73155882358551
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment and reverse it (2-opt)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a 3-opt move to further improve the solution\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_solution[a:c+1] = np.concatenate([segment2, segment1])\n\n    # 3. Check if the new solution is better in at least one objective\n    def calculate_objective(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective(base_solution)\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is worse in all objectives, revert to the original\n    if all(new > current for new, current in zip(new_obj, current_obj)):\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 98,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 2:\n        return new_solution\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Choose the distance matrix based on the worst objective\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution based on the selected objective\n    worst_edge = None\n    max_dist = -1\n    for k in range(n):\n        u = base_solution[k]\n        v = base_solution[(k+1)%n]\n        d = dist_matrix[u, v]\n        if d > max_dist:\n            max_dist = d\n            worst_edge = k\n\n    if worst_edge is not None:\n        # Perform a swap that might improve the worst objective\n        a, b = worst_edge, (worst_edge + 1) % n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7744838607804503,
            1.6012303829193115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 2:\n        return new_solution\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Choose the distance matrix based on the worst objective\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution based on the selected objective\n    worst_edge = None\n    max_dist = -1\n    for k in range(n):\n        u = base_solution[k]\n        v = base_solution[(k+1)%n]\n        d = dist_matrix[u, v]\n        if d > max_dist:\n            max_dist = d\n            worst_edge = k\n\n    if worst_edge is not None:\n        # Perform a swap that might improve the worst objective\n        a, b = worst_edge, (worst_edge + 1) % n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 99,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimized in all objectives)\n    # Here we select the solution with the highest sum of objectives as a candidate for improvement\n    candidate_indices = np.argsort([sum(obj) for _, obj in archive])[::-1]\n    selected_index = np.random.choice(candidate_indices[:min(5, len(candidate_indices))])\n    base_solution = archive[selected_index][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to perturb\n    segment_length = np.random.randint(2, min(5, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Apply a 2-opt move within the segment\n    if segment_length > 1:\n        i = np.random.randint(start, end - 1)\n        j = np.random.randint(i + 1, end)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a swap between segments to balance objectives\n    if n > 5:\n        swap_start = np.random.randint(0, n - 2)\n        swap_end = swap_start + 2\n        # Evaluate the current and alternative segments in all objectives\n        current_segment = new_solution[swap_start:swap_end]\n        alternative_segment = np.roll(current_segment, 1)\n\n        # Calculate the change in objectives\n        def calculate_change(segment):\n            cost1 = (distance_matrix_1[segment[-1], segment[0]] +\n                     distance_matrix_1[segment[0], segment[-1]])\n            cost2 = (distance_matrix_2[segment[-1], segment[0]] +\n                     distance_matrix_2[segment[0], segment[-1]])\n            cost3 = (distance_matrix_3[segment[-1], segment[0]] +\n                     distance_matrix_3[segment[0], segment[-1]])\n            return cost1, cost2, cost3\n\n        current_costs = calculate_change(current_segment)\n        alt_costs = calculate_change(alternative_segment)\n\n        # Accept the change if it improves at least one objective\n        if any(alt < curr for alt, curr in zip(alt_costs, current_costs)):\n            new_solution[swap_start:swap_end] = alternative_segment\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: duplicate nodes\"\n    assert np.array_equal(np.sort(new_solution), np.arange(n)), \"Invalid tour: missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.6690836006301004,
            1.8569225311279296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimized in all objectives)\n    # Here we select the solution with the highest sum of objectives as a candidate for improvement\n    candidate_indices = np.argsort([sum(obj) for _, obj in archive])[::-1]\n    selected_index = np.random.choice(candidate_indices[:min(5, len(candidate_indices))])\n    base_solution = archive[selected_index][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to perturb\n    segment_length = np.random.randint(2, min(5, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Apply a 2-opt move within the segment\n    if segment_length > 1:\n        i = np.random.randint(start, end - 1)\n        j = np.random.randint(i + 1, end)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a swap between segments to balance objectives\n    if n > 5:\n        swap_start = np.random.randint(0, n - 2)\n        swap_end = swap_start + 2\n        # Evaluate the current and alternative segments in all objectives\n        current_segment = new_solution[swap_start:swap_end]\n        alternative_segment = np.roll(current_segment, 1)\n\n        # Calculate the change in objectives\n        def calculate_change(segment):\n            cost1 = (distance_matrix_1[segment[-1], segment[0]] +\n                     distance_matrix_1[segment[0], segment[-1]])\n            cost2 = (distance_matrix_2[segment[-1], segment[0]] +\n                     distance_matrix_2[segment[0], segment[-1]])\n            cost3 = (distance_matrix_3[segment[-1], segment[0]] +\n                     distance_matrix_3[segment[0], segment[-1]])\n            return cost1, cost2, cost3\n\n        current_costs = calculate_change(current_segment)\n        alt_costs = calculate_change(alternative_segment)\n\n        # Accept the change if it improves at least one objective\n        if any(alt < curr for alt, curr in zip(alt_costs, current_costs)):\n            new_solution[swap_start:swap_end] = alternative_segment\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: duplicate nodes\"\n    assert np.array_equal(np.sort(new_solution), np.arange(n)), \"Invalid tour: missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 100,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected = random.choices(\n        archive,\n        weights=[1 / (obj[0] * obj[1] * obj[2] + 1e-6) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-aware swaps\n    for _ in range(2):  # Multiple attempts to improve\n        # Calculate current objectives\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        )\n\n        # Find the worst objective to improve\n        worst_obj = np.argmax(current_obj)\n\n        # Select matrices based on worst objective\n        if worst_obj == 0:\n            dmat = distance_matrix_1\n        elif worst_obj == 1:\n            dmat = distance_matrix_2\n        else:\n            dmat = distance_matrix_3\n\n        # Find the best possible swap to improve this objective\n        best_improvement = 0\n        best_swap = (0, 0)\n\n        for a in range(n):\n            for b in range(a + 1, n):\n                # Calculate improvement if we swap nodes a and b\n                old_dist = dmat[new_solution[a-1], new_solution[a]] + dmat[new_solution[b-1], new_solution[b]]\n                new_dist = dmat[new_solution[a-1], new_solution[b]] + dmat[new_solution[b-1], new_solution[a]]\n                improvement = old_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n\n        if best_improvement > 0:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6984158317079876,
            4.177984881401062
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected = random.choices(\n        archive,\n        weights=[1 / (obj[0] * obj[1] * obj[2] + 1e-6) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-aware swaps\n    for _ in range(2):  # Multiple attempts to improve\n        # Calculate current objectives\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        )\n\n        # Find the worst objective to improve\n        worst_obj = np.argmax(current_obj)\n\n        # Select matrices based on worst objective\n        if worst_obj == 0:\n            dmat = distance_matrix_1\n        elif worst_obj == 1:\n            dmat = distance_matrix_2\n        else:\n            dmat = distance_matrix_3\n\n        # Find the best possible swap to improve this objective\n        best_improvement = 0\n        best_swap = (0, 0)\n\n        for a in range(n):\n            for b in range(a + 1, n):\n                # Calculate improvement if we swap nodes a and b\n                old_dist = dmat[new_solution[a-1], new_solution[a]] + dmat[new_solution[b-1], new_solution[b]]\n                new_dist = dmat[new_solution[a-1], new_solution[b]] + dmat[new_solution[b-1], new_solution[a]]\n                improvement = old_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (a, b)\n\n        if best_improvement > 0:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 101,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs for each objective\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(potential_costs[obj] < current_costs[obj] for obj in range(3)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap\n        if (distance_matrix_1[new_solution[k], new_solution[l]] <\n            distance_matrix_1[new_solution[k], new_solution[l]] * 1.1 and  # Small improvement threshold\n            distance_matrix_2[new_solution[k], new_solution[l]] <\n            distance_matrix_2[new_solution[k], new_solution[l]] * 1.1 and\n            distance_matrix_3[new_solution[k], new_solution[l]] <\n            distance_matrix_3[new_solution[k], new_solution[l]] * 1.1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6339446202168111,
            3.0572320461273192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs for each objective\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(potential_costs[obj] < current_costs[obj] for obj in range(3)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap\n        if (distance_matrix_1[new_solution[k], new_solution[l]] <\n            distance_matrix_1[new_solution[k], new_solution[l]] * 1.1 and  # Small improvement threshold\n            distance_matrix_2[new_solution[k], new_solution[l]] <\n            distance_matrix_2[new_solution[k], new_solution[l]] * 1.1 and\n            distance_matrix_3[new_solution[k], new_solution[l]] <\n            distance_matrix_3[new_solution[k], new_solution[l]] * 1.1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 102,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a score for each solution based on the sum of its objectives (lower is better)\n    scores = [sum(obj) for obj in archive_objectives]\n    min_score = min(scores)\n    candidates = [i for i, score in enumerate(scores) if score <= min_score + 0.1 * (max(scores) - min_score)]\n\n    # Randomly select from the top candidates\n    selected_idx = np.random.choice(candidates)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move with probability 0.7, otherwise perform edge exchange\n    if np.random.random() < 0.7:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge exchange local search\n        if n >= 4:\n            a, b, c, d = np.random.choice(n, 4, replace=False)\n            # Ensure all indices are distinct\n            a, b, c, d = sorted([a, b, c, d])[:4]\n            # Swap edges (a,b)-(c,d) to (a,c)-(b,d)\n            new_solution[[a+1, b]] = new_solution[b], new_solution[a+1]\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6584531833500569,
            3.820429873466492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a score for each solution based on the sum of its objectives (lower is better)\n    scores = [sum(obj) for obj in archive_objectives]\n    min_score = min(scores)\n    candidates = [i for i, score in enumerate(scores) if score <= min_score + 0.1 * (max(scores) - min_score)]\n\n    # Randomly select from the top candidates\n    selected_idx = np.random.choice(candidates)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move with probability 0.7, otherwise perform edge exchange\n    if np.random.random() < 0.7:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge exchange local search\n        if n >= 4:\n            a, b, c, d = np.random.choice(n, 4, replace=False)\n            # Ensure all indices are distinct\n            a, b, c, d = sorted([a, b, c, d])[:4]\n            # Swap edges (a,b)-(c,d) to (a,c)-(b,d)\n            new_solution[[a+1, b]] = new_solution[b], new_solution[a+1]\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 103,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n\n    # Randomly decide between 2-opt and objective-aware swap\n    if np.random.rand() < 0.5:\n        # Perform 2-opt\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware swap: find the worst edge in any objective space and try to improve it\n        objectives = archive[selected_idx][1]\n        worst_obj = np.argmax(objectives)\n\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective space\n        worst_edge = -1\n        max_dist = -1\n        for i in range(len(new_solution)):\n            u = new_solution[i]\n            v = new_solution[(i+1)%len(new_solution)]\n            if dist_matrix[u, v] > max_dist:\n                max_dist = dist_matrix[u, v]\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Try to replace the worst edge with a better one\n            u = new_solution[worst_edge]\n            v = new_solution[(worst_edge+1)%len(new_solution)]\n\n            # Find the best possible replacement\n            best_replacement = None\n            min_dist = float('inf')\n            for i in range(len(new_solution)):\n                if i == worst_edge or i == (worst_edge+1)%len(new_solution):\n                    continue\n                x = new_solution[i]\n                y = new_solution[(i+1)%len(new_solution)]\n                if dist_matrix[x, y] < min_dist:\n                    best_replacement = (i, (i+1)%len(new_solution))\n                    min_dist = dist_matrix[x, y]\n\n            if best_replacement is not None:\n                # Perform the swap\n                i, j = best_replacement\n                # Ensure the swap maintains feasibility\n                if i < worst_edge < j or j < worst_edge < i:\n                    # Need to reverse the segment to maintain order\n                    new_solution[min(i,j):max(i,j)+1] = new_solution[min(i,j):max(i,j)+1][::-1]\n                else:\n                    # Simple swap\n                    new_solution[worst_edge] = new_solution[i]\n                    new_solution[(worst_edge+1)%len(new_solution)] = new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7079028198111267,
            1.1556257486343384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n\n    # Randomly decide between 2-opt and objective-aware swap\n    if np.random.rand() < 0.5:\n        # Perform 2-opt\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware swap: find the worst edge in any objective space and try to improve it\n        objectives = archive[selected_idx][1]\n        worst_obj = np.argmax(objectives)\n\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective space\n        worst_edge = -1\n        max_dist = -1\n        for i in range(len(new_solution)):\n            u = new_solution[i]\n            v = new_solution[(i+1)%len(new_solution)]\n            if dist_matrix[u, v] > max_dist:\n                max_dist = dist_matrix[u, v]\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Try to replace the worst edge with a better one\n            u = new_solution[worst_edge]\n            v = new_solution[(worst_edge+1)%len(new_solution)]\n\n            # Find the best possible replacement\n            best_replacement = None\n            min_dist = float('inf')\n            for i in range(len(new_solution)):\n                if i == worst_edge or i == (worst_edge+1)%len(new_solution):\n                    continue\n                x = new_solution[i]\n                y = new_solution[(i+1)%len(new_solution)]\n                if dist_matrix[x, y] < min_dist:\n                    best_replacement = (i, (i+1)%len(new_solution))\n                    min_dist = dist_matrix[x, y]\n\n            if best_replacement is not None:\n                # Perform the swap\n                i, j = best_replacement\n                # Ensure the swap maintains feasibility\n                if i < worst_edge < j or j < worst_edge < i:\n                    # Need to reverse the segment to maintain order\n                    new_solution[min(i,j):max(i,j)+1] = new_solution[min(i,j):max(i,j)+1][::-1]\n                else:\n                    # Simple swap\n                    new_solution[worst_edge] = new_solution[i]\n                    new_solution[(worst_edge+1)%len(new_solution)] = new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 104,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective values\n    # Here, we select the solution with the highest sum of objectives (can be adjusted)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform a 2-opt swap if it improves at least one objective\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    # Calculate the change in objectives\n    def calculate_objective(sol):\n        obj1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        obj2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        obj3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (obj1, obj2, obj3)\n\n    original_obj = archive[selected_idx][1]\n    new_obj = calculate_objective(temp_solution)\n\n    # Accept the swap if it improves at least one objective\n    if any(new_obj[k] < original_obj[k] for k in range(3)):\n        new_solution = temp_solution\n    else:\n        # If not, perform a random swap and accept if it improves any objective\n        k, l = np.random.choice(n, 2, replace=False)\n        temp_solution = new_solution.copy()\n        temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n        new_obj = calculate_objective(temp_solution)\n        if any(new_obj[k] < original_obj[k] for k in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.650386361953267,
            1.4835975408554076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective values\n    # Here, we select the solution with the highest sum of objectives (can be adjusted)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform a 2-opt swap if it improves at least one objective\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    # Calculate the change in objectives\n    def calculate_objective(sol):\n        obj1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        obj2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        obj3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (obj1, obj2, obj3)\n\n    original_obj = archive[selected_idx][1]\n    new_obj = calculate_objective(temp_solution)\n\n    # Accept the swap if it improves at least one objective\n    if any(new_obj[k] < original_obj[k] for k in range(3)):\n        new_solution = temp_solution\n    else:\n        # If not, perform a random swap and accept if it improves any objective\n        k, l = np.random.choice(n, 2, replace=False)\n        temp_solution = new_solution.copy()\n        temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n        new_obj = calculate_objective(temp_solution)\n        if any(new_obj[k] < original_obj[k] for k in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 105,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize solutions with lower total cost\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, len(sorted_archive) // 3 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for the local search\n        # Choose the objective with the highest cost in the selected solution\n        obj_idx = np.argmax(archive[selected_idx][1]) if len(archive) > 1 else random.randint(0, 2)\n\n        # Apply a modified 2-opt that considers the selected objective's distance matrix\n        i, j = sorted(random.sample(range(n), 2))\n        if obj_idx == 0:\n            # Check if reversing the segment improves the first objective\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif obj_idx == 1:\n            # Check if reversing the segment improves the second objective\n            current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Check if reversing the segment improves the third objective\n            current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # With 50% probability, apply a 3-opt move to further improve the solution\n        if random.random() < 0.5:\n            a, b, c = sorted(random.sample(range(n), 3))\n            # Try different orderings for the selected segment\n            variants = [\n                np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c][::-1], new_solution[c:]]),\n                np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n                np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]])\n            ]\n            # Evaluate each variant based on the selected objective\n            best_variant = new_solution.copy()\n            best_cost = float('inf')\n            for variant in variants:\n                if obj_idx == 0:\n                    cost = sum(distance_matrix_1[variant[i], variant[i+1]] for i in range(n-1)) + distance_matrix_1[variant[-1], variant[0]]\n                elif obj_idx == 1:\n                    cost = sum(distance_matrix_2[variant[i], variant[i+1]] for i in range(n-1)) + distance_matrix_2[variant[-1], variant[0]]\n                else:\n                    cost = sum(distance_matrix_3[variant[i], variant[i+1]] for i in range(n-1)) + distance_matrix_3[variant[-1], variant[0]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_variant = variant.copy()\n            new_solution = best_variant\n\n    return new_solution\n\n",
        "score": [
            -0.7119636327470139,
            2.6989662885665893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize solutions with lower total cost\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, len(sorted_archive) // 3 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for the local search\n        # Choose the objective with the highest cost in the selected solution\n        obj_idx = np.argmax(archive[selected_idx][1]) if len(archive) > 1 else random.randint(0, 2)\n\n        # Apply a modified 2-opt that considers the selected objective's distance matrix\n        i, j = sorted(random.sample(range(n), 2))\n        if obj_idx == 0:\n            # Check if reversing the segment improves the first objective\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif obj_idx == 1:\n            # Check if reversing the segment improves the second objective\n            current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Check if reversing the segment improves the third objective\n            current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # With 50% probability, apply a 3-opt move to further improve the solution\n        if random.random() < 0.5:\n            a, b, c = sorted(random.sample(range(n), 3))\n            # Try different orderings for the selected segment\n            variants = [\n                np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c][::-1], new_solution[c:]]),\n                np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n                np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]])\n            ]\n            # Evaluate each variant based on the selected objective\n            best_variant = new_solution.copy()\n            best_cost = float('inf')\n            for variant in variants:\n                if obj_idx == 0:\n                    cost = sum(distance_matrix_1[variant[i], variant[i+1]] for i in range(n-1)) + distance_matrix_1[variant[-1], variant[0]]\n                elif obj_idx == 1:\n                    cost = sum(distance_matrix_2[variant[i], variant[i+1]] for i in range(n-1)) + distance_matrix_2[variant[-1], variant[0]]\n                else:\n                    cost = sum(distance_matrix_3[variant[i], variant[i+1]] for i in range(n-1)) + distance_matrix_3[variant[-1], variant[0]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_variant = variant.copy()\n            new_solution = best_variant\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 106,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.sum(objectives, axis=0, keepdims=True)\n    weights = 1 / (1 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. With 50% probability, perform a 2-opt move\n    # 2. With 30% probability, perform a 3-opt move\n    # 3. With 20% probability, perform a cross-exchange move\n    operator_choice = random.random()\n\n    if operator_choice < 0.5:  # 2-opt\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator_choice < 0.8:  # 3-opt\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:  # Cross-exchange\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7511445674432035,
            2.0691784977912904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.sum(objectives, axis=0, keepdims=True)\n    weights = 1 / (1 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. With 50% probability, perform a 2-opt move\n    # 2. With 30% probability, perform a 3-opt move\n    # 3. With 20% probability, perform a cross-exchange move\n    operator_choice = random.random()\n\n    if operator_choice < 0.5:  # 2-opt\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator_choice < 0.8:  # 3-opt\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:  # Cross-exchange\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 107,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher objective values)\n    candidates = []\n    for sol, obj in archive:\n        # Calculate a score based on the sum of objectives (higher score = more potential)\n        score = sum(obj)\n        candidates.append((score, sol))\n\n    # Sort candidates by score in descending order and select top 20% or at least 1\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    top_k = max(1, len(candidates) // 5)\n    selected = random.choice(candidates[:top_k])[1].copy()\n\n    # Apply a hybrid local search operator\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly choose one of three local search operators\n    operator = random.choice(['2-opt', 'swap', 'inversion'])\n\n    if operator == '2-opt':\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator == 'swap':\n        # Swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Inversion of a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates and complete tour)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5440957164979977,
            1.592833125591278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher objective values)\n    candidates = []\n    for sol, obj in archive:\n        # Calculate a score based on the sum of objectives (higher score = more potential)\n        score = sum(obj)\n        candidates.append((score, sol))\n\n    # Sort candidates by score in descending order and select top 20% or at least 1\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    top_k = max(1, len(candidates) // 5)\n    selected = random.choice(candidates[:top_k])[1].copy()\n\n    # Apply a hybrid local search operator\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly choose one of three local search operators\n    operator = random.choice(['2-opt', 'swap', 'inversion'])\n\n    if operator == '2-opt':\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator == 'swap':\n        # Swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Inversion of a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates and complete tour)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 108,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (lowest sum of objectives)\n    archive_with_scores = [(sol, obj, sum(obj)) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: x[2])\n    selected_idx = min(2, len(archive_with_scores) - 1)  # Select from top 3 solutions\n    base_solution, _, _ = archive_with_scores[selected_idx]\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3D-aware 2-opt variant\n    for _ in range(3):  # Perform multiple iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[i], new_solution[j-1]] +\n                          distance_matrix_2[new_solution[i], new_solution[j-1]] +\n                          distance_matrix_3[new_solution[i], new_solution[j-1]])\n\n        # Accept if improvement in at least one objective\n        if potential_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Apply 3D-aware node insertion\n    for _ in range(2):\n        # Select a random node and position\n        node = np.random.choice(new_solution)\n        pos = np.random.randint(0, n)\n\n        # Remove and reinsert\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7012532816933482,
            2.2904836773872375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (lowest sum of objectives)\n    archive_with_scores = [(sol, obj, sum(obj)) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: x[2])\n    selected_idx = min(2, len(archive_with_scores) - 1)  # Select from top 3 solutions\n    base_solution, _, _ = archive_with_scores[selected_idx]\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3D-aware 2-opt variant\n    for _ in range(3):  # Perform multiple iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[i], new_solution[j-1]] +\n                          distance_matrix_2[new_solution[i], new_solution[j-1]] +\n                          distance_matrix_3[new_solution[i], new_solution[j-1]])\n\n        # Accept if improvement in at least one objective\n        if potential_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Apply 3D-aware node insertion\n    for _ in range(2):\n        # Select a random node and position\n        node = np.random.choice(new_solution)\n        pos = np.random.randint(0, n)\n\n        # Remove and reinsert\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 109,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (here, we select the one with the highest sum of objectives)\n    objectives = [obj for _, obj in archive]\n    sum_objectives = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel multi-objective swap\n    # Select two random edges and swap their nodes if it improves at least one objective\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate current and potential new costs for all three objectives\n    current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]])\n    current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]])\n    current_cost3 = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n    new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[a]])\n    new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[a]])\n    new_cost3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_3[new_solution[b-1], new_solution[a]])\n\n    # Accept the swap if it improves at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or (new_cost3 < current_cost3):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5843038532108096,
            1.7530276775360107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (here, we select the one with the highest sum of objectives)\n    objectives = [obj for _, obj in archive]\n    sum_objectives = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel multi-objective swap\n    # Select two random edges and swap their nodes if it improves at least one objective\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate current and potential new costs for all three objectives\n    current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]])\n    current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]])\n    current_cost3 = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n    new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[a]])\n    new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[a]])\n    new_cost3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_3[new_solution[b-1], new_solution[a]])\n\n    # Accept the swap if it improves at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or (new_cost3 < current_cost3):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 110,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Simple selection strategy: pick a random solution (could be improved with more sophisticated criteria)\n        selected_idx = np.random.randint(0, len(archive))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply a 2-opt move to improve the solution in one objective space\n    # 2. Apply a node insertion to improve another objective space\n    # 3. Apply a swap to improve the third objective space\n\n    n = len(new_solution)\n    obj_weights = np.random.rand(3)  # Random weights for objectives (could be based on improvement potential)\n\n    # Determine which objective to prioritize for each move\n    if obj_weights[0] > obj_weights[1] and obj_weights[0] > obj_weights[2]:\n        # Prioritize first objective space\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # 2-opt move\n    elif obj_weights[1] > obj_weights[0] and obj_weights[1] > obj_weights[2]:\n        # Prioritize second objective space\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])  # Insertion\n    else:\n        # Prioritize third objective space\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Swap\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes[0]\n            missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.74608991837981,
            1.2217562198638916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Simple selection strategy: pick a random solution (could be improved with more sophisticated criteria)\n        selected_idx = np.random.randint(0, len(archive))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply a 2-opt move to improve the solution in one objective space\n    # 2. Apply a node insertion to improve another objective space\n    # 3. Apply a swap to improve the third objective space\n\n    n = len(new_solution)\n    obj_weights = np.random.rand(3)  # Random weights for objectives (could be based on improvement potential)\n\n    # Determine which objective to prioritize for each move\n    if obj_weights[0] > obj_weights[1] and obj_weights[0] > obj_weights[2]:\n        # Prioritize first objective space\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # 2-opt move\n    elif obj_weights[1] > obj_weights[0] and obj_weights[1] > obj_weights[2]:\n        # Prioritize second objective space\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])  # Insertion\n    else:\n        # Prioritize third objective space\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Swap\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes[0]\n            missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 111,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential for improvement\n    # Here we select the solution with the highest sum of objectives (worst in all three objectives)\n    # This is a heuristic to identify solutions that may have room for improvement\n    max_obj_sum = -1\n    selected_solution = None\n    for sol, obj in archive:\n        obj_sum = sum(obj)\n        if obj_sum > max_obj_sum:\n            max_obj_sum = obj_sum\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy combining multiple operators\n    n = len(new_solution)\n\n    # Operator 1: 2-opt swap (for one objective)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Operator 2: 3-opt swap (for another objective)\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Operator 3: Node insertion (for the third objective)\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5904711644150649,
            1.5613989353179931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential for improvement\n    # Here we select the solution with the highest sum of objectives (worst in all three objectives)\n    # This is a heuristic to identify solutions that may have room for improvement\n    max_obj_sum = -1\n    selected_solution = None\n    for sol, obj in archive:\n        obj_sum = sum(obj)\n        if obj_sum > max_obj_sum:\n            max_obj_sum = obj_sum\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy combining multiple operators\n    n = len(new_solution)\n\n    # Operator 1: 2-opt swap (for one objective)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Operator 2: 3-opt swap (for another objective)\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Operator 3: Node insertion (for the third objective)\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 112,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., high crowding distance in objective space)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Evaluate the current segment's contribution to each objective\n    def segment_cost(seg):\n        c1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        c2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        c3 = sum(distance_matrix_3[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        return c1, c2, c3\n\n    current_cost = segment_cost(segment)\n\n    # Step 3: Try reversing the segment (2-opt move)\n    reversed_segment = segment[::-1]\n    reversed_cost = segment_cost(reversed_segment)\n\n    # Step 4: If the reversed segment improves any objective, accept it\n    if any(rc < cc for rc, cc in zip(reversed_cost, current_cost)):\n        new_solution[a:b+1] = reversed_segment\n        return new_solution\n\n    # Step 5: If not, try swapping edges between segments (objective-aware)\n    if n > 4:\n        c = np.random.randint(0, n)\n        while c in [a, b]:\n            c = np.random.randint(0, n)\n\n        # Try swapping edges a-b and c-d\n        if c < a:\n            new_solution[c:a+1] = new_solution[c:a+1][::-1]\n        else:\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7865069346146127,
            1.5211072325706483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., high crowding distance in objective space)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Evaluate the current segment's contribution to each objective\n    def segment_cost(seg):\n        c1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        c2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        c3 = sum(distance_matrix_3[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        return c1, c2, c3\n\n    current_cost = segment_cost(segment)\n\n    # Step 3: Try reversing the segment (2-opt move)\n    reversed_segment = segment[::-1]\n    reversed_cost = segment_cost(reversed_segment)\n\n    # Step 4: If the reversed segment improves any objective, accept it\n    if any(rc < cc for rc, cc in zip(reversed_cost, current_cost)):\n        new_solution[a:b+1] = reversed_segment\n        return new_solution\n\n    # Step 5: If not, try swapping edges between segments (objective-aware)\n    if n > 4:\n        c = np.random.randint(0, n)\n        while c in [a, b]:\n            c = np.random.randint(0, n)\n\n        # Try swapping edges a-b and c-d\n        if c < a:\n            new_solution[c:a+1] = new_solution[c:a+1][::-1]\n        else:\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 113,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the worst objective (to find solutions that can be improved)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n\n    # Select the top 20% of solutions with the worst objective\n    top_percent = max(1, int(0.2 * len(archive_sorted)))\n    candidates = archive_sorted[:top_percent]\n\n    # Randomly select a candidate solution\n    selected_solution = candidates[np.random.randint(0, len(candidates))][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # 1. 2-opt move (local search in one objective)\n    i, j = np.random.randint(0, len(new_solution), size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Objective-aware swap (consider all three objectives)\n    k, l = np.random.randint(0, len(new_solution), size=2)\n    if k != l:\n        # Calculate improvement in all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]] +\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]] +\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        )\n\n        # Accept swap if it improves at least one objective\n        if swapped_cost < original_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Objective-specific edge insertion (consider one random objective)\n    obj = np.random.randint(0, 3)\n    if obj == 0:\n        dm = distance_matrix_1\n    elif obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    m, n = np.random.randint(0, len(new_solution), size=2)\n    if m != n:\n        # Remove edge (m, n) and insert it between (k, l)\n        k, l = np.random.randint(0, len(new_solution), size=2)\n        if k > l:\n            k, l = l, k\n\n        # Calculate cost before insertion\n        original_cost = dm[new_solution[m-1], new_solution[m]] + dm[new_solution[n-1], new_solution[n]]\n\n        # Calculate cost after insertion\n        new_cost = dm[new_solution[m-1], new_solution[n]] + dm[new_solution[k], new_solution[l]]\n\n        # Accept if improvement\n        if new_cost < original_cost:\n            new_solution = np.concatenate([\n                new_solution[:k],\n                new_solution[m:n],\n                new_solution[k:l],\n                new_solution[n:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6961767325833342,
            0.8924706459045411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the worst objective (to find solutions that can be improved)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n\n    # Select the top 20% of solutions with the worst objective\n    top_percent = max(1, int(0.2 * len(archive_sorted)))\n    candidates = archive_sorted[:top_percent]\n\n    # Randomly select a candidate solution\n    selected_solution = candidates[np.random.randint(0, len(candidates))][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # 1. 2-opt move (local search in one objective)\n    i, j = np.random.randint(0, len(new_solution), size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Objective-aware swap (consider all three objectives)\n    k, l = np.random.randint(0, len(new_solution), size=2)\n    if k != l:\n        # Calculate improvement in all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]] +\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]] +\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        )\n\n        # Accept swap if it improves at least one objective\n        if swapped_cost < original_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Objective-specific edge insertion (consider one random objective)\n    obj = np.random.randint(0, 3)\n    if obj == 0:\n        dm = distance_matrix_1\n    elif obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    m, n = np.random.randint(0, len(new_solution), size=2)\n    if m != n:\n        # Remove edge (m, n) and insert it between (k, l)\n        k, l = np.random.randint(0, len(new_solution), size=2)\n        if k > l:\n            k, l = l, k\n\n        # Calculate cost before insertion\n        original_cost = dm[new_solution[m-1], new_solution[m]] + dm[new_solution[n-1], new_solution[n]]\n\n        # Calculate cost after insertion\n        new_cost = dm[new_solution[m-1], new_solution[n]] + dm[new_solution[k], new_solution[l]]\n\n        # Accept if improvement\n        if new_cost < original_cost:\n            new_solution = np.concatenate([\n                new_solution[:k],\n                new_solution[m:n],\n                new_solution[k:l],\n                new_solution[n:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 113,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the worst objective (to find solutions that can be improved)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n\n    # Select the top 20% of solutions with the worst objective\n    top_percent = max(1, int(0.2 * len(archive_sorted)))\n    candidates = archive_sorted[:top_percent]\n\n    # Randomly select a candidate solution\n    selected_solution = candidates[np.random.randint(0, len(candidates))][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # 1. 2-opt move (local search in one objective)\n    i, j = np.random.randint(0, len(new_solution), size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Objective-aware swap (consider all three objectives)\n    k, l = np.random.randint(0, len(new_solution), size=2)\n    if k != l:\n        # Calculate improvement in all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]] +\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]] +\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        )\n\n        # Accept swap if it improves at least one objective\n        if swapped_cost < original_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Objective-specific edge insertion (consider one random objective)\n    obj = np.random.randint(0, 3)\n    if obj == 0:\n        dm = distance_matrix_1\n    elif obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    m, n = np.random.randint(0, len(new_solution), size=2)\n    if m != n:\n        # Remove edge (m, n) and insert it between (k, l)\n        k, l = np.random.randint(0, len(new_solution), size=2)\n        if k > l:\n            k, l = l, k\n\n        # Calculate cost before insertion\n        original_cost = dm[new_solution[m-1], new_solution[m]] + dm[new_solution[n-1], new_solution[n]]\n\n        # Calculate cost after insertion\n        new_cost = dm[new_solution[m-1], new_solution[n]] + dm[new_solution[k], new_solution[l]]\n\n        # Accept if improvement\n        if new_cost < original_cost:\n            new_solution = np.concatenate([\n                new_solution[:k],\n                new_solution[m:n],\n                new_solution[k:l],\n                new_solution[n:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6961767325833342,
            0.8924706459045411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the worst objective (to find solutions that can be improved)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n\n    # Select the top 20% of solutions with the worst objective\n    top_percent = max(1, int(0.2 * len(archive_sorted)))\n    candidates = archive_sorted[:top_percent]\n\n    # Randomly select a candidate solution\n    selected_solution = candidates[np.random.randint(0, len(candidates))][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # 1. 2-opt move (local search in one objective)\n    i, j = np.random.randint(0, len(new_solution), size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Objective-aware swap (consider all three objectives)\n    k, l = np.random.randint(0, len(new_solution), size=2)\n    if k != l:\n        # Calculate improvement in all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]] +\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]] +\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        )\n\n        # Accept swap if it improves at least one objective\n        if swapped_cost < original_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Objective-specific edge insertion (consider one random objective)\n    obj = np.random.randint(0, 3)\n    if obj == 0:\n        dm = distance_matrix_1\n    elif obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    m, n = np.random.randint(0, len(new_solution), size=2)\n    if m != n:\n        # Remove edge (m, n) and insert it between (k, l)\n        k, l = np.random.randint(0, len(new_solution), size=2)\n        if k > l:\n            k, l = l, k\n\n        # Calculate cost before insertion\n        original_cost = dm[new_solution[m-1], new_solution[m]] + dm[new_solution[n-1], new_solution[n]]\n\n        # Calculate cost after insertion\n        new_cost = dm[new_solution[m-1], new_solution[n]] + dm[new_solution[k], new_solution[l]]\n\n        # Accept if improvement\n        if new_cost < original_cost:\n            new_solution = np.concatenate([\n                new_solution[:k],\n                new_solution[m:n],\n                new_solution[k:l],\n                new_solution[n:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 114,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 20% or top 5, whichever is larger\n        selection_pool = sorted_archive[:max(1, min(5, len(sorted_archive) // 5))]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Choose between 2-opt and objective-aware swap based on solution quality\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # Standard 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: find a node that improves at least one objective\n            best_improvement = 0\n            best_swap = None\n\n            # Evaluate all possible swaps (limited to 100 random swaps for efficiency)\n            for _ in range(min(100, n*(n-1)//2)):\n                i, j = random.sample(range(n), 2)\n                if i > j:\n                    i, j = j, i\n\n                # Calculate current and new distances for all objectives\n                current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n                current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n                current_dist3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n                new_dist3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n\n                # Calculate improvement for each objective\n                improvement1 = current_dist1 - new_dist1\n                improvement2 = current_dist2 - new_dist2\n                improvement3 = current_dist3 - new_dist3\n\n                # Count how many objectives are improved\n                num_improved = sum(1 for imp in [improvement1, improvement2, improvement3] if imp > 0)\n\n                # Track the best swap that improves at least one objective\n                if num_improved > best_improvement or (num_improved == best_improvement and random.random() < 0.3):\n                    best_improvement = num_improved\n                    best_swap = (i, j)\n\n            if best_swap is not None:\n                i, j = best_swap\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6154609579351235,
            2.5097781300544737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 20% or top 5, whichever is larger\n        selection_pool = sorted_archive[:max(1, min(5, len(sorted_archive) // 5))]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Choose between 2-opt and objective-aware swap based on solution quality\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # Standard 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: find a node that improves at least one objective\n            best_improvement = 0\n            best_swap = None\n\n            # Evaluate all possible swaps (limited to 100 random swaps for efficiency)\n            for _ in range(min(100, n*(n-1)//2)):\n                i, j = random.sample(range(n), 2)\n                if i > j:\n                    i, j = j, i\n\n                # Calculate current and new distances for all objectives\n                current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n                current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n                current_dist3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n                new_dist3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n\n                # Calculate improvement for each objective\n                improvement1 = current_dist1 - new_dist1\n                improvement2 = current_dist2 - new_dist2\n                improvement3 = current_dist3 - new_dist3\n\n                # Count how many objectives are improved\n                num_improved = sum(1 for imp in [improvement1, improvement2, improvement3] if imp > 0)\n\n                # Track the best swap that improves at least one objective\n                if num_improved > best_improvement or (num_improved == best_improvement and random.random() < 0.3):\n                    best_improvement = num_improved\n                    best_swap = (i, j)\n\n            if best_swap is not None:\n                i, j = best_swap\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 115,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good in all objectives)\n    def selection_criteria(obj):\n        # Prefer solutions that are not dominated in all objectives\n        return sum(obj) / len(obj)  # Simple average, can be replaced with more sophisticated criteria\n\n    # Sort solutions by selection criteria (ascending)\n    archive_sorted = sorted(archive, key=lambda x: selection_criteria(x[1]))\n\n    # Select top 20% of solutions for exploration\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between different local search strategies\n    strategy = random.choice(['2opt', 'objective_aware_swap', 'multi_objective_2opt'])\n\n    if strategy == '2opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif strategy == 'objective_aware_swap':\n        # Swap edges based on which objective would benefit most\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate potential improvement for each objective\n        obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        obj1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        obj2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        obj3_before = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        obj3_after = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n\n        # If any objective improves, perform the swap\n        if obj1_after < obj1_before or obj2_after < obj2_before or obj3_after < obj3_before:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif strategy == 'multi_objective_2opt':\n        # Multi-objective aware 2-opt that considers all objectives\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate total improvement across all objectives\n        total_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) + \\\n                       (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) + \\\n                       (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        total_after = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) + \\\n                      (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) + \\\n                      (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        if total_after < total_before:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5849065514748005,
            3.2246744632720947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good in all objectives)\n    def selection_criteria(obj):\n        # Prefer solutions that are not dominated in all objectives\n        return sum(obj) / len(obj)  # Simple average, can be replaced with more sophisticated criteria\n\n    # Sort solutions by selection criteria (ascending)\n    archive_sorted = sorted(archive, key=lambda x: selection_criteria(x[1]))\n\n    # Select top 20% of solutions for exploration\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between different local search strategies\n    strategy = random.choice(['2opt', 'objective_aware_swap', 'multi_objective_2opt'])\n\n    if strategy == '2opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif strategy == 'objective_aware_swap':\n        # Swap edges based on which objective would benefit most\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate potential improvement for each objective\n        obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        obj1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        obj2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        obj3_before = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        obj3_after = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n\n        # If any objective improves, perform the swap\n        if obj1_after < obj1_before or obj2_after < obj2_before or obj3_after < obj3_before:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif strategy == 'multi_objective_2opt':\n        # Multi-objective aware 2-opt that considers all objectives\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate total improvement across all objectives\n        total_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) + \\\n                       (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) + \\\n                       (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        total_after = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) + \\\n                      (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) + \\\n                      (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        if total_after < total_before:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 116,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Determine which objective space has the highest potential for improvement\n    # Here, we prioritize the objective with the highest current value\n    max_obj_idx = np.argmax(objectives)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Hybrid local search: combine 2-opt and edge insertion for the selected objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge insertion for the selected objective\n    best_insertion = None\n    best_improvement = 0\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n        # Try inserting node k between i and j\n        temp_solution = new_solution.copy()\n        temp_solution = np.insert(temp_solution, i, temp_solution[k])\n        temp_solution = np.delete(temp_solution, k + (1 if k > i else 0))\n\n        # Calculate improvement in the selected objective space\n        original_cost = (distance_matrices[max_obj_idx][new_solution[i-1], new_solution[i]] +\n                          distance_matrices[max_obj_idx][new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrices[max_obj_idx][temp_solution[i-1], temp_solution[i]] +\n                    distance_matrices[max_obj_idx][temp_solution[j], temp_solution[(j+1)%n]])\n\n        improvement = original_cost - new_cost\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insertion = temp_solution\n\n    if best_insertion is not None:\n        new_solution = best_insertion\n\n    # Ensure the solution remains valid (no duplicates, all nodes covered)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7339142270456982,
            3.07826452255249
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Determine which objective space has the highest potential for improvement\n    # Here, we prioritize the objective with the highest current value\n    max_obj_idx = np.argmax(objectives)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Hybrid local search: combine 2-opt and edge insertion for the selected objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge insertion for the selected objective\n    best_insertion = None\n    best_improvement = 0\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n        # Try inserting node k between i and j\n        temp_solution = new_solution.copy()\n        temp_solution = np.insert(temp_solution, i, temp_solution[k])\n        temp_solution = np.delete(temp_solution, k + (1 if k > i else 0))\n\n        # Calculate improvement in the selected objective space\n        original_cost = (distance_matrices[max_obj_idx][new_solution[i-1], new_solution[i]] +\n                          distance_matrices[max_obj_idx][new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrices[max_obj_idx][temp_solution[i-1], temp_solution[i]] +\n                    distance_matrices[max_obj_idx][temp_solution[j], temp_solution[(j+1)%n]])\n\n        improvement = original_cost - new_cost\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insertion = temp_solution\n\n    if best_insertion is not None:\n        new_solution = best_insertion\n\n    # Ensure the solution remains valid (no duplicates, all nodes covered)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 117,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to find those that are not dominated by many others\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list to avoid extremes\n        selected_idx = len(archive_sorted) // 2\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt, insertion, and swap moves\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful local search possible for small tours\n\n    # Randomly choose one of the three local search operators\n    operator = np.random.choice(['2opt', 'insertion', 'swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'insertion':\n        # Perform insertion move\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        # Perform swap move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If the solution is invalid, revert to the original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.74420197338496,
            1.9288201332092285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to find those that are not dominated by many others\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list to avoid extremes\n        selected_idx = len(archive_sorted) // 2\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt, insertion, and swap moves\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful local search possible for small tours\n\n    # Randomly choose one of the three local search operators\n    operator = np.random.choice(['2opt', 'insertion', 'swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'insertion':\n        # Perform insertion move\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        # Perform swap move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If the solution is invalid, revert to the original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 118,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution in the archive\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        sorted_objectives = objectives[sorted_indices, m]\n        crowding = np.zeros(len(sorted_indices))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_indices) - 1):\n            crowding[i] = sorted_objectives[i+1] - sorted_objectives[i-1]\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances across objectives\n    combined_crowding = np.sum(crowding_distances, axis=0)\n    selected_index = np.argmax(combined_crowding)\n    base_solution = archive[selected_index][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour for perturbation\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(10, n - 1))\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate((new_solution[start:], new_solution[:end]))\n\n    # Reverse the segment (2-opt move)\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    if start < end:\n        new_solution[start:end] = reversed_segment\n    else:\n        new_solution[:end] = reversed_segment[:end]\n        new_solution[start:] = reversed_segment[end:]\n\n    # Apply a 3-opt move to further improve the solution\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and select the one that improves the most\n    moves = [\n        np.concatenate((new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:])),\n        np.concatenate((new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:])),\n        np.concatenate((new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]))\n    ]\n\n    # Evaluate each move based on the sum of distances across all three objectives\n    best_move = new_solution.copy()\n    best_cost = float('inf')\n\n    for move in moves:\n        cost1 = sum(distance_matrix_1[move[i-1], move[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[move[i-1], move[i]] for i in range(n))\n        cost3 = sum(distance_matrix_3[move[i-1], move[i]] for i in range(n))\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_move = move.copy()\n\n    new_solution = best_move\n\n    return new_solution\n\n",
        "score": [
            -0.7162180512939069,
            2.9754191756248476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution in the archive\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        sorted_objectives = objectives[sorted_indices, m]\n        crowding = np.zeros(len(sorted_indices))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_indices) - 1):\n            crowding[i] = sorted_objectives[i+1] - sorted_objectives[i-1]\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances across objectives\n    combined_crowding = np.sum(crowding_distances, axis=0)\n    selected_index = np.argmax(combined_crowding)\n    base_solution = archive[selected_index][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour for perturbation\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(10, n - 1))\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate((new_solution[start:], new_solution[:end]))\n\n    # Reverse the segment (2-opt move)\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    if start < end:\n        new_solution[start:end] = reversed_segment\n    else:\n        new_solution[:end] = reversed_segment[:end]\n        new_solution[start:] = reversed_segment[end:]\n\n    # Apply a 3-opt move to further improve the solution\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create three possible 3-opt moves and select the one that improves the most\n    moves = [\n        np.concatenate((new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:])),\n        np.concatenate((new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:])),\n        np.concatenate((new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]))\n    ]\n\n    # Evaluate each move based on the sum of distances across all three objectives\n    best_move = new_solution.copy()\n    best_cost = float('inf')\n\n    for move in moves:\n        cost1 = sum(distance_matrix_1[move[i-1], move[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[move[i-1], move[i]] for i in range(n))\n        cost3 = sum(distance_matrix_3[move[i-1], move[i]] for i in range(n))\n        total_cost = cost1 + cost2 + cost3\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_move = move.copy()\n\n    new_solution = best_move\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 119,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance across objectives\n    edge_importance = np.zeros(n)\n    for i in range(n):\n        a, b = base_solution[i], base_solution[(i + 1) % n]\n        # Sum of normalized distances across objectives\n        total_dist = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n        edge_importance[i] = total_dist\n\n    # Select edges to swap based on importance and randomness\n    if n > 3:\n        # Sort edges by importance (descending) and select top 20% or at least 2 edges\n        k = max(2, int(0.2 * n))\n        important_edges = np.argsort(-edge_importance)[:k]\n        i, j = np.random.choice(important_edges, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Perform 2-opt swap\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6945270912490815,
            1.7653082251548766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance across objectives\n    edge_importance = np.zeros(n)\n    for i in range(n):\n        a, b = base_solution[i], base_solution[(i + 1) % n]\n        # Sum of normalized distances across objectives\n        total_dist = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n        edge_importance[i] = total_dist\n\n    # Select edges to swap based on importance and randomness\n    if n > 3:\n        # Sort edges by importance (descending) and select top 20% or at least 2 edges\n        k = max(2, int(0.2 * n))\n        important_edges = np.argsort(-edge_importance)[:k]\n        i, j = np.random.choice(important_edges, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Perform 2-opt swap\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 120,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with relatively high objective values)\n    candidates = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_solution = random.choice(candidates[:max(1, len(candidates) // 3)])[0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-weighted edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform multiple 2-opt moves with objective-aware edge selection\n    for _ in range(min(5, n // 2)):\n        # Calculate edge weights based on all three objectives\n        edge_weights = np.zeros(n)\n        for i in range(n):\n            node_a = new_solution[i]\n            node_b = new_solution[(i + 1) % n]\n            # Weighted sum of distances across all three objectives\n            edge_weights[i] = (distance_matrix_1[node_a, node_b] +\n                              distance_matrix_2[node_a, node_b] +\n                              distance_matrix_3[node_a, node_b])\n\n        # Select edges with highest weights (potential for improvement)\n        threshold = np.percentile(edge_weights, 75)\n        high_weight_edges = np.where(edge_weights >= threshold)[0]\n\n        if len(high_weight_edges) < 2:\n            continue\n\n        # Randomly select two edges to perform 2-opt\n        i, j = random.sample(list(high_weight_edges), 2)\n        if i > j:\n            i, j = j, i\n\n        # Perform 2-opt swap\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5514112109103777,
            4.076646614074707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with relatively high objective values)\n    candidates = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_solution = random.choice(candidates[:max(1, len(candidates) // 3)])[0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-weighted edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform multiple 2-opt moves with objective-aware edge selection\n    for _ in range(min(5, n // 2)):\n        # Calculate edge weights based on all three objectives\n        edge_weights = np.zeros(n)\n        for i in range(n):\n            node_a = new_solution[i]\n            node_b = new_solution[(i + 1) % n]\n            # Weighted sum of distances across all three objectives\n            edge_weights[i] = (distance_matrix_1[node_a, node_b] +\n                              distance_matrix_2[node_a, node_b] +\n                              distance_matrix_3[node_a, node_b])\n\n        # Select edges with highest weights (potential for improvement)\n        threshold = np.percentile(edge_weights, 75)\n        high_weight_edges = np.where(edge_weights >= threshold)[0]\n\n        if len(high_weight_edges) < 2:\n            continue\n\n        # Randomly select two edges to perform 2-opt\n        i, j = random.sample(list(high_weight_edges), 2)\n        if i > j:\n            i, j = j, i\n\n        # Perform 2-opt swap\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 121,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% of solutions based on combined objective values\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected = random.choice(top_solutions)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware selection\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the change in all three objectives\n        delta_1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                   distance_matrix_1[new_solution[i-1], new_solution[i+1]]) - \\\n                  (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[j], new_solution[i+1]])\n\n        delta_2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                   distance_matrix_2[new_solution[i-1], new_solution[i+1]]) - \\\n                  (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[j], new_solution[i+1]])\n\n        delta_3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                   distance_matrix_3[new_solution[i-1], new_solution[i+1]]) - \\\n                  (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_3[new_solution[j], new_solution[i+1]])\n\n        # Combine objectives with weights based on their current values\n        total_delta = (delta_1 / (selected[1][0] + 1e-6)) + \\\n                      (delta_2 / (selected[1][1] + 1e-6)) + \\\n                      (delta_3 / (selected[1][2] + 1e-6))\n\n        if total_delta < 0:  # Accept if improvement in at least one objective\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional objective-aware swaps\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                   distance_matrix_1[new_solution[j], new_solution[i+1]]) - \\\n                  (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[j], new_solution[i+1]])\n\n        delta_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[j], new_solution[i+1]]) - \\\n                  (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[j], new_solution[i+1]])\n\n        delta_3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                   distance_matrix_3[new_solution[j], new_solution[i+1]]) - \\\n                  (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_3[new_solution[j], new_solution[i+1]])\n\n        total_delta = (delta_1 / (selected[1][0] + 1e-6)) + \\\n                      (delta_2 / (selected[1][1] + 1e-6)) + \\\n                      (delta_3 / (selected[1][2] + 1e-6))\n\n        if total_delta < 0 or random.random() < 0.1:  # Accept with small probability for exploration\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7221387538965307,
            1.832263720035553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% of solutions based on combined objective values\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected = random.choice(top_solutions)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware selection\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the change in all three objectives\n        delta_1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                   distance_matrix_1[new_solution[i-1], new_solution[i+1]]) - \\\n                  (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[j], new_solution[i+1]])\n\n        delta_2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                   distance_matrix_2[new_solution[i-1], new_solution[i+1]]) - \\\n                  (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[j], new_solution[i+1]])\n\n        delta_3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                   distance_matrix_3[new_solution[i-1], new_solution[i+1]]) - \\\n                  (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_3[new_solution[j], new_solution[i+1]])\n\n        # Combine objectives with weights based on their current values\n        total_delta = (delta_1 / (selected[1][0] + 1e-6)) + \\\n                      (delta_2 / (selected[1][1] + 1e-6)) + \\\n                      (delta_3 / (selected[1][2] + 1e-6))\n\n        if total_delta < 0:  # Accept if improvement in at least one objective\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional objective-aware swaps\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                   distance_matrix_1[new_solution[j], new_solution[i+1]]) - \\\n                  (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_1[new_solution[j], new_solution[i+1]])\n\n        delta_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[j], new_solution[i+1]]) - \\\n                  (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_2[new_solution[j], new_solution[i+1]])\n\n        delta_3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                   distance_matrix_3[new_solution[j], new_solution[i+1]]) - \\\n                  (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                   distance_matrix_3[new_solution[j], new_solution[i+1]])\n\n        total_delta = (delta_1 / (selected[1][0] + 1e-6)) + \\\n                      (delta_2 / (selected[1][1] + 1e-6)) + \\\n                      (delta_3 / (selected[1][2] + 1e-6))\n\n        if total_delta < 0 or random.random() < 0.1:  # Accept with small probability for exploration\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 122,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    sorted_indices = np.argsort(avg_objectives)\n    selected_idx = sorted_indices[random.randint(0, min(2, len(sorted_indices)-1))]  # Select from top 3\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps based on which objectives are worse\n    current_obj = archive[selected_idx][1]\n    avg_obj = sum(current_obj)/3\n\n    # Identify which objectives are above average\n    above_avg = [i for i, obj in enumerate(current_obj) if obj > avg_obj]\n\n    if above_avg:\n        # For each above-average objective, find the worst edge in that space\n        worst_edge = -1\n        worst_obj = -1\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n\n            # Calculate edge cost in each space\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            cost3 = distance_matrix_3[u, v]\n\n            # Check if this edge is worse than average in any of the above-average objectives\n            for obj_idx in above_avg:\n                if obj_idx == 0 and cost1 > current_obj[0]/n:\n                    if cost1 > worst_obj:\n                        worst_obj = cost1\n                        worst_edge = i\n                elif obj_idx == 1 and cost2 > current_obj[1]/n:\n                    if cost2 > worst_obj:\n                        worst_obj = cost2\n                        worst_edge = i\n                elif obj_idx == 2 and cost3 > current_obj[2]/n:\n                    if cost3 > worst_obj:\n                        worst_obj = cost3\n                        worst_edge = i\n\n        if worst_edge != -1:\n            # Perform a swap that might improve the worst objective\n            i = worst_edge\n            j = (i + random.randint(1, n//2)) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7349195160244434,
            1.4490837812423707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest average objective)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    sorted_indices = np.argsort(avg_objectives)\n    selected_idx = sorted_indices[random.randint(0, min(2, len(sorted_indices)-1))]  # Select from top 3\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps based on which objectives are worse\n    current_obj = archive[selected_idx][1]\n    avg_obj = sum(current_obj)/3\n\n    # Identify which objectives are above average\n    above_avg = [i for i, obj in enumerate(current_obj) if obj > avg_obj]\n\n    if above_avg:\n        # For each above-average objective, find the worst edge in that space\n        worst_edge = -1\n        worst_obj = -1\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n\n            # Calculate edge cost in each space\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            cost3 = distance_matrix_3[u, v]\n\n            # Check if this edge is worse than average in any of the above-average objectives\n            for obj_idx in above_avg:\n                if obj_idx == 0 and cost1 > current_obj[0]/n:\n                    if cost1 > worst_obj:\n                        worst_obj = cost1\n                        worst_edge = i\n                elif obj_idx == 1 and cost2 > current_obj[1]/n:\n                    if cost2 > worst_obj:\n                        worst_obj = cost2\n                        worst_edge = i\n                elif obj_idx == 2 and cost3 > current_obj[2]/n:\n                    if cost3 > worst_obj:\n                        worst_obj = cost3\n                        worst_edge = i\n\n        if worst_edge != -1:\n            # Perform a swap that might improve the worst objective\n            i = worst_edge\n            j = (i + random.randint(1, n//2)) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 123,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that have not been heavily explored yet\n    # and those that show diversity in their objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, base_objectives = archive[selected_idx]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-way swap\n    # First, perform a standard 2-opt move\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform a 3-way swap to further diversify the solution\n    a, b, c = sorted(random.sample(range(n), 3))\n    new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure the solution remains feasible (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7768487766877865,
            0.9714664936065673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that have not been heavily explored yet\n    # and those that show diversity in their objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, base_objectives = archive[selected_idx]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-way swap\n    # First, perform a standard 2-opt move\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform a 3-way swap to further diversify the solution\n    a, b, c = sorted(random.sample(range(n), 3))\n    new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure the solution remains feasible (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 124,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search strategy: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Select edges based on their contribution to the worst objective\n        worst_obj = np.argmax([sum(selected_solution[1]) for selected_solution in archive])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the current solution for the selected objective\n        max_dist = -1\n        i, j = 0, 0\n        for k in range(n):\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            if dist_matrix[a, b] > max_dist:\n                max_dist = dist_matrix[a, b]\n                i, j = k, (k+1)%n\n\n        # Perform 2-opt swap\n        if i < j:\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n        else:\n            new_solution[i+1:] = new_solution[j::-1]\n            new_solution[:j+1] = new_solution[:j:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6484776346157676,
            3.667611825466156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search strategy: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Select edges based on their contribution to the worst objective\n        worst_obj = np.argmax([sum(selected_solution[1]) for selected_solution in archive])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the current solution for the selected objective\n        max_dist = -1\n        i, j = 0, 0\n        for k in range(n):\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            if dist_matrix[a, b] > max_dist:\n                max_dist = dist_matrix[a, b]\n                i, j = k, (k+1)%n\n\n        # Perform 2-opt swap\n        if i < j:\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n        else:\n            new_solution[i+1:] = new_solution[j::-1]\n            new_solution[:j+1] = new_solution[:j:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 125,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # First, perform a standard 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        # If first objective is worst, optimize it by finding the best swap in that space\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                delta = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # Similar for second objective\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                delta = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # For third objective\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                delta = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8289964859883672,
            2.578814148902893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # First, perform a standard 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        # If first objective is worst, optimize it by finding the best swap in that space\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                delta = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # Similar for second objective\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                delta = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # For third objective\n        best_improvement = 0\n        best_swap = None\n        for a in range(n):\n            for b in range(a+1, n):\n                delta = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n        if best_swap:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 126,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    # We prioritize solutions with the largest objective values (worst solutions)\n    # This is a heuristic to focus on solutions that can be improved the most\n    objectives = [obj for _, obj in archive]\n    objectives = np.array(objectives)\n    max_indices = np.argmax(objectives, axis=0)  # Find worst for each objective\n    selected_index = np.random.choice(max_indices)  # Randomly pick one of the worst solutions\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. First, perform a 2-opt move (standard for TSP)\n    # 2. Then, perform a swap between the two worst objectives\n    # 3. Finally, perform a random 2-opt move to introduce diversity\n\n    # Step 1: 2-opt move\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Swap between the two worst objectives\n    # Calculate the contribution of each node to each objective\n    contributions = np.zeros((n, 3))\n    for k in range(n-1):\n        contributions[k, 0] += distance_matrix_1[new_solution[k], new_solution[k+1]]\n        contributions[k+1, 0] += distance_matrix_1[new_solution[k], new_solution[k+1]]\n        contributions[k, 1] += distance_matrix_2[new_solution[k], new_solution[k+1]]\n        contributions[k+1, 1] += distance_matrix_2[new_solution[k], new_solution[k+1]]\n        contributions[k, 2] += distance_matrix_3[new_solution[k], new_solution[k+1]]\n        contributions[k+1, 2] += distance_matrix_3[new_solution[k], new_solution[k+1]]\n    contributions[-1, 0] += distance_matrix_1[new_solution[-1], new_solution[0]]\n    contributions[0, 0] += distance_matrix_1[new_solution[-1], new_solution[0]]\n    contributions[-1, 1] += distance_matrix_2[new_solution[-1], new_solution[0]]\n    contributions[0, 1] += distance_matrix_2[new_solution[-1], new_solution[0]]\n    contributions[-1, 2] += distance_matrix_3[new_solution[-1], new_solution[0]]\n    contributions[0, 2] += distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    # Find the two objectives with the highest total contributions\n    total_contributions = np.sum(contributions, axis=0)\n    worst_objectives = np.argsort(total_contributions)[-2:]\n\n    # Find nodes with the highest contribution to these two worst objectives\n    worst_nodes = np.argsort(np.sum(contributions[:, worst_objectives], axis=1))[-2:]\n\n    # Swap these two nodes\n    new_solution[worst_nodes[0]], new_solution[worst_nodes[1]] = new_solution[worst_nodes[1]], new_solution[worst_nodes[0]]\n\n    # Step 3: Random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7899069108307748,
            2.3257585883140566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    # We prioritize solutions with the largest objective values (worst solutions)\n    # This is a heuristic to focus on solutions that can be improved the most\n    objectives = [obj for _, obj in archive]\n    objectives = np.array(objectives)\n    max_indices = np.argmax(objectives, axis=0)  # Find worst for each objective\n    selected_index = np.random.choice(max_indices)  # Randomly pick one of the worst solutions\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. First, perform a 2-opt move (standard for TSP)\n    # 2. Then, perform a swap between the two worst objectives\n    # 3. Finally, perform a random 2-opt move to introduce diversity\n\n    # Step 1: 2-opt move\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Swap between the two worst objectives\n    # Calculate the contribution of each node to each objective\n    contributions = np.zeros((n, 3))\n    for k in range(n-1):\n        contributions[k, 0] += distance_matrix_1[new_solution[k], new_solution[k+1]]\n        contributions[k+1, 0] += distance_matrix_1[new_solution[k], new_solution[k+1]]\n        contributions[k, 1] += distance_matrix_2[new_solution[k], new_solution[k+1]]\n        contributions[k+1, 1] += distance_matrix_2[new_solution[k], new_solution[k+1]]\n        contributions[k, 2] += distance_matrix_3[new_solution[k], new_solution[k+1]]\n        contributions[k+1, 2] += distance_matrix_3[new_solution[k], new_solution[k+1]]\n    contributions[-1, 0] += distance_matrix_1[new_solution[-1], new_solution[0]]\n    contributions[0, 0] += distance_matrix_1[new_solution[-1], new_solution[0]]\n    contributions[-1, 1] += distance_matrix_2[new_solution[-1], new_solution[0]]\n    contributions[0, 1] += distance_matrix_2[new_solution[-1], new_solution[0]]\n    contributions[-1, 2] += distance_matrix_3[new_solution[-1], new_solution[0]]\n    contributions[0, 2] += distance_matrix_3[new_solution[-1], new_solution[0]]\n\n    # Find the two objectives with the highest total contributions\n    total_contributions = np.sum(contributions, axis=0)\n    worst_objectives = np.argsort(total_contributions)[-2:]\n\n    # Find nodes with the highest contribution to these two worst objectives\n    worst_nodes = np.argsort(np.sum(contributions[:, worst_objectives], axis=1))[-2:]\n\n    # Swap these two nodes\n    new_solution[worst_nodes[0]], new_solution[worst_nodes[1]] = new_solution[worst_nodes[1]], new_solution[worst_nodes[0]]\n\n    # Step 3: Random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 127,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not already optimal in all objectives)\n    candidates = []\n    for sol, obj in archive:\n        # Check if the solution is not already optimal in all objectives\n        # (This is a placeholder; adjust based on your criteria)\n        if not all(o == 0 for o in obj):  # Assuming 0 is the optimal value\n            candidates.append((sol, obj))\n\n    if not candidates:\n        # If no candidates found, select randomly\n        sol, _ = random.choice(archive)\n    else:\n        # Select a candidate with high potential (e.g., one with the worst objective)\n        # Here, we select the solution with the highest sum of objectives\n        sol, _ = max(candidates, key=lambda x: sum(x[1]))\n\n    new_solution = sol.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment of the tour\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2. Apply a 2-opt move to the selected segment\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 3. Optionally, apply a move that considers all three objectives\n    # For example, swap nodes that are far in at least one objective space\n    if n > 2:\n        k, l = random.sample(range(n), 2)\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate the distances in all three spaces\n        dist1 = distance_matrix_1[node_k, node_l]\n        dist2 = distance_matrix_2[node_k, node_l]\n        dist3 = distance_matrix_3[node_k, node_l]\n\n        # If the nodes are far in at least one space, swap them\n        if any(d > np.mean(dm) for d, dm in zip([dist1, dist2, dist3], [distance_matrix_1, distance_matrix_2, distance_matrix_3])):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.5594009061806828,
            1.112877881526947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not already optimal in all objectives)\n    candidates = []\n    for sol, obj in archive:\n        # Check if the solution is not already optimal in all objectives\n        # (This is a placeholder; adjust based on your criteria)\n        if not all(o == 0 for o in obj):  # Assuming 0 is the optimal value\n            candidates.append((sol, obj))\n\n    if not candidates:\n        # If no candidates found, select randomly\n        sol, _ = random.choice(archive)\n    else:\n        # Select a candidate with high potential (e.g., one with the worst objective)\n        # Here, we select the solution with the highest sum of objectives\n        sol, _ = max(candidates, key=lambda x: sum(x[1]))\n\n    new_solution = sol.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment of the tour\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2. Apply a 2-opt move to the selected segment\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 3. Optionally, apply a move that considers all three objectives\n    # For example, swap nodes that are far in at least one objective space\n    if n > 2:\n        k, l = random.sample(range(n), 2)\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate the distances in all three spaces\n        dist1 = distance_matrix_1[node_k, node_l]\n        dist2 = distance_matrix_2[node_k, node_l]\n        dist3 = distance_matrix_3[node_k, node_l]\n\n        # If the nodes are far in at least one space, swap them\n        if any(d > np.mean(dm) for d, dm in zip([dist1, dist2, dist3], [distance_matrix_1, distance_matrix_2, distance_matrix_3])):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 128,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        probs = [1.0 / len(archive) for _ in archive]\n    else:\n        probs = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion local search\n        if n > 2:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(sorted(unique_nodes), sorted(base_solution)):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8096443195753871,
            2.0399303793907166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        probs = [1.0 / len(archive) for _ in archive]\n    else:\n        probs = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion local search\n        if n > 2:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(sorted(unique_nodes), sorted(base_solution)):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 129,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their worst objective (to find those with room for improvement)\n        sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n        # Select from the top 30% of solutions with the worst objectives\n        candidate_indices = random.sample(range(len(sorted_archive) // 3, len(sorted_archive)), min(3, len(sorted_archive) - len(sorted_archive) // 3))\n        base_solution = sorted_archive[random.choice(candidate_indices)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select two distinct segments\n        i, j = sorted(random.sample(range(n - 1), 2))\n        k, l = sorted(random.sample(range(n - 1), 2))\n\n        # Perform 2-opt swap on one segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform objective-aware swap on another segment\n        if k != i and l != j:\n            # Calculate the improvement potential for each objective\n            obj1_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n            obj1_after = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n            obj2_before = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n            obj2_after = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n            obj3_before = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            obj3_after = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]\n\n            # If at least one objective improves, perform the swap\n            if (obj1_after < obj1_before) or (obj2_after < obj2_before) or (obj3_after < obj3_before):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7153809021691717,
            1.4500405430793761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their worst objective (to find those with room for improvement)\n        sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n        # Select from the top 30% of solutions with the worst objectives\n        candidate_indices = random.sample(range(len(sorted_archive) // 3, len(sorted_archive)), min(3, len(sorted_archive) - len(sorted_archive) // 3))\n        base_solution = sorted_archive[random.choice(candidate_indices)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select two distinct segments\n        i, j = sorted(random.sample(range(n - 1), 2))\n        k, l = sorted(random.sample(range(n - 1), 2))\n\n        # Perform 2-opt swap on one segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform objective-aware swap on another segment\n        if k != i and l != j:\n            # Calculate the improvement potential for each objective\n            obj1_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n            obj1_after = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n            obj2_before = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n            obj2_after = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n            obj3_before = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            obj3_after = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]\n\n            # If at least one objective improves, perform the swap\n            if (obj1_after < obj1_before) or (obj2_after < obj2_before) or (obj3_after < obj3_before):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 130,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution (simplified for 3 objectives)\n        crowding_distances = []\n        objectives = [obj for (sol, obj) in archive]\n\n        for i in range(3):  # For each objective\n            sorted_indices = np.argsort([obj[i] for obj in objectives])\n            min_val = objectives[sorted_indices[0]][i]\n            max_val = objectives[sorted_indices[-1]][i]\n            if max_val == min_val:\n                crowding_distances.append([0.0] * len(archive))\n            else:\n                crowding = [(objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / (max_val - min_val) if j != 0 and j != len(sorted_indices)-1 else float('inf') for j in sorted_indices]\n                crowding_distances.append(crowding)\n\n        # Combine crowding distances across objectives\n        combined_crowding = [sum(distances) for distances in zip(*crowding_distances)]\n        selected_index = np.argmax(combined_crowding)\n        base_solution = archive[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with random segment inversion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt or segment inversion\n    if np.random.rand() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion: randomly select a segment and reverse it\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5336326033258856,
            2.6652430176734923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution (simplified for 3 objectives)\n        crowding_distances = []\n        objectives = [obj for (sol, obj) in archive]\n\n        for i in range(3):  # For each objective\n            sorted_indices = np.argsort([obj[i] for obj in objectives])\n            min_val = objectives[sorted_indices[0]][i]\n            max_val = objectives[sorted_indices[-1]][i]\n            if max_val == min_val:\n                crowding_distances.append([0.0] * len(archive))\n            else:\n                crowding = [(objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / (max_val - min_val) if j != 0 and j != len(sorted_indices)-1 else float('inf') for j in sorted_indices]\n                crowding_distances.append(crowding)\n\n        # Combine crowding distances across objectives\n        combined_crowding = [sum(distances) for distances in zip(*crowding_distances)]\n        selected_index = np.argmax(combined_crowding)\n        base_solution = archive[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with random segment inversion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt or segment inversion\n    if np.random.rand() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion: randomly select a segment and reverse it\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 131,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by a combined metric of improvement potential (e.g., sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    operator = random.choice(['2opt', 'swap', 'insert', 'reverse'])\n\n    if operator == '2opt':\n        # 2-opt local search\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator == 'swap':\n        # Swap two nodes\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif operator == 'insert':\n        # Insert a node at a different position\n        i, j = random.sample(range(len(new_solution)), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n    elif operator == 'reverse':\n        # Reverse a segment\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7093636451022544,
            1.4102504968643188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by a combined metric of improvement potential (e.g., sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    operator = random.choice(['2opt', 'swap', 'insert', 'reverse'])\n\n    if operator == '2opt':\n        # 2-opt local search\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator == 'swap':\n        # Swap two nodes\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif operator == 'insert':\n        # Insert a node at a different position\n        i, j = random.sample(range(len(new_solution)), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n    elif operator == 'reverse':\n        # Reverse a segment\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 132,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest crowding distance in the objective space\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0 for _ in solutions]\n\n        # Extract objectives\n        objectives = [obj for _, obj in solutions]\n        obj1 = [o[0] for o in objectives]\n        obj2 = [o[1] for o in objectives]\n        obj3 = [o[2] for o in objectives]\n\n        # Normalize objectives\n        min_obj1, max_obj1 = min(obj1), max(obj1)\n        min_obj2, max_obj2 = min(obj2), max(obj2)\n        min_obj3, max_obj3 = min(obj3), max(obj3)\n\n        normalized_obj1 = [(o - min_obj1) / (max_obj1 - min_obj1 + 1e-10) for o in obj1]\n        normalized_obj2 = [(o - min_obj2) / (max_obj2 - min_obj2 + 1e-10) for o in obj2]\n        normalized_obj3 = [(o - min_obj3) / (max_obj3 - min_obj3 + 1e-10) for o in obj3]\n\n        # Calculate crowding distance\n        crowding_dist = [0.0] * len(solutions)\n        for i in range(len(solutions)):\n            if i == 0 or i == len(solutions) - 1:\n                crowding_dist[i] = float('inf')\n            else:\n                crowding_dist[i] = (normalized_obj1[i+1] - normalized_obj1[i-1]) + \\\n                                 (normalized_obj2[i+1] - normalized_obj2[i-1]) + \\\n                                 (normalized_obj3[i+1] - normalized_obj3[i-1])\n\n        return crowding_dist\n\n    crowding_distances = crowding_distance(archive)\n    max_crowding = max(crowding_distances)\n    candidates = [sol for sol, dist in zip(archive, crowding_distances) if dist == max_crowding]\n    selected_solution, _ = random.choice(candidates)\n\n    # Perform hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 1. Apply 2-opt local search on the objective with the highest variance\n    def calculate_variance(distance_matrix):\n        total = 0\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                total += distance_matrix[new_solution[i], new_solution[j]]\n                count += 1\n        return total / count if count > 0 else 0\n\n    var1 = calculate_variance(distance_matrix_1)\n    var2 = calculate_variance(distance_matrix_2)\n    var3 = calculate_variance(distance_matrix_3)\n\n    if var1 >= var2 and var1 >= var3:\n        # Perform 2-opt on first objective\n        for _ in range(10):  # Limit iterations to prevent excessive computation\n            i, j = sorted(random.sample(range(n), 2))\n            if i == j:\n                continue\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif var2 >= var1 and var2 >= var3:\n        # Perform 2-opt on second objective\n        for _ in range(10):\n            i, j = sorted(random.sample(range(n), 2))\n            if i == j:\n                continue\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform 2-opt on third objective\n        for _ in range(10):\n            i, j = sorted(random.sample(range(n), 2))\n            if i == j:\n                continue\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply OR-opt to improve solution further\n    for _ in range(5):\n        i, j, k = random.sample(range(n), 3)\n        if i == j or i == k or j == k:\n            continue\n        i, j, k = sorted([i, j, k])\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6664038009395448,
            2.8849302887916566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest crowding distance in the objective space\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0 for _ in solutions]\n\n        # Extract objectives\n        objectives = [obj for _, obj in solutions]\n        obj1 = [o[0] for o in objectives]\n        obj2 = [o[1] for o in objectives]\n        obj3 = [o[2] for o in objectives]\n\n        # Normalize objectives\n        min_obj1, max_obj1 = min(obj1), max(obj1)\n        min_obj2, max_obj2 = min(obj2), max(obj2)\n        min_obj3, max_obj3 = min(obj3), max(obj3)\n\n        normalized_obj1 = [(o - min_obj1) / (max_obj1 - min_obj1 + 1e-10) for o in obj1]\n        normalized_obj2 = [(o - min_obj2) / (max_obj2 - min_obj2 + 1e-10) for o in obj2]\n        normalized_obj3 = [(o - min_obj3) / (max_obj3 - min_obj3 + 1e-10) for o in obj3]\n\n        # Calculate crowding distance\n        crowding_dist = [0.0] * len(solutions)\n        for i in range(len(solutions)):\n            if i == 0 or i == len(solutions) - 1:\n                crowding_dist[i] = float('inf')\n            else:\n                crowding_dist[i] = (normalized_obj1[i+1] - normalized_obj1[i-1]) + \\\n                                 (normalized_obj2[i+1] - normalized_obj2[i-1]) + \\\n                                 (normalized_obj3[i+1] - normalized_obj3[i-1])\n\n        return crowding_dist\n\n    crowding_distances = crowding_distance(archive)\n    max_crowding = max(crowding_distances)\n    candidates = [sol for sol, dist in zip(archive, crowding_distances) if dist == max_crowding]\n    selected_solution, _ = random.choice(candidates)\n\n    # Perform hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 1. Apply 2-opt local search on the objective with the highest variance\n    def calculate_variance(distance_matrix):\n        total = 0\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                total += distance_matrix[new_solution[i], new_solution[j]]\n                count += 1\n        return total / count if count > 0 else 0\n\n    var1 = calculate_variance(distance_matrix_1)\n    var2 = calculate_variance(distance_matrix_2)\n    var3 = calculate_variance(distance_matrix_3)\n\n    if var1 >= var2 and var1 >= var3:\n        # Perform 2-opt on first objective\n        for _ in range(10):  # Limit iterations to prevent excessive computation\n            i, j = sorted(random.sample(range(n), 2))\n            if i == j:\n                continue\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif var2 >= var1 and var2 >= var3:\n        # Perform 2-opt on second objective\n        for _ in range(10):\n            i, j = sorted(random.sample(range(n), 2))\n            if i == j:\n                continue\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform 2-opt on third objective\n        for _ in range(10):\n            i, j = sorted(random.sample(range(n), 2))\n            if i == j:\n                continue\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply OR-opt to improve solution further\n    for _ in range(5):\n        i, j, k = random.sample(range(n), 3)\n        if i == j or i == k or j == k:\n            continue\n        i, j, k = sorted([i, j, k])\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 133,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        top_k = max(1, len(archive) // 3)\n        selected_idx = np.random.choice(top_k)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective edge swapping\n    for _ in range(10):  # Perform multiple iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[j]]\n        )\n\n        # Check if the swap improves at least one objective without worsening others too much\n        if (new_costs[0] <= current_costs[0] and new_costs[1] <= current_costs[1] and new_costs[2] <= current_costs[2]) or \\\n           (sum(new_costs) < sum(current_costs)):\n            # Perform the swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7989538819520131,
            2.7093592524528503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        top_k = max(1, len(archive) // 3)\n        selected_idx = np.random.choice(top_k)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective edge swapping\n    for _ in range(10):  # Perform multiple iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[j]]\n        )\n\n        # Check if the swap improves at least one objective without worsening others too much\n        if (new_costs[0] <= current_costs[0] and new_costs[1] <= current_costs[1] and new_costs[2] <= current_costs[2]) or \\\n           (sum(new_costs) < sum(current_costs)):\n            # Perform the swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to balance all three objectives\n    # Find the most \"unbalanced\" segment based on objective differences\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    obj_diffs = [abs(obj1 - obj2), abs(obj1 - obj3), abs(obj2 - obj3)]\n    max_diff_idx = np.argmax(obj_diffs)\n\n    # Swap nodes to balance the most unbalanced objective\n    if max_diff_idx == 0:  # obj1 and obj2 are most unbalanced\n        # Find nodes where swapping would reduce the difference\n        for _ in range(10):  # Try a few random swaps\n            a, b = random.sample(range(n), 2)\n            original_diff = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]]) - \\\n                           (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[a]])\n            new_diff = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]]) - \\\n                       (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n            if abs(original_diff) > abs(new_diff):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    elif max_diff_idx == 1:  # obj1 and obj3 are most unbalanced\n        # Similar logic to above but for obj1 and obj3\n        for _ in range(10):\n            a, b = random.sample(range(n), 2)\n            original_diff = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]]) - \\\n                           (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[a]])\n            new_diff = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[b]]) - \\\n                       (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[a]])\n            if abs(original_diff) > abs(new_diff):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    else:  # obj2 and obj3 are most unbalanced\n        # Similar logic to above but for obj2 and obj3\n        for _ in range(10):\n            a, b = random.sample(range(n), 2)\n            original_diff = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[b]]) - \\\n                           (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[a]])\n            new_diff = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[b]]) - \\\n                       (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[a]])\n            if abs(original_diff) > abs(new_diff):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.82558797863268,
            1.5134012699127197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to balance all three objectives\n    # Find the most \"unbalanced\" segment based on objective differences\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    obj_diffs = [abs(obj1 - obj2), abs(obj1 - obj3), abs(obj2 - obj3)]\n    max_diff_idx = np.argmax(obj_diffs)\n\n    # Swap nodes to balance the most unbalanced objective\n    if max_diff_idx == 0:  # obj1 and obj2 are most unbalanced\n        # Find nodes where swapping would reduce the difference\n        for _ in range(10):  # Try a few random swaps\n            a, b = random.sample(range(n), 2)\n            original_diff = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]]) - \\\n                           (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[a]])\n            new_diff = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]]) - \\\n                       (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n            if abs(original_diff) > abs(new_diff):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    elif max_diff_idx == 1:  # obj1 and obj3 are most unbalanced\n        # Similar logic to above but for obj1 and obj3\n        for _ in range(10):\n            a, b = random.sample(range(n), 2)\n            original_diff = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]]) - \\\n                           (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[a]])\n            new_diff = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[b]]) - \\\n                       (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[a]])\n            if abs(original_diff) > abs(new_diff):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    else:  # obj2 and obj3 are most unbalanced\n        # Similar logic to above but for obj2 and obj3\n        for _ in range(10):\n            a, b = random.sample(range(n), 2)\n            original_diff = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[b]]) - \\\n                           (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[a]])\n            new_diff = (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[b]]) - \\\n                       (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[a]])\n            if abs(original_diff) > abs(new_diff):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 135,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate a score for each solution based on its objective values (lower is better)\n        scores = [sum(obj) for _, obj in archive]\n        min_score = min(scores)\n        max_score = max(scores)\n        # Normalize scores to [0, 1] and invert to prioritize lower scores\n        normalized_scores = [(max_score - s) / (max_score - min_score + 1e-10) for s in scores]\n        # Select a solution with probability proportional to its normalized score\n        selected_idx = random.choices(range(len(archive)), weights=normalized_scores, k=1)[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    if n <= 3:\n        # For small tours, just reverse the order\n        return new_solution[::-1]\n\n    # Randomly choose between 2-opt or edge exchange\n    if random.random() < 0.5:\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge exchange: swap two edges to create a different tour structure\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Ensure the exchange is feasible\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify the solution is still valid (no duplicates and all nodes are visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7000532077319849,
            1.3783490896224975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate a score for each solution based on its objective values (lower is better)\n        scores = [sum(obj) for _, obj in archive]\n        min_score = min(scores)\n        max_score = max(scores)\n        # Normalize scores to [0, 1] and invert to prioritize lower scores\n        normalized_scores = [(max_score - s) / (max_score - min_score + 1e-10) for s in scores]\n        # Select a solution with probability proportional to its normalized score\n        selected_idx = random.choices(range(len(archive)), weights=normalized_scores, k=1)[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    if n <= 3:\n        # For small tours, just reverse the order\n        return new_solution[::-1]\n\n    # Randomly choose between 2-opt or edge exchange\n    if random.random() < 0.5:\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge exchange: swap two edges to create a different tour structure\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Ensure the exchange is feasible\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify the solution is still valid (no duplicates and all nodes are visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 136,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objectives and select a middle-ranked one (avoiding extremes)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and swap moves\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly choose between 2-opt and swap\n    if np.random.rand() < 0.5:\n        # 2-opt move: select two random edges and reverse the path between them\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Swap move: select two random nodes and swap their positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7174335545693926,
            1.73888019323349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objectives and select a middle-ranked one (avoiding extremes)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and swap moves\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly choose between 2-opt and swap\n    if np.random.rand() < 0.5:\n        # 2-opt move: select two random edges and reverse the path between them\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Swap move: select two random nodes and swap their positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 137,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from typing import List\n    import numpy as np\n\n    # Select a promising solution with high diversity\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find those with diverse trade-offs\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list to ensure diversity\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small tours\n\n    # Calculate current total cost across all objectives\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    original_cost = calculate_total_cost(new_solution)\n\n    # Try 2-opt first\n    improved = False\n    for i in range(n):\n        for j in range(i+2, n):\n            # Try reversing the segment between i and j\n            candidate = new_solution.copy()\n            candidate[i:j] = candidate[i:j][::-1]\n            candidate_cost = calculate_total_cost(candidate)\n\n            # Accept if at least one objective improves\n            if any(candidate_cost[k] < original_cost[k] for k in range(3)):\n                new_solution = candidate\n                original_cost = candidate_cost\n                improved = True\n                break\n        if improved:\n            break\n\n    if not improved:\n        # Try 3-opt if 2-opt didn't improve\n        for i in range(n):\n            for j in range(i+2, n):\n                for k in range(j+2, n):\n                    # Try all possible 3-opt moves\n                    candidates = [\n                        new_solution.copy(),  # Original\n                        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),  # Reverse j to k\n                        np.concatenate([new_solution[:i], new_solution[k:], new_solution[i:j], new_solution[j:k]]),  # Rotate\n                        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[j:k], new_solution[i:j-1:-1]]),  # Complex 3-opt\n                        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])  # Another rotation\n                    ]\n\n                    for candidate in candidates[1:]:\n                        candidate_cost = calculate_total_cost(candidate)\n                        if any(candidate_cost[k] < original_cost[k] for k in range(3)):\n                            new_solution = candidate\n                            original_cost = candidate_cost\n                            improved = True\n                            break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.678427437387372,
            1.6636414170265197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from typing import List\n    import numpy as np\n\n    # Select a promising solution with high diversity\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find those with diverse trade-offs\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list to ensure diversity\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small tours\n\n    # Calculate current total cost across all objectives\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    original_cost = calculate_total_cost(new_solution)\n\n    # Try 2-opt first\n    improved = False\n    for i in range(n):\n        for j in range(i+2, n):\n            # Try reversing the segment between i and j\n            candidate = new_solution.copy()\n            candidate[i:j] = candidate[i:j][::-1]\n            candidate_cost = calculate_total_cost(candidate)\n\n            # Accept if at least one objective improves\n            if any(candidate_cost[k] < original_cost[k] for k in range(3)):\n                new_solution = candidate\n                original_cost = candidate_cost\n                improved = True\n                break\n        if improved:\n            break\n\n    if not improved:\n        # Try 3-opt if 2-opt didn't improve\n        for i in range(n):\n            for j in range(i+2, n):\n                for k in range(j+2, n):\n                    # Try all possible 3-opt moves\n                    candidates = [\n                        new_solution.copy(),  # Original\n                        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),  # Reverse j to k\n                        np.concatenate([new_solution[:i], new_solution[k:], new_solution[i:j], new_solution[j:k]]),  # Rotate\n                        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[j:k], new_solution[i:j-1:-1]]),  # Complex 3-opt\n                        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])  # Another rotation\n                    ]\n\n                    for candidate in candidates[1:]:\n                        candidate_cost = calculate_total_cost(candidate)\n                        if any(candidate_cost[k] < original_cost[k] for k in range(3)):\n                            new_solution = candidate\n                            original_cost = candidate_cost\n                            improved = True\n                            break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 138,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n_nodes = len(base_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n_nodes), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate the improvement potential for each objective\n    obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]] - \\\n                       (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]])\n    obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]] - \\\n                       (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]])\n    obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]] - \\\n                       (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]])\n\n    # If the move improves at least one objective, keep it; otherwise, revert\n    if obj1_improvement >= 0 and obj2_improvement >= 0 and obj3_improvement >= 0:\n        new_solution = base_solution.copy()\n\n    # Additionally, perform a random swap to explore the search space\n    if random.random() < 0.3:  # 30% chance for random swap\n        a, b = random.sample(range(n_nodes), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7541368694042655,
            1.777366304397583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n_nodes = len(base_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n_nodes), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate the improvement potential for each objective\n    obj1_improvement = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]] - \\\n                       (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]])\n    obj2_improvement = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]] - \\\n                       (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]])\n    obj3_improvement = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]] - \\\n                       (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]])\n\n    # If the move improves at least one objective, keep it; otherwise, revert\n    if obj1_improvement >= 0 and obj2_improvement >= 0 and obj3_improvement >= 0:\n        new_solution = base_solution.copy()\n\n    # Additionally, perform a random swap to explore the search space\n    if random.random() < 0.3:  # 30% chance for random swap\n        a, b = random.sample(range(n_nodes), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 139,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    ranks = np.argsort(objectives.sum(axis=1))  # Sum of objectives to get overall rank\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in ranks])[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt and random insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt to the objective with the highest current cost\n    obj_costs = objectives[selected_idx]\n    worst_obj_idx = np.argmax(obj_costs)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    worst_edge = None\n    max_cost = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        cost = dist_matrix[u, v]\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge = (i, (i+1)%n)\n\n    if worst_edge:\n        i, j = worst_edge\n        # Try to replace this edge with a better one using 2-opt\n        for k in range(i+1, n):\n            l = (k+1)%n\n            if l == i:\n                continue\n            # Check if swapping (i,k) and (j,l) improves the solution\n            original_cost = dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[k], new_solution[l]]\n            new_cost = dist_matrix[new_solution[i], new_solution[k]] + dist_matrix[new_solution[j], new_solution[l]]\n            if new_cost < original_cost:\n                # Perform the swap\n                new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n                break\n\n    # Random insertion to escape local optima\n    if random.random() < 0.3:  # 30% chance for random insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = min(j, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7207803086925676,
            2.533661186695099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    ranks = np.argsort(objectives.sum(axis=1))  # Sum of objectives to get overall rank\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in ranks])[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt and random insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt to the objective with the highest current cost\n    obj_costs = objectives[selected_idx]\n    worst_obj_idx = np.argmax(obj_costs)\n\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    worst_edge = None\n    max_cost = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        cost = dist_matrix[u, v]\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge = (i, (i+1)%n)\n\n    if worst_edge:\n        i, j = worst_edge\n        # Try to replace this edge with a better one using 2-opt\n        for k in range(i+1, n):\n            l = (k+1)%n\n            if l == i:\n                continue\n            # Check if swapping (i,k) and (j,l) improves the solution\n            original_cost = dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[k], new_solution[l]]\n            new_cost = dist_matrix[new_solution[i], new_solution[k]] + dist_matrix[new_solution[j], new_solution[l]]\n            if new_cost < original_cost:\n                # Perform the swap\n                new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n                break\n\n    # Random insertion to escape local optima\n    if random.random() < 0.3:  # 30% chance for random insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = min(j, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 140,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: combination of 2-opt and random segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Choose between 2-opt and random segment reversal based on a probability\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random segment reversal\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7458745856791296,
            0.8133497714996338
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: combination of 2-opt and random segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Choose between 2-opt and random segment reversal based on a probability\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random segment reversal\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 140,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: combination of 2-opt and random segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Choose between 2-opt and random segment reversal based on a probability\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random segment reversal\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7458745856791296,
            0.8133497714996338
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: combination of 2-opt and random segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Choose between 2-opt and random segment reversal based on a probability\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random segment reversal\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 141,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    segment_size = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start + segment_size]\n\n    # Apply a multi-objective aware perturbation\n    if random.random() < 0.5:\n        # Reverse the segment\n        new_solution[start:start + segment_size] = segment[::-1]\n    else:\n        # Swap segments between two objectives\n        obj1 = random.randint(0, 2)\n        obj2 = (obj1 + 1) % 3\n        if obj1 == 0:\n            dist_matrix = distance_matrix_1\n        elif obj1 == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the best swap within the segment\n        best_improvement = 0\n        best_swap = None\n        for i in range(len(segment)):\n            for j in range(i + 1, len(segment)):\n                # Calculate improvement for the swap\n                a, b = segment[i], segment[j]\n                original_cost = (dist_matrix[a, b] + dist_matrix[b, a]) if i != j - 1 else dist_matrix[a, b]\n                swapped_cost = (dist_matrix[b, a] + dist_matrix[a, b]) if i != j - 1 else dist_matrix[b, a]\n                improvement = original_cost - swapped_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            segment[i], segment[j] = segment[j], segment[i]\n            new_solution[start:start + segment_size] = segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6064135922072033,
            1.383021605014801
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    segment_size = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start + segment_size]\n\n    # Apply a multi-objective aware perturbation\n    if random.random() < 0.5:\n        # Reverse the segment\n        new_solution[start:start + segment_size] = segment[::-1]\n    else:\n        # Swap segments between two objectives\n        obj1 = random.randint(0, 2)\n        obj2 = (obj1 + 1) % 3\n        if obj1 == 0:\n            dist_matrix = distance_matrix_1\n        elif obj1 == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the best swap within the segment\n        best_improvement = 0\n        best_swap = None\n        for i in range(len(segment)):\n            for j in range(i + 1, len(segment)):\n                # Calculate improvement for the swap\n                a, b = segment[i], segment[j]\n                original_cost = (dist_matrix[a, b] + dist_matrix[b, a]) if i != j - 1 else dist_matrix[a, b]\n                swapped_cost = (dist_matrix[b, a] + dist_matrix[a, b]) if i != j - 1 else dist_matrix[b, a]\n                improvement = original_cost - swapped_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            segment[i], segment[j] = segment[j], segment[i]\n            new_solution[start:start + segment_size] = segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 142,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective perturbation\n    n_nodes = len(base_solution)\n    i, j = sorted(np.random.choice(n_nodes, size=2, replace=False))\n\n    # Apply 2-opt to improve the solution\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective perturbation: randomly swap segments based on objective dominance\n    if np.random.rand() < 0.3:  # 30% chance to apply perturbation\n        k, l = sorted(np.random.choice(n_nodes, size=2, replace=False))\n        # Determine which objective to prioritize for perturbation\n        objectives = selected[1]\n        if objectives[0] > objectives[1] and objectives[0] > objectives[2]:\n            # Perturb based on first objective\n            new_solution[k:l] = new_solution[k:l][::-1]\n        elif objectives[1] > objectives[0] and objectives[1] > objectives[2]:\n            # Perturb based on second objective\n            new_solution = np.roll(new_solution, shift=np.random.randint(1, n_nodes))\n        else:\n            # Perturb based on third objective\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n_nodes, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.6772885959548655,
            1.3910409092903138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective perturbation\n    n_nodes = len(base_solution)\n    i, j = sorted(np.random.choice(n_nodes, size=2, replace=False))\n\n    # Apply 2-opt to improve the solution\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective perturbation: randomly swap segments based on objective dominance\n    if np.random.rand() < 0.3:  # 30% chance to apply perturbation\n        k, l = sorted(np.random.choice(n_nodes, size=2, replace=False))\n        # Determine which objective to prioritize for perturbation\n        objectives = selected[1]\n        if objectives[0] > objectives[1] and objectives[0] > objectives[2]:\n            # Perturb based on first objective\n            new_solution[k:l] = new_solution[k:l][::-1]\n        elif objectives[1] > objectives[0] and objectives[1] > objectives[2]:\n            # Perturb based on second objective\n            new_solution = np.roll(new_solution, shift=np.random.randint(1, n_nodes))\n        else:\n            # Perturb based on third objective\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n_nodes, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 143,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of objectives (promising for improvement)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        new_solution[i:] = new_solution[i:][::-1]\n        new_solution[:j+1] = new_solution[:j+1][::-1]\n\n    # Perform edge exchange move\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7492690310048655,
            1.5416783928871154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of objectives (promising for improvement)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform 2-opt move\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        new_solution[i:] = new_solution[i:][::-1]\n        new_solution[:j+1] = new_solution[:j+1][::-1]\n\n    # Perform edge exchange move\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 144,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a weighted random choice based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    probabilities = diversity_scores / diversity_scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and 3-opt based on objective improvement potential\n        if np.random.random() < 0.7:  # Higher chance for 2-opt due to simplicity\n            # 2-opt with objective-aware edge selection\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            candidate_edges = [(i, j), (i, (i+1)%n), (j, (j+1)%n), ((i+1)%n, (j+1)%n)]\n            best_improvement = 0\n            best_edge = None\n\n            for edge in candidate_edges:\n                a, b = edge\n                # Calculate improvement across all three objectives\n                improvement = (\n                    (distance_matrix_1[new_solution[a], new_solution[b]] +\n                     distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]) -\n                    (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                ) + (\n                    (distance_matrix_2[new_solution[a], new_solution[b]] +\n                     distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]) -\n                    (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                ) + (\n                    (distance_matrix_3[new_solution[a], new_solution[b]] +\n                     distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]]) -\n                    (distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n                )\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_edge = edge\n\n            if best_edge:\n                a, b = best_edge\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # 3-opt with objective-aware segment selection\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segments = [\n                (i, j, k),\n                (i, k, j),\n                (j, i, k),\n                (j, k, i),\n                (k, i, j),\n                (k, j, i)\n            ]\n\n            best_improvement = 0\n            best_segment = None\n\n            for seg in segments:\n                a, b, c = seg\n                # Calculate improvement across all three objectives\n                improvement = (\n                    (distance_matrix_1[new_solution[a], new_solution[b]] +\n                     distance_matrix_1[new_solution[b], new_solution[c]] +\n                     distance_matrix_1[new_solution[c], new_solution[(a+1)%n]]) -\n                    (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                     distance_matrix_1[new_solution[c], new_solution[(c+1)%n]])\n                ) + (\n                    (distance_matrix_2[new_solution[a], new_solution[b]] +\n                     distance_matrix_2[new_solution[b], new_solution[c]] +\n                     distance_matrix_2[new_solution[c], new_solution[(a+1)%n]]) -\n                    (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                     distance_matrix_2[new_solution[c], new_solution[(c+1)%n]])\n                ) + (\n                    (distance_matrix_3[new_solution[a], new_solution[b]] +\n                     distance_matrix_3[new_solution[b], new_solution[c]] +\n                     distance_matrix_3[new_solution[c], new_solution[(a+1)%n]]) -\n                    (distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_3[new_solution[b], new_solution[(b+1)%n]] +\n                     distance_matrix_3[new_solution[c], new_solution[(c+1)%n]])\n                )\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_segment = seg\n\n            if best_segment:\n                a, b, c = best_segment\n                # Apply the best 3-opt move\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                new_solution[b:c+1] = new_solution[b:c+1][::-1]\n                new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7288139128389226,
            4.236707937717438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a weighted random choice based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    probabilities = diversity_scores / diversity_scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and 3-opt based on objective improvement potential\n        if np.random.random() < 0.7:  # Higher chance for 2-opt due to simplicity\n            # 2-opt with objective-aware edge selection\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            candidate_edges = [(i, j), (i, (i+1)%n), (j, (j+1)%n), ((i+1)%n, (j+1)%n)]\n            best_improvement = 0\n            best_edge = None\n\n            for edge in candidate_edges:\n                a, b = edge\n                # Calculate improvement across all three objectives\n                improvement = (\n                    (distance_matrix_1[new_solution[a], new_solution[b]] +\n                     distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]) -\n                    (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                ) + (\n                    (distance_matrix_2[new_solution[a], new_solution[b]] +\n                     distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]) -\n                    (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                ) + (\n                    (distance_matrix_3[new_solution[a], new_solution[b]] +\n                     distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]]) -\n                    (distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n                )\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_edge = edge\n\n            if best_edge:\n                a, b = best_edge\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # 3-opt with objective-aware segment selection\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segments = [\n                (i, j, k),\n                (i, k, j),\n                (j, i, k),\n                (j, k, i),\n                (k, i, j),\n                (k, j, i)\n            ]\n\n            best_improvement = 0\n            best_segment = None\n\n            for seg in segments:\n                a, b, c = seg\n                # Calculate improvement across all three objectives\n                improvement = (\n                    (distance_matrix_1[new_solution[a], new_solution[b]] +\n                     distance_matrix_1[new_solution[b], new_solution[c]] +\n                     distance_matrix_1[new_solution[c], new_solution[(a+1)%n]]) -\n                    (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                     distance_matrix_1[new_solution[c], new_solution[(c+1)%n]])\n                ) + (\n                    (distance_matrix_2[new_solution[a], new_solution[b]] +\n                     distance_matrix_2[new_solution[b], new_solution[c]] +\n                     distance_matrix_2[new_solution[c], new_solution[(a+1)%n]]) -\n                    (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                     distance_matrix_2[new_solution[c], new_solution[(c+1)%n]])\n                ) + (\n                    (distance_matrix_3[new_solution[a], new_solution[b]] +\n                     distance_matrix_3[new_solution[b], new_solution[c]] +\n                     distance_matrix_3[new_solution[c], new_solution[(a+1)%n]]) -\n                    (distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_3[new_solution[b], new_solution[(b+1)%n]] +\n                     distance_matrix_3[new_solution[c], new_solution[(c+1)%n]])\n                )\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_segment = seg\n\n            if best_segment:\n                a, b, c = best_segment\n                # Apply the best 3-opt move\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                new_solution[b:c+1] = new_solution[b:c+1][::-1]\n                new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 145,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their sum of objectives (prioritize those with higher total cost)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select from top 30% of solutions\n        candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        base_solution, _ = random.choice(candidate_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Randomly choose between 2-opt and edge insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion local search\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6290155787760937,
            1.732179594039917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their sum of objectives (prioritize those with higher total cost)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select from top 30% of solutions\n        candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        base_solution, _ = random.choice(candidate_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Randomly choose between 2-opt and edge insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion local search\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 146,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and 3-opt based on the most critical objective\n    critical_obj = np.argmax(objective_variance)\n\n    if critical_obj == 0:\n        # Use 2-opt optimized for distance_matrix_1\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif critical_obj == 1:\n        # Use 3-opt optimized for distance_matrix_2\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:\n        # Use a combination of operations optimized for distance_matrix_3\n        op = random.choice(['swap', 'insert'])\n        if op == 'swap':\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6932582243708099,
            1.886130678653717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and 3-opt based on the most critical objective\n    critical_obj = np.argmax(objective_variance)\n\n    if critical_obj == 0:\n        # Use 2-opt optimized for distance_matrix_1\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif critical_obj == 1:\n        # Use 3-opt optimized for distance_matrix_2\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:\n        # Use a combination of operations optimized for distance_matrix_3\n        op = random.choice(['swap', 'insert'])\n        if op == 'swap':\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 147,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    candidates = [sol for sol, obj in archive if any(o > 0 for o in obj)]\n    if not candidates:\n        candidates = [sol for sol, obj in archive]\n\n    # Intelligent random selection: prioritize solutions with higher objective values\n    weights = [sum(obj) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # First, perform a random 2-opt move\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Identify nodes with high contribution to objectives\n    obj_contributions = []\n    for i in range(n):\n        prev = base_solution[i-1]\n        curr = base_solution[i]\n        next_node = base_solution[(i+1) % n]\n\n        # Calculate contribution to each objective\n        contrib = (\n            distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node],\n            distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node],\n            distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n        )\n        obj_contributions.append(contrib)\n\n    # Find nodes with highest combined contribution\n    total_contribs = [sum(c) for c in obj_contributions]\n    high_contrib_nodes = sorted(range(n), key=lambda x: total_contribs[x], reverse=True)[:2]\n\n    if len(high_contrib_nodes) >= 2:\n        i, j = high_contrib_nodes[0], high_contrib_nodes[1]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8269850681953617,
            1.2253808379173279
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    candidates = [sol for sol, obj in archive if any(o > 0 for o in obj)]\n    if not candidates:\n        candidates = [sol for sol, obj in archive]\n\n    # Intelligent random selection: prioritize solutions with higher objective values\n    weights = [sum(obj) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # First, perform a random 2-opt move\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Identify nodes with high contribution to objectives\n    obj_contributions = []\n    for i in range(n):\n        prev = base_solution[i-1]\n        curr = base_solution[i]\n        next_node = base_solution[(i+1) % n]\n\n        # Calculate contribution to each objective\n        contrib = (\n            distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node],\n            distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node],\n            distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n        )\n        obj_contributions.append(contrib)\n\n    # Find nodes with highest combined contribution\n    total_contribs = [sum(c) for c in obj_contributions]\n    high_contrib_nodes = sorted(range(n), key=lambda x: total_contribs[x], reverse=True)[:2]\n\n    if len(high_contrib_nodes) >= 2:\n        i, j = high_contrib_nodes[0], high_contrib_nodes[1]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 148,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score for each solution (lower is better)\n    scores = [sum(obj) for obj in archive_objectives]\n    best_idx = np.argmin(scores)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve the worst-performing objective\n    obj_scores = archive_objectives[best_idx]\n    worst_obj = np.argmax(obj_scores)  # identify the worst-performing objective\n\n    # Choose the distance matrix based on the worst objective\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best swap to improve the worst objective\n    best_improvement = 0\n    best_swap = (0, 0)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate current and new distances for the worst objective\n            current_dist = (distance_matrix[new_solution[i-1], new_solution[i]] +\n                           distance_matrix[new_solution[j-1], new_solution[j]])\n            new_dist = (distance_matrix[new_solution[i-1], new_solution[j]] +\n                        distance_matrix[new_solution[j-1], new_solution[i]])\n\n            improvement = current_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n    if best_improvement > 0:\n        i, j = best_swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7874732915762714,
            2.8375707626342774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score for each solution (lower is better)\n    scores = [sum(obj) for obj in archive_objectives]\n    best_idx = np.argmin(scores)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve the worst-performing objective\n    obj_scores = archive_objectives[best_idx]\n    worst_obj = np.argmax(obj_scores)  # identify the worst-performing objective\n\n    # Choose the distance matrix based on the worst objective\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best swap to improve the worst objective\n    best_improvement = 0\n    best_swap = (0, 0)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate current and new distances for the worst objective\n            current_dist = (distance_matrix[new_solution[i-1], new_solution[i]] +\n                           distance_matrix[new_solution[j-1], new_solution[j]])\n            new_dist = (distance_matrix[new_solution[i-1], new_solution[j]] +\n                        distance_matrix[new_solution[j-1], new_solution[i]])\n\n            improvement = current_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n    if best_improvement > 0:\n        i, j = best_swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 149,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap based on their contribution to the objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate the change in all three objectives\n    def calculate_delta(solution, i, j):\n        a, b = solution[i-1], solution[i]\n        c, d = solution[j], solution[(j+1)%n]\n\n        # Current edges: (a-b) and (c-d)\n        # New edges: (a-c) and (b-d)\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d] -\n                 (distance_matrix_1[a, b] + distance_matrix_1[c, d]))\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d] -\n                 (distance_matrix_2[a, b] + distance_matrix_2[c, d]))\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d] -\n                 (distance_matrix_3[a, b] + distance_matrix_3[c, d]))\n        return (delta1, delta2, delta3)\n\n    delta = calculate_delta(new_solution, i, j)\n\n    # Accept the move if it improves at least one objective (non-dominated improvement)\n    if any(d < 0 for d in delta):\n        # Perform the 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional: Try a 3-opt move if the 2-opt didn't improve any objective\n    if all(d >= 0 for d in delta):\n        k = np.random.randint(0, n)\n        while k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n            k = np.random.randint(0, n)\n\n        # Select three edges to swap (3-opt)\n        def calculate_3opt_delta(solution, i, j, k):\n            # Implementation of 3-opt delta calculation\n            # This is a simplified version - a full implementation would be more complex\n            a, b = solution[i-1], solution[i]\n            c, d = solution[j], solution[(j+1)%n]\n            e, f = solution[k], solution[(k+1)%n]\n\n            # Possible 3-opt moves (there are 8 possible configurations)\n            # Here we just try one configuration for simplicity\n            delta1 = (distance_matrix_1[a, e] + distance_matrix_1[b, f] +\n                     distance_matrix_1[c, d] - distance_matrix_1[a, b] -\n                     distance_matrix_1[e, f] - distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, e] + distance_matrix_2[b, f] +\n                     distance_matrix_2[c, d] - distance_matrix_2[a, b] -\n                     distance_matrix_2[e, f] - distance_matrix_2[c, d])\n            delta3 = (distance_matrix_3[a, e] + distance_matrix_3[b, f] +\n                     distance_matrix_3[c, d] - distance_matrix_3[a, b] -\n                     distance_matrix_3[e, f] - distance_matrix_3[c, d])\n            return (delta1, delta2, delta3)\n\n        delta_3opt = calculate_3opt_delta(new_solution, i, j, k)\n        if any(d < 0 for d in delta_3opt):\n            # Perform the 3-opt move (simplified - actual implementation would need to handle all 8 cases)\n            # This is a placeholder for the actual 3-opt implementation\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7463914182367462,
            4.017775905132294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap based on their contribution to the objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate the change in all three objectives\n    def calculate_delta(solution, i, j):\n        a, b = solution[i-1], solution[i]\n        c, d = solution[j], solution[(j+1)%n]\n\n        # Current edges: (a-b) and (c-d)\n        # New edges: (a-c) and (b-d)\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d] -\n                 (distance_matrix_1[a, b] + distance_matrix_1[c, d]))\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d] -\n                 (distance_matrix_2[a, b] + distance_matrix_2[c, d]))\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d] -\n                 (distance_matrix_3[a, b] + distance_matrix_3[c, d]))\n        return (delta1, delta2, delta3)\n\n    delta = calculate_delta(new_solution, i, j)\n\n    # Accept the move if it improves at least one objective (non-dominated improvement)\n    if any(d < 0 for d in delta):\n        # Perform the 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional: Try a 3-opt move if the 2-opt didn't improve any objective\n    if all(d >= 0 for d in delta):\n        k = np.random.randint(0, n)\n        while k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n            k = np.random.randint(0, n)\n\n        # Select three edges to swap (3-opt)\n        def calculate_3opt_delta(solution, i, j, k):\n            # Implementation of 3-opt delta calculation\n            # This is a simplified version - a full implementation would be more complex\n            a, b = solution[i-1], solution[i]\n            c, d = solution[j], solution[(j+1)%n]\n            e, f = solution[k], solution[(k+1)%n]\n\n            # Possible 3-opt moves (there are 8 possible configurations)\n            # Here we just try one configuration for simplicity\n            delta1 = (distance_matrix_1[a, e] + distance_matrix_1[b, f] +\n                     distance_matrix_1[c, d] - distance_matrix_1[a, b] -\n                     distance_matrix_1[e, f] - distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, e] + distance_matrix_2[b, f] +\n                     distance_matrix_2[c, d] - distance_matrix_2[a, b] -\n                     distance_matrix_2[e, f] - distance_matrix_2[c, d])\n            delta3 = (distance_matrix_3[a, e] + distance_matrix_3[b, f] +\n                     distance_matrix_3[c, d] - distance_matrix_3[a, b] -\n                     distance_matrix_3[e, f] - distance_matrix_3[c, d])\n            return (delta1, delta2, delta3)\n\n        delta_3opt = calculate_3opt_delta(new_solution, i, j, k)\n        if any(d < 0 for d in delta_3opt):\n            # Perform the 3-opt move (simplified - actual implementation would need to handle all 8 cases)\n            # This is a placeholder for the actual 3-opt implementation\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 150,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity (variation in objective values)\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        # Select solutions with high diversity in at least one objective\n        candidates = [i for i, (sol, obj) in enumerate(archive) if any(d > np.mean(diversity) for d in diversity)]\n        if candidates:\n            selected_idx = random.choice(candidates)\n            base_solution = archive[selected_idx][0].copy()\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n            base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and insertion with probability 0.7 and 0.3 respectively\n        if random.random() < 0.7:\n            # 2-opt move: select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Insertion move: select a node and insert it at a different position\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If duplicate nodes exist, repair by reinserting missing nodes\n        missing_nodes = set(range(n)) - set(new_solution)\n        for node in missing_nodes:\n            j = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8097024435775741,
            4.404247510433197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity (variation in objective values)\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        # Select solutions with high diversity in at least one objective\n        candidates = [i for i, (sol, obj) in enumerate(archive) if any(d > np.mean(diversity) for d in diversity)]\n        if candidates:\n            selected_idx = random.choice(candidates)\n            base_solution = archive[selected_idx][0].copy()\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n            base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and insertion with probability 0.7 and 0.3 respectively\n        if random.random() < 0.7:\n            # 2-opt move: select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Insertion move: select a node and insert it at a different position\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If duplicate nodes exist, repair by reinserting missing nodes\n        missing_nodes = set(range(n)) - set(new_solution)\n        for node in missing_nodes:\n            j = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 151,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligent selection: prioritize solutions with the best trade-off across objectives\n    # Using a simple weighted sum approach (could be replaced with more sophisticated selection)\n    weights = np.array([0.4, 0.3, 0.3])  # Adjust weights based on problem context\n    scores = [np.dot(weights, obj) for _, obj in archive]\n    selected_idx = np.argmin(scores)  # Select solution with the best weighted sum\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware perturbations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (standard but effective for TSP)\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Objective-aware 3-opt move (novel hybrid operator)\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n        # Choose the best of three possible 3-opt configurations based on objective improvement\n        configs = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:b], new_solution[a:c+1][::-1], new_solution[b:a], new_solution[c+1:]]),\n            np.concatenate([new_solution[:c], new_solution[a:b+1][::-1], new_solution[c:a], new_solution[b+1:]])\n        ]\n\n        # Evaluate each configuration across all objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n            cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n            cost3 = sum(distance_matrix_3[sol[i-1], sol[i]] for i in range(len(sol)))\n            return np.array([cost1, cost2, cost3])\n\n        evaluations = [evaluate(config) for config in configs]\n        best_idx = np.argmin([np.dot(weights, eval) for eval in evaluations])\n        new_solution = configs[best_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6845549860782085,
            1.7726289272308349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligent selection: prioritize solutions with the best trade-off across objectives\n    # Using a simple weighted sum approach (could be replaced with more sophisticated selection)\n    weights = np.array([0.4, 0.3, 0.3])  # Adjust weights based on problem context\n    scores = [np.dot(weights, obj) for _, obj in archive]\n    selected_idx = np.argmin(scores)  # Select solution with the best weighted sum\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware perturbations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (standard but effective for TSP)\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Objective-aware 3-opt move (novel hybrid operator)\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n        # Choose the best of three possible 3-opt configurations based on objective improvement\n        configs = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:b], new_solution[a:c+1][::-1], new_solution[b:a], new_solution[c+1:]]),\n            np.concatenate([new_solution[:c], new_solution[a:b+1][::-1], new_solution[c:a], new_solution[b+1:]])\n        ]\n\n        # Evaluate each configuration across all objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n            cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n            cost3 = sum(distance_matrix_3[sol[i-1], sol[i]] for i in range(len(sol)))\n            return np.array([cost1, cost2, cost3])\n\n        evaluations = [evaluate(config) for config in configs]\n        best_idx = np.argmin([np.dot(weights, eval) for eval in evaluations])\n        new_solution = configs[best_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 152,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by total cost (sum of three objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select top 20% solutions with the potential for improvement\n    top_candidates = archive_sorted[:max(1, len(archive) // 5)]\n    selected_solution = random.choice(top_candidates)[0].copy()\n\n    # Hybrid local search strategy: combination of 2-opt and 3-opt with objective-aware selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and 3-opt based on current solution quality\n    if random.random() < 0.7 or sum(archive_sorted[0][1]) > sum(archive_sorted[-1][1]) * 0.9:\n        # Perform 2-opt with objective-aware edge selection\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform 3-opt with objective-aware edge selection\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Validate the solution remains feasible\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (contains duplicates or missing nodes)\")\n\n    return new_solution\n\n",
        "score": [
            -0.6580879102045715,
            0.9934648752212525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by total cost (sum of three objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select top 20% solutions with the potential for improvement\n    top_candidates = archive_sorted[:max(1, len(archive) // 5)]\n    selected_solution = random.choice(top_candidates)[0].copy()\n\n    # Hybrid local search strategy: combination of 2-opt and 3-opt with objective-aware selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and 3-opt based on current solution quality\n    if random.random() < 0.7 or sum(archive_sorted[0][1]) > sum(archive_sorted[-1][1]) * 0.9:\n        # Perform 2-opt with objective-aware edge selection\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform 3-opt with objective-aware edge selection\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Validate the solution remains feasible\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (contains duplicates or missing nodes)\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 153,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to prioritize solutions with higher values in any objective\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.max(axis=1)  # Prioritize solutions with high values in any objective\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with a probability based on objective diversity\n    # 2. Apply 3-opt if the solution is dominated in one objective\n    # 3. Apply node insertion if the solution is dominated in two objectives\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current objectives\n    def calculate_objectives(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(base_solution)\n    objectives_array = np.array([obj for _, obj in archive])\n    dominated_count = np.sum(np.all(objectives_array <= current_obj, axis=1)) - 1  # -1 to exclude self\n\n    # Determine which local search to apply\n    if dominated_count > len(archive) * 0.7:  # If solution is dominated in most objectives\n        # Apply 3-opt (more disruptive)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    elif dominated_count > len(archive) * 0.3:  # If solution is dominated in some objectives\n        # Apply node insertion (less disruptive)\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n    else:\n        # Apply 2-opt (standard local search)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.3883305387811021,
            2.2006564021110533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to prioritize solutions with higher values in any objective\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.max(axis=1)  # Prioritize solutions with high values in any objective\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with a probability based on objective diversity\n    # 2. Apply 3-opt if the solution is dominated in one objective\n    # 3. Apply node insertion if the solution is dominated in two objectives\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current objectives\n    def calculate_objectives(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(base_solution)\n    objectives_array = np.array([obj for _, obj in archive])\n    dominated_count = np.sum(np.all(objectives_array <= current_obj, axis=1)) - 1  # -1 to exclude self\n\n    # Determine which local search to apply\n    if dominated_count > len(archive) * 0.7:  # If solution is dominated in most objectives\n        # Apply 3-opt (more disruptive)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    elif dominated_count > len(archive) * 0.3:  # If solution is dominated in some objectives\n        # Apply node insertion (less disruptive)\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n    else:\n        # Apply 2-opt (standard local search)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 154,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select segments to modify based on objective diversity\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Ensure i < j < k\n    i, j, k = sorted([i, j, k])\n\n    # 2-opt swap between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap between j and k\n    # Calculate objective improvements for different swap options\n    def calculate_improvement(swap_solution):\n        obj1 = sum(distance_matrix_1[swap_solution[i], swap_solution[i+1]] for i in range(n-1)) + distance_matrix_1[swap_solution[-1], swap_solution[0]]\n        obj2 = sum(distance_matrix_2[swap_solution[i], swap_solution[i+1]] for i in range(n-1)) + distance_matrix_2[swap_solution[-1], swap_solution[0]]\n        obj3 = sum(distance_matrix_3[swap_solution[i], swap_solution[i+1]] for i in range(n-1)) + distance_matrix_3[swap_solution[-1], swap_solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_improvement(new_solution)\n\n    # Try different swap options to improve the most diverse objective\n    best_solution = new_solution.copy()\n    best_obj = current_obj\n\n    # Option 1: Swap nodes at j and k\n    temp_solution = new_solution.copy()\n    temp_solution[j], temp_solution[k] = temp_solution[k], temp_solution[j]\n    temp_obj = calculate_improvement(temp_solution)\n    if sum(temp_obj) < sum(best_obj):\n        best_solution = temp_solution.copy()\n        best_obj = temp_obj\n\n    # Option 2: Reverse segment between j and k\n    temp_solution = new_solution.copy()\n    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n    temp_obj = calculate_improvement(temp_solution)\n    if sum(temp_obj) < sum(best_obj):\n        best_solution = temp_solution.copy()\n        best_obj = temp_obj\n\n    # Option 3: Shift segment between j and k\n    temp_solution = new_solution.copy()\n    segment = temp_solution[j:k+1]\n    temp_solution = np.concatenate([temp_solution[:j], temp_solution[k+1:], segment])\n    temp_obj = calculate_improvement(temp_solution)\n    if sum(temp_obj) < sum(best_obj):\n        best_solution = temp_solution.copy()\n        best_obj = temp_obj\n\n    return best_solution\n\n",
        "score": [
            -0.49134585066430025,
            2.213237226009369
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select segments to modify based on objective diversity\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Ensure i < j < k\n    i, j, k = sorted([i, j, k])\n\n    # 2-opt swap between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap between j and k\n    # Calculate objective improvements for different swap options\n    def calculate_improvement(swap_solution):\n        obj1 = sum(distance_matrix_1[swap_solution[i], swap_solution[i+1]] for i in range(n-1)) + distance_matrix_1[swap_solution[-1], swap_solution[0]]\n        obj2 = sum(distance_matrix_2[swap_solution[i], swap_solution[i+1]] for i in range(n-1)) + distance_matrix_2[swap_solution[-1], swap_solution[0]]\n        obj3 = sum(distance_matrix_3[swap_solution[i], swap_solution[i+1]] for i in range(n-1)) + distance_matrix_3[swap_solution[-1], swap_solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_improvement(new_solution)\n\n    # Try different swap options to improve the most diverse objective\n    best_solution = new_solution.copy()\n    best_obj = current_obj\n\n    # Option 1: Swap nodes at j and k\n    temp_solution = new_solution.copy()\n    temp_solution[j], temp_solution[k] = temp_solution[k], temp_solution[j]\n    temp_obj = calculate_improvement(temp_solution)\n    if sum(temp_obj) < sum(best_obj):\n        best_solution = temp_solution.copy()\n        best_obj = temp_obj\n\n    # Option 2: Reverse segment between j and k\n    temp_solution = new_solution.copy()\n    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n    temp_obj = calculate_improvement(temp_solution)\n    if sum(temp_obj) < sum(best_obj):\n        best_solution = temp_solution.copy()\n        best_obj = temp_obj\n\n    # Option 3: Shift segment between j and k\n    temp_solution = new_solution.copy()\n    segment = temp_solution[j:k+1]\n    temp_solution = np.concatenate([temp_solution[:j], temp_solution[k+1:], segment])\n    temp_obj = calculate_improvement(temp_solution)\n    if sum(temp_obj) < sum(best_obj):\n        best_solution = temp_solution.copy()\n        best_obj = temp_obj\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 155,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:max(1, len(archive) // 5)]\n    base_solution, _ = random.choice(top_solutions)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, apply random segment reversal\n            seg_length = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - seg_length)\n            new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.639463134401214,
            1.3478794813156127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:max(1, len(archive) // 5)]\n    base_solution, _ = random.choice(top_solutions)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, apply random segment reversal\n            seg_length = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - seg_length)\n            new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 156,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly choose a local search strategy\n    strategy = random.choice(['2opt', 'edge_insertion', 'mixed'])\n\n    if strategy == '2opt':\n        # Perform 2-opt on a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif strategy == 'edge_insertion':\n        # Move a random node to a better position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        # Remove node\n        new_solution = np.delete(new_solution, node_idx)\n        # Find best insertion position based on combined distance\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(n-1):\n            # Calculate cost for insertion at position pos\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n            cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                    distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    else:  # mixed strategy\n        # Perform a small 2-opt first\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Then try edge insertion\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        best_pos = random.randint(0, n-2)  # Random position for simplicity\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7401293982253632,
            1.5052754163742066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly choose a local search strategy\n    strategy = random.choice(['2opt', 'edge_insertion', 'mixed'])\n\n    if strategy == '2opt':\n        # Perform 2-opt on a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif strategy == 'edge_insertion':\n        # Move a random node to a better position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        # Remove node\n        new_solution = np.delete(new_solution, node_idx)\n        # Find best insertion position based on combined distance\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(n-1):\n            # Calculate cost for insertion at position pos\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n            cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                    distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    else:  # mixed strategy\n        # Perform a small 2-opt first\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        # Then try edge insertion\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        best_pos = random.randint(0, n-2)  # Random position for simplicity\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 157,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by choosing one with the highest sum of objectives\n    # This helps in focusing on solutions that are less optimized across all objectives\n    selected_idx = np.argmax([sum(obj) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt and 3-opt moves with objective-aware selection\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt to balance exploration and exploitation\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move: select three edges and rearrange the segments\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n\n    # Ensure the solution remains a valid tour (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6813009717218129,
            1.4586559534072876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by choosing one with the highest sum of objectives\n    # This helps in focusing on solutions that are less optimized across all objectives\n    selected_idx = np.argmax([sum(obj) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt and 3-opt moves with objective-aware selection\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt to balance exploration and exploitation\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move: select three edges and rearrange the segments\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n\n    # Ensure the solution remains a valid tour (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 158,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with high potential for improvement\n    # Here, we select a solution with the highest variance in its objectives as it indicates room for multi-objective improvement\n    variances = [np.var([obj[i] for _, obj in archive]) for i in range(3)]\n    selected_idx = np.argmax(variances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[start:end]\n\n    # Apply 2-opt within the segment\n    if len(segment) > 2:\n        i, j = np.random.choice(len(segment), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        segment[i:j+1] = segment[i:j+1][::-1]\n\n    # Reinsert the modified segment\n    new_solution[start:end] = segment\n\n    # Apply edge insertion to improve connectivity\n    for _ in range(2):  # Limit the number of insertions to maintain diversity\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(selected_solution) and len(np.unique(new_solution)) == len(selected_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.717350248315283,
            1.552967917919159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with high potential for improvement\n    # Here, we select a solution with the highest variance in its objectives as it indicates room for multi-objective improvement\n    variances = [np.var([obj[i] for _, obj in archive]) for i in range(3)]\n    selected_idx = np.argmax(variances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[start:end]\n\n    # Apply 2-opt within the segment\n    if len(segment) > 2:\n        i, j = np.random.choice(len(segment), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        segment[i:j+1] = segment[i:j+1][::-1]\n\n    # Reinsert the modified segment\n    new_solution[start:end] = segment\n\n    # Apply edge insertion to improve connectivity\n    for _ in range(2):  # Limit the number of insertions to maintain diversity\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(selected_solution) and len(np.unique(new_solution)) == len(selected_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 159,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best swap that improves at least one objective\n    best_swap = None\n    best_improvement = 0\n\n    for k in range(i, j+1):\n        for l in range(k+1, j+1):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_1[new_solution[l], new_solution[k]] -\n                      distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                      distance_matrix_1[new_solution[l], new_solution[l-1]])\n\n            delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_2[new_solution[l], new_solution[k]] -\n                      distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                      distance_matrix_2[new_solution[l], new_solution[l-1]])\n\n            delta3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_3[new_solution[l], new_solution[k]] -\n                      distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                      distance_matrix_3[new_solution[l], new_solution[l-1]])\n\n            # Check if this swap improves at least one objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                improvement = abs(delta1) + abs(delta2) + abs(delta3)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (k, l)\n\n    if best_swap is not None:\n        k, l = best_swap\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.643880289363761,
            2.5027268528938293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best swap that improves at least one objective\n    best_swap = None\n    best_improvement = 0\n\n    for k in range(i, j+1):\n        for l in range(k+1, j+1):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_1[new_solution[l], new_solution[k]] -\n                      distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                      distance_matrix_1[new_solution[l], new_solution[l-1]])\n\n            delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_2[new_solution[l], new_solution[k]] -\n                      distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                      distance_matrix_2[new_solution[l], new_solution[l-1]])\n\n            delta3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_3[new_solution[l], new_solution[k]] -\n                      distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                      distance_matrix_3[new_solution[l], new_solution[l-1]])\n\n            # Check if this swap improves at least one objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                improvement = abs(delta1) + abs(delta2) + abs(delta3)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (k, l)\n\n    if best_swap is not None:\n        k, l = best_swap\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 160,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel multi-objective edge swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel multi-objective edge swap: swap edges based on the most critical objective\n    if np.random.rand() < 0.5:  # 50% chance to apply the multi-objective swap\n        obj1, obj2, obj3 = zip(*[archive[k][1] for k in range(min(5, len(archive)))])\n        critical_obj = np.argmax([np.std(obj1), np.std(obj2), np.std(obj3)])\n\n        if critical_obj == 0:\n            # Swap edges based on first objective's distance matrix\n            for k in range(n):\n                u, v = new_solution[k], new_solution[(k+1)%n]\n                for l in range(k+2, n):\n                    x, y = new_solution[l], new_solution[(l+1)%n]\n                    if distance_matrix_1[u][x] + distance_matrix_1[v][y] < distance_matrix_1[u][v] + distance_matrix_1[x][y]:\n                        new_solution[k+1:l+1] = new_solution[l:k:-1]\n                        break\n        elif critical_obj == 1:\n            # Swap edges based on second objective's distance matrix\n            for k in range(n):\n                u, v = new_solution[k], new_solution[(k+1)%n]\n                for l in range(k+2, n):\n                    x, y = new_solution[l], new_solution[(l+1)%n]\n                    if distance_matrix_2[u][x] + distance_matrix_2[v][y] < distance_matrix_2[u][v] + distance_matrix_2[x][y]:\n                        new_solution[k+1:l+1] = new_solution[l:k:-1]\n                        break\n        else:\n            # Swap edges based on third objective's distance matrix\n            for k in range(n):\n                u, v = new_solution[k], new_solution[(k+1)%n]\n                for l in range(k+2, n):\n                    x, y = new_solution[l], new_solution[(l+1)%n]\n                    if distance_matrix_3[u][x] + distance_matrix_3[v][y] < distance_matrix_3[u][v] + distance_matrix_3[x][y]:\n                        new_solution[k+1:l+1] = new_solution[l:k:-1]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6851368438227408,
            2.1587900638580324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel multi-objective edge swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel multi-objective edge swap: swap edges based on the most critical objective\n    if np.random.rand() < 0.5:  # 50% chance to apply the multi-objective swap\n        obj1, obj2, obj3 = zip(*[archive[k][1] for k in range(min(5, len(archive)))])\n        critical_obj = np.argmax([np.std(obj1), np.std(obj2), np.std(obj3)])\n\n        if critical_obj == 0:\n            # Swap edges based on first objective's distance matrix\n            for k in range(n):\n                u, v = new_solution[k], new_solution[(k+1)%n]\n                for l in range(k+2, n):\n                    x, y = new_solution[l], new_solution[(l+1)%n]\n                    if distance_matrix_1[u][x] + distance_matrix_1[v][y] < distance_matrix_1[u][v] + distance_matrix_1[x][y]:\n                        new_solution[k+1:l+1] = new_solution[l:k:-1]\n                        break\n        elif critical_obj == 1:\n            # Swap edges based on second objective's distance matrix\n            for k in range(n):\n                u, v = new_solution[k], new_solution[(k+1)%n]\n                for l in range(k+2, n):\n                    x, y = new_solution[l], new_solution[(l+1)%n]\n                    if distance_matrix_2[u][x] + distance_matrix_2[v][y] < distance_matrix_2[u][v] + distance_matrix_2[x][y]:\n                        new_solution[k+1:l+1] = new_solution[l:k:-1]\n                        break\n        else:\n            # Swap edges based on third objective's distance matrix\n            for k in range(n):\n                u, v = new_solution[k], new_solution[(k+1)%n]\n                for l in range(k+2, n):\n                    x, y = new_solution[l], new_solution[(l+1)%n]\n                    if distance_matrix_3[u][x] + distance_matrix_3[v][y] < distance_matrix_3[u][v] + distance_matrix_3[x][y]:\n                        new_solution[k+1:l+1] = new_solution[l:k:-1]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 161,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt move (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst-performing edge in any objective\n    worst_obj = None\n    worst_idx = -1\n    for k in range(n):\n        node_a, node_b = new_solution[k], new_solution[(k+1)%n]\n        obj1 = distance_matrix_1[node_a, node_b]\n        obj2 = distance_matrix_2[node_a, node_b]\n        obj3 = distance_matrix_3[node_a, node_b]\n        current_obj = (obj1, obj2, obj3)\n        if worst_obj is None or sum(current_obj) > sum(worst_obj):\n            worst_obj = current_obj\n            worst_idx = k\n\n    # Swap the worst edge with a random other edge\n    if worst_idx != -1:\n        swap_idx = np.random.randint(n)\n        while swap_idx == worst_idx or swap_idx == (worst_idx + 1) % n:\n            swap_idx = np.random.randint(n)\n        new_solution[worst_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5328185885023224,
            3.017621326446533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt move (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst-performing edge in any objective\n    worst_obj = None\n    worst_idx = -1\n    for k in range(n):\n        node_a, node_b = new_solution[k], new_solution[(k+1)%n]\n        obj1 = distance_matrix_1[node_a, node_b]\n        obj2 = distance_matrix_2[node_a, node_b]\n        obj3 = distance_matrix_3[node_a, node_b]\n        current_obj = (obj1, obj2, obj3)\n        if worst_obj is None or sum(current_obj) > sum(worst_obj):\n            worst_obj = current_obj\n            worst_idx = k\n\n    # Swap the worst edge with a random other edge\n    if worst_idx != -1:\n        swap_idx = np.random.randint(n)\n        while swap_idx == worst_idx or swap_idx == (worst_idx + 1) % n:\n            swap_idx = np.random.randint(n)\n        new_solution[worst_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 162,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = [sol for sol, _ in archive if np.random.rand() < 0.3]  # Randomly select 30% of solutions\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    operator = random.choice(['edge_exchange', 'node_insertion', 'segment_reversal'])\n\n    if operator == 'edge_exchange':\n        # Exchange two edges to form a 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'node_insertion':\n        # Remove a node and reinsert it at a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'segment_reversal':\n        # Reverse a segment while considering objective improvements\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate objective improvements for the reversal\n        original_cost = (sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                         sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                         sum(distance_matrix_3[segment[k-1], segment[k]] for k in range(1, len(segment))))\n\n        reversed_cost = (sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment))) +\n                        sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment))) +\n                        sum(distance_matrix_3[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment))))\n\n        # Only reverse if it improves at least one objective\n        if reversed_cost < original_cost:\n            new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7223580842056738,
            1.9132709503173828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = [sol for sol, _ in archive if np.random.rand() < 0.3]  # Randomly select 30% of solutions\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    operator = random.choice(['edge_exchange', 'node_insertion', 'segment_reversal'])\n\n    if operator == 'edge_exchange':\n        # Exchange two edges to form a 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'node_insertion':\n        # Remove a node and reinsert it at a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'segment_reversal':\n        # Reverse a segment while considering objective improvements\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate objective improvements for the reversal\n        original_cost = (sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                         sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                         sum(distance_matrix_3[segment[k-1], segment[k]] for k in range(1, len(segment))))\n\n        reversed_cost = (sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment))) +\n                        sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment))) +\n                        sum(distance_matrix_3[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment))))\n\n        # Only reverse if it improves at least one objective\n        if reversed_cost < original_cost:\n            new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 163,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_solution = None\n    max_diversity = -1\n\n    for sol, obj in archive:\n        # Calculate diversity as the sum of differences between objectives\n        diversity = sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt, 3-opt, and objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt move with probability 0.6\n    if random.random() < 0.6:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt move with probability 0.4\n    elif random.random() < 0.4:\n        k = random.randint(0, n-1)\n        if k < i or k > j:\n            # Perform 3-opt swap\n            if k < i:\n                new_solution[k:i+1] = new_solution[k:i+1][::-1]\n            else:\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Objective-aware swap with probability 0.2\n    elif random.random() < 0.2:\n        # Find the node with the highest total distance in any objective space\n        max_node = -1\n        max_dist = -1\n\n        for node in new_solution[i:j+1]:\n            total_dist = (distance_matrix_1[node, new_solution[(i-1)%n]] +\n                          distance_matrix_2[node, new_solution[(i-1)%n]] +\n                          distance_matrix_3[node, new_solution[(i-1)%n]])\n            if total_dist > max_dist:\n                max_dist = total_dist\n                max_node = node\n\n        if max_node != -1:\n            # Swap with a random node in the same segment\n            swap_pos = random.randint(i, j)\n            new_solution[swap_pos], new_solution[np.where(new_solution == max_node)[0][0]] = (\n                new_solution[np.where(new_solution == max_node)[0][0]], new_solution[swap_pos]\n            )\n\n    return new_solution\n\n",
        "score": [
            -0.4286811980223944,
            2.221309542655945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_solution = None\n    max_diversity = -1\n\n    for sol, obj in archive:\n        # Calculate diversity as the sum of differences between objectives\n        diversity = sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt, 3-opt, and objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt move with probability 0.6\n    if random.random() < 0.6:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt move with probability 0.4\n    elif random.random() < 0.4:\n        k = random.randint(0, n-1)\n        if k < i or k > j:\n            # Perform 3-opt swap\n            if k < i:\n                new_solution[k:i+1] = new_solution[k:i+1][::-1]\n            else:\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Objective-aware swap with probability 0.2\n    elif random.random() < 0.2:\n        # Find the node with the highest total distance in any objective space\n        max_node = -1\n        max_dist = -1\n\n        for node in new_solution[i:j+1]:\n            total_dist = (distance_matrix_1[node, new_solution[(i-1)%n]] +\n                          distance_matrix_2[node, new_solution[(i-1)%n]] +\n                          distance_matrix_3[node, new_solution[(i-1)%n]])\n            if total_dist > max_dist:\n                max_dist = total_dist\n                max_node = node\n\n        if max_node != -1:\n            # Swap with a random node in the same segment\n            swap_pos = random.randint(i, j)\n            new_solution[swap_pos], new_solution[np.where(new_solution == max_node)[0][0]] = (\n                new_solution[np.where(new_solution == max_node)[0][0]], new_solution[swap_pos]\n            )\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 164,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score of their objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions with a bias towards better solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        # Randomly select a solution from the top candidates\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a custom 3-opt-like move\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # First, perform a 2-opt move between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a custom 3-opt-like move between j and k\n    if random.random() < 0.5:  # 50% chance to apply the custom move\n        segment = new_solution[j:k]\n        # Reverse the segment and insert it in a different position\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:j], reversed_segment, new_solution[k:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If the solution is invalid, revert to a simple 2-opt\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7273160461094937,
            1.5019617915153503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score of their objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions with a bias towards better solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        # Randomly select a solution from the top candidates\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a custom 3-opt-like move\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # First, perform a 2-opt move between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a custom 3-opt-like move between j and k\n    if random.random() < 0.5:  # 50% chance to apply the custom move\n        segment = new_solution[j:k]\n        # Reverse the segment and insert it in a different position\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:j], reversed_segment, new_solution[k:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If the solution is invalid, revert to a simple 2-opt\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 165,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions with high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware perturbation: swap nodes that are most critical in one objective but less so in others\n    for _ in range(2):  # Perform multiple swaps to diversify\n        # Calculate edge costs in each objective space\n        costs = []\n        for k in range(n-1):\n            node1, node2 = new_solution[k], new_solution[k+1]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            cost3 = distance_matrix_3[node1, node2]\n            costs.append((cost1, cost2, cost3))\n\n        # Find edges with high cost in one objective but not in others\n        max_diff_edges = []\n        for k in range(n-1):\n            cost1, cost2, cost3 = costs[k]\n            # Calculate how much this edge contributes to each objective relative to others\n            diff1 = cost1 - (cost2 + cost3)/2\n            diff2 = cost2 - (cost1 + cost3)/2\n            diff3 = cost3 - (cost1 + cost2)/2\n            max_diff = max(diff1, diff2, diff3)\n            if max_diff > 0:  # Edge is particularly expensive in one objective\n                max_diff_edges.append((k, max_diff))\n\n        if max_diff_edges:\n            # Select the edge with highest difference and swap it\n            max_diff_edges.sort(key=lambda x: -x[1])\n            edge_idx = max_diff_edges[0][0]\n            a, b = edge_idx, edge_idx + 1\n            if a > 0 and b < n - 1:\n                # Swap nodes to potentially reduce the expensive edge\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7981559171819914,
            2.0398326992988585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions with high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware perturbation: swap nodes that are most critical in one objective but less so in others\n    for _ in range(2):  # Perform multiple swaps to diversify\n        # Calculate edge costs in each objective space\n        costs = []\n        for k in range(n-1):\n            node1, node2 = new_solution[k], new_solution[k+1]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            cost3 = distance_matrix_3[node1, node2]\n            costs.append((cost1, cost2, cost3))\n\n        # Find edges with high cost in one objective but not in others\n        max_diff_edges = []\n        for k in range(n-1):\n            cost1, cost2, cost3 = costs[k]\n            # Calculate how much this edge contributes to each objective relative to others\n            diff1 = cost1 - (cost2 + cost3)/2\n            diff2 = cost2 - (cost1 + cost3)/2\n            diff3 = cost3 - (cost1 + cost2)/2\n            max_diff = max(diff1, diff2, diff3)\n            if max_diff > 0:  # Edge is particularly expensive in one objective\n                max_diff_edges.append((k, max_diff))\n\n        if max_diff_edges:\n            # Select the edge with highest difference and swap it\n            max_diff_edges.sort(key=lambda x: -x[1])\n            edge_idx = max_diff_edges[0][0]\n            a, b = edge_idx, edge_idx + 1\n            if a > 0 and b < n - 1:\n                # Swap nodes to potentially reduce the expensive edge\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 166,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to others in objective space)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_objectives = archive[selected_idx][1]\n\n    # Calculate the crowding distance in the objective space to identify solutions with potential\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Prefer solutions with lower crowding distance (more crowded = less potential)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a segment to perturb based on objective diversity\n    obj1, obj2, obj3 = base_objectives\n    total_obj = obj1 + obj2 + obj3\n\n    # Probabilistically choose which objective to prioritize in the perturbation\n    if np.random.random() < obj1 / total_obj:\n        # Prioritize first objective\n        i, j = np.random.choice(n, 2, replace=False)\n    elif np.random.random() < obj2 / total_obj:\n        # Prioritize second objective\n        i, j = np.random.choice(n, 2, replace=False)\n    else:\n        # Prioritize third objective\n        i, j = np.random.choice(n, 2, replace=False)\n\n    # Ensure i < j for simplicity\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move (reverse the segment between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.690307180250605,
            3.899087703227997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to others in objective space)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_objectives = archive[selected_idx][1]\n\n    # Calculate the crowding distance in the objective space to identify solutions with potential\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Prefer solutions with lower crowding distance (more crowded = less potential)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a segment to perturb based on objective diversity\n    obj1, obj2, obj3 = base_objectives\n    total_obj = obj1 + obj2 + obj3\n\n    # Probabilistically choose which objective to prioritize in the perturbation\n    if np.random.random() < obj1 / total_obj:\n        # Prioritize first objective\n        i, j = np.random.choice(n, 2, replace=False)\n    elif np.random.random() < obj2 / total_obj:\n        # Prioritize second objective\n        i, j = np.random.choice(n, 2, replace=False)\n    else:\n        # Prioritize third objective\n        i, j = np.random.choice(n, 2, replace=False)\n\n    # Ensure i < j for simplicity\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move (reverse the segment between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 167,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by the sum of objectives to prioritize solutions with lower costs\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(10, len(archive_sorted) - 1)  # Select from top 10 or all if less than 10\n    base_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a combination of 2-opt and objective-aware swaps\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: swap nodes that are far in one objective but close in others\n            i = random.randint(0, n-1)\n            j = (i + random.randint(1, n//2)) % n\n\n            # Calculate the objective differences\n            obj1_diff = abs(distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                           distance_matrix_1[new_solution[j], new_solution[j]])\n\n            obj2_diff = abs(distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                           distance_matrix_2[new_solution[j], new_solution[j]])\n\n            obj3_diff = abs(distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                           distance_matrix_3[new_solution[j], new_solution[j]])\n\n            # If the swap improves at least one objective, perform it\n            if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6198764020913038,
            2.3564617037773132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by the sum of objectives to prioritize solutions with lower costs\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(10, len(archive_sorted) - 1)  # Select from top 10 or all if less than 10\n    base_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a combination of 2-opt and objective-aware swaps\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: swap nodes that are far in one objective but close in others\n            i = random.randint(0, n-1)\n            j = (i + random.randint(1, n//2)) % n\n\n            # Calculate the objective differences\n            obj1_diff = abs(distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                           distance_matrix_1[new_solution[j], new_solution[j]])\n\n            obj2_diff = abs(distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                           distance_matrix_2[new_solution[j], new_solution[j]])\n\n            obj3_diff = abs(distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                           distance_matrix_3[new_solution[j], new_solution[j]])\n\n            # If the swap improves at least one objective, perform it\n            if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 168,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., worst objective)\n    objectives = np.array([obj for _, obj in archive])\n    # Calculate the sum of normalized objectives for each solution\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware 2-opt\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate the swap in all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        if new_cost < original_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware 3-opt (limited to one segment flip)\n    if n >= 4:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        # Evaluate the 3-opt move in all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]]\n        )\n\n        # Try different segment flips\n        options = [\n            (new_solution[i:j+1][::-1], new_solution[j:k+1][::-1], new_solution[k:][::-1]),\n            (new_solution[i:j+1][::-1], new_solution[j:k+1], new_solution[k:]),\n            (new_solution[i:j+1], new_solution[j:k+1][::-1], new_solution[k:]),\n            (new_solution[i:j+1], new_solution[j:k+1], new_solution[k:][::-1])\n        ]\n\n        best_new_solution = new_solution.copy()\n        best_new_cost = original_cost\n\n        for opt in options:\n            temp_solution = np.concatenate([new_solution[:i], opt[0], opt[1], opt[2]])\n            new_cost = (\n                distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_1[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_1[temp_solution[k-1], temp_solution[k]] +\n                distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_2[temp_solution[k-1], temp_solution[k]] +\n                distance_matrix_3[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_3[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_3[temp_solution[k-1], temp_solution[k]]\n            )\n\n            if new_cost < best_new_cost:\n                best_new_cost = new_cost\n                best_new_solution = temp_solution.copy()\n\n        if best_new_cost < original_cost:\n            new_solution = best_new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5423110119123571,
            1.361992609500885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., worst objective)\n    objectives = np.array([obj for _, obj in archive])\n    # Calculate the sum of normalized objectives for each solution\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware 2-opt\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate the swap in all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        if new_cost < original_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware 3-opt (limited to one segment flip)\n    if n >= 4:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        # Evaluate the 3-opt move in all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]]\n        )\n\n        # Try different segment flips\n        options = [\n            (new_solution[i:j+1][::-1], new_solution[j:k+1][::-1], new_solution[k:][::-1]),\n            (new_solution[i:j+1][::-1], new_solution[j:k+1], new_solution[k:]),\n            (new_solution[i:j+1], new_solution[j:k+1][::-1], new_solution[k:]),\n            (new_solution[i:j+1], new_solution[j:k+1], new_solution[k:][::-1])\n        ]\n\n        best_new_solution = new_solution.copy()\n        best_new_cost = original_cost\n\n        for opt in options:\n            temp_solution = np.concatenate([new_solution[:i], opt[0], opt[1], opt[2]])\n            new_cost = (\n                distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_1[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_1[temp_solution[k-1], temp_solution[k]] +\n                distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_2[temp_solution[k-1], temp_solution[k]] +\n                distance_matrix_3[temp_solution[i-1], temp_solution[i]] +\n                distance_matrix_3[temp_solution[j-1], temp_solution[j]] +\n                distance_matrix_3[temp_solution[k-1], temp_solution[k]]\n            )\n\n            if new_cost < best_new_cost:\n                best_new_cost = new_cost\n                best_new_solution = temp_solution.copy()\n\n        if best_new_cost < original_cost:\n            new_solution = best_new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 169,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform multi-objective edge swap\n    if k != l:\n        # Calculate the improvement potential across all three objectives\n        obj1_improvement = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_1[new_solution[k], new_solution[l-1]]) - \\\n                           (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                            distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        obj2_improvement = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_2[new_solution[k], new_solution[l-1]]) - \\\n                           (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                            distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        obj3_improvement = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_3[new_solution[k], new_solution[l-1]]) - \\\n                           (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                            distance_matrix_3[new_solution[l-1], new_solution[l]])\n\n        # If the swap improves at least one objective, perform it\n        if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6990849497821361,
            1.7809440970420838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform multi-objective edge swap\n    if k != l:\n        # Calculate the improvement potential across all three objectives\n        obj1_improvement = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_1[new_solution[k], new_solution[l-1]]) - \\\n                           (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                            distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        obj2_improvement = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_2[new_solution[k], new_solution[l-1]]) - \\\n                           (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                            distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        obj3_improvement = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_3[new_solution[k], new_solution[l-1]]) - \\\n                           (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                            distance_matrix_3[new_solution[l-1], new_solution[l]])\n\n        # If the swap improves at least one objective, perform it\n        if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 170,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the spread of objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel 3-objective-aware operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve one objective\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply a 3-objective-aware operator: select a segment and reinsert based on combined cost\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[k:l+1]\n\n    # Calculate combined cost for reinsertion points\n    costs = []\n    for m in range(n - len(segment)):\n        if m < k:\n            candidate = np.concatenate([new_solution[:m], segment, new_solution[m:k], new_solution[l+1:]])\n        else:\n            candidate = np.concatenate([new_solution[:k], new_solution[l+1:m], segment, new_solution[m:]])\n\n        # Combined cost across all objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        combined_cost = cost1 + cost2 + cost3\n        costs.append((combined_cost, candidate))\n\n    if costs:\n        _, best_candidate = min(costs, key=lambda x: x[0])\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.586925730380322,
            2.4374175667762756
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the spread of objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel 3-objective-aware operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve one objective\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply a 3-objective-aware operator: select a segment and reinsert based on combined cost\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[k:l+1]\n\n    # Calculate combined cost for reinsertion points\n    costs = []\n    for m in range(n - len(segment)):\n        if m < k:\n            candidate = np.concatenate([new_solution[:m], segment, new_solution[m:k], new_solution[l+1:]])\n        else:\n            candidate = np.concatenate([new_solution[:k], new_solution[l+1:m], segment, new_solution[m:]])\n\n        # Combined cost across all objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n        combined_cost = cost1 + cost2 + cost3\n        costs.append((combined_cost, candidate))\n\n    if costs:\n        _, best_candidate = min(costs, key=lambda x: x[0])\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 171,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimized in all objectives)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    selected_idx = np.argmax([np.sum(np.abs(obj - avg_objectives)) for obj in objectives])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify segments with high potential for improvement\n    # Calculate current segment costs\n    def calculate_segment_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(len(solution)-1):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[-1], solution[0]]  # complete the tour\n        return cost\n\n    current_cost1 = calculate_segment_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_segment_cost(new_solution, distance_matrix_2)\n    current_cost3 = calculate_segment_cost(new_solution, distance_matrix_3)\n\n    # Try to improve by swapping nodes that are far in one objective but close in others\n    for _ in range(5):  # Limited attempts to avoid excessive computation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential new costs\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        new_cost1 = calculate_segment_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_segment_cost(temp_solution, distance_matrix_2)\n        new_cost3 = calculate_segment_cost(temp_solution, distance_matrix_3)\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or new_cost3 < current_cost3):\n            new_solution = temp_solution\n            current_cost1, current_cost2, current_cost3 = new_cost1, new_cost2, new_cost3\n            break  # Only accept one improvement per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.650183551278028,
            3.499662625789642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimized in all objectives)\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    selected_idx = np.argmax([np.sum(np.abs(obj - avg_objectives)) for obj in objectives])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify segments with high potential for improvement\n    # Calculate current segment costs\n    def calculate_segment_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(len(solution)-1):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[-1], solution[0]]  # complete the tour\n        return cost\n\n    current_cost1 = calculate_segment_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_segment_cost(new_solution, distance_matrix_2)\n    current_cost3 = calculate_segment_cost(new_solution, distance_matrix_3)\n\n    # Try to improve by swapping nodes that are far in one objective but close in others\n    for _ in range(5):  # Limited attempts to avoid excessive computation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential new costs\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        new_cost1 = calculate_segment_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_segment_cost(temp_solution, distance_matrix_2)\n        new_cost3 = calculate_segment_cost(temp_solution, distance_matrix_3)\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or new_cost3 < current_cost3):\n            new_solution = temp_solution\n            current_cost1, current_cost2, current_cost3 = new_cost1, new_cost2, new_cost3\n            break  # Only accept one improvement per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 172,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more room for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select the top 30% of solutions\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top candidates\n        selected_idx = np.random.randint(0, len(candidate_solutions))\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform a 2-opt move (standard for TSP)\n    # 2. Then perform a 3-opt move (more disruptive but can escape local optima)\n    # 3. Finally, apply a custom 3-objective-aware swap\n\n    # 2-opt move\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt move (randomly select 3 edges and reconnect them in a different way)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    if a < b < c:\n        # There are 4 possible ways to reconnect 3 edges in a 3-opt move\n        # We randomly choose one of them\n        option = np.random.randint(0, 4)\n        if option == 0:\n            # No change\n            pass\n        elif option == 1:\n            # Reverse the middle segment\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        elif option == 2:\n            # Reverse the first and middle segments\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        elif option == 3:\n            # Reverse all three segments\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n    # 3-objective-aware swap: identify nodes that improve at least one objective\n    # when swapped with their neighbors\n    improved = False\n    for i in range(n):\n        j = (i + 1) % n\n        current_nodes = [new_solution[i], new_solution[j]]\n        # Calculate current objective values\n        current_obj1 = distance_matrix_1[current_nodes[0], current_nodes[1]]\n        current_obj2 = distance_matrix_2[current_nodes[0], current_nodes[1]]\n        current_obj3 = distance_matrix_3[current_nodes[0], current_nodes[1]]\n\n        # Try swapping with a random other node\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            # Calculate new objective values\n            new_nodes = [current_nodes[0], new_solution[k]]\n            new_obj1 = distance_matrix_1[new_nodes[0], new_nodes[1]]\n            new_obj2 = distance_matrix_2[new_nodes[0], new_nodes[1]]\n            new_obj3 = distance_matrix_3[new_nodes[0], new_nodes[1]]\n\n            # If at least one objective improves, accept the swap\n            if (new_obj1 < current_obj1) or (new_obj2 < current_obj2) or (new_obj3 < current_obj3):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n                improved = True\n                break\n\n    # If no improvement found with the 3-objective-aware swap, perform a random 2-opt\n    if not improved:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7039395507844339,
            1.271722638607025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more room for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select the top 30% of solutions\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top candidates\n        selected_idx = np.random.randint(0, len(candidate_solutions))\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform a 2-opt move (standard for TSP)\n    # 2. Then perform a 3-opt move (more disruptive but can escape local optima)\n    # 3. Finally, apply a custom 3-objective-aware swap\n\n    # 2-opt move\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt move (randomly select 3 edges and reconnect them in a different way)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    if a < b < c:\n        # There are 4 possible ways to reconnect 3 edges in a 3-opt move\n        # We randomly choose one of them\n        option = np.random.randint(0, 4)\n        if option == 0:\n            # No change\n            pass\n        elif option == 1:\n            # Reverse the middle segment\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        elif option == 2:\n            # Reverse the first and middle segments\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        elif option == 3:\n            # Reverse all three segments\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n    # 3-objective-aware swap: identify nodes that improve at least one objective\n    # when swapped with their neighbors\n    improved = False\n    for i in range(n):\n        j = (i + 1) % n\n        current_nodes = [new_solution[i], new_solution[j]]\n        # Calculate current objective values\n        current_obj1 = distance_matrix_1[current_nodes[0], current_nodes[1]]\n        current_obj2 = distance_matrix_2[current_nodes[0], current_nodes[1]]\n        current_obj3 = distance_matrix_3[current_nodes[0], current_nodes[1]]\n\n        # Try swapping with a random other node\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            # Calculate new objective values\n            new_nodes = [current_nodes[0], new_solution[k]]\n            new_obj1 = distance_matrix_1[new_nodes[0], new_nodes[1]]\n            new_obj2 = distance_matrix_2[new_nodes[0], new_nodes[1]]\n            new_obj3 = distance_matrix_3[new_nodes[0], new_nodes[1]]\n\n            # If at least one objective improves, accept the swap\n            if (new_obj1 < current_obj1) or (new_obj2 < current_obj2) or (new_obj3 < current_obj3):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n                improved = True\n                break\n\n    # If no improvement found with the 3-objective-aware swap, perform a random 2-opt\n    if not improved:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 173,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not too similar to others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and random segment inversion\n    n = len(new_solution)\n    if n < 4:\n        # Too small to apply meaningful operators\n        return new_solution\n\n    # Randomly choose between 2-opt and segment inversion\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Random segment inversion with objective-aware selection\n        # Choose a segment that might improve at least one objective\n        best_improvement = 0\n        best_i, best_j = 0, 0\n\n        # Try multiple random segments to find the most promising one\n        for _ in range(min(10, n//2)):\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i < 2:\n                continue\n\n            # Calculate current cost for this segment\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            current_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n            # Calculate potential cost after inversion\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n            new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]]\n            new_cost3 = distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n\n            # Count how many objectives would improve\n            improvement_count = sum(1 for curr, new in [(current_cost1, new_cost1), (current_cost2, new_cost2), (current_cost3, new_cost3)] if new < curr)\n\n            if improvement_count > best_improvement:\n                best_improvement = improvement_count\n                best_i, best_j = i, j\n\n        if best_improvement > 0:\n            new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(set(new_solution)) == n, \"Generated solution is not a valid tour\"\n    assert np.all(new_solution >= 0) and np.all(new_solution < n), \"Generated solution contains invalid node IDs\"\n\n    return new_solution\n\n",
        "score": [
            -0.824613585351077,
            1.9387901544570922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not too similar to others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and random segment inversion\n    n = len(new_solution)\n    if n < 4:\n        # Too small to apply meaningful operators\n        return new_solution\n\n    # Randomly choose between 2-opt and segment inversion\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Random segment inversion with objective-aware selection\n        # Choose a segment that might improve at least one objective\n        best_improvement = 0\n        best_i, best_j = 0, 0\n\n        # Try multiple random segments to find the most promising one\n        for _ in range(min(10, n//2)):\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i < 2:\n                continue\n\n            # Calculate current cost for this segment\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            current_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n            # Calculate potential cost after inversion\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n            new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]]\n            new_cost3 = distance_matrix_3[temp_solution[i-1], temp_solution[i]] + distance_matrix_3[temp_solution[j-1], temp_solution[j]]\n\n            # Count how many objectives would improve\n            improvement_count = sum(1 for curr, new in [(current_cost1, new_cost1), (current_cost2, new_cost2), (current_cost3, new_cost3)] if new < curr)\n\n            if improvement_count > best_improvement:\n                best_improvement = improvement_count\n                best_i, best_j = i, j\n\n        if best_improvement > 0:\n            new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(set(new_solution)) == n, \"Generated solution is not a valid tour\"\n    assert np.all(new_solution >= 0) and np.all(new_solution < n), \"Generated solution contains invalid node IDs\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 174,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the smallest sum of objectives (promising for further improvement)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and random swap with objective-aware selection\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # First apply 2-opt locally to the most congested objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 > obj2 and obj1 > obj3:\n        # Focus on first objective space\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif obj2 > obj1 and obj2 > obj3:\n        # Focus on second objective space\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Focus on third objective space\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then apply a random swap to diversify\n    if n > 3:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7460882702328767,
            1.3997846961021423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the smallest sum of objectives (promising for further improvement)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and random swap with objective-aware selection\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # First apply 2-opt locally to the most congested objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 > obj2 and obj1 > obj3:\n        # Focus on first objective space\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif obj2 > obj1 and obj2 > obj3:\n        # Focus on second objective space\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Focus on third objective space\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then apply a random swap to diversify\n    if n > 3:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 175,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that shows potential for improvement in at least one objective\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Calculate the total cost of the current solution\n    current_cost = sum(current_objectives)\n\n    # Find a solution that is better in at least one objective\n    better_solutions = []\n    for i, (sol, obj) in enumerate(archive):\n        if any(o < current_objectives[j] for j, o in enumerate(obj)):\n            better_solutions.append((i, sol, obj))\n\n    if better_solutions:\n        # Select the solution with the best improvement in any objective\n        best_improvement = float('inf')\n        best_solution = None\n        for i, sol, obj in better_solutions:\n            improvement = sum(min(current_objectives[j] - o, 0) for j, o in enumerate(obj))\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_solution = sol.copy()\n\n        if best_solution is not None:\n            base_solution = best_solution\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Evaluate the segment's contribution to each objective\n    segment_costs = [0.0, 0.0, 0.0]\n    for k in range(len(segment) - 1):\n        a, b = segment[k], segment[k+1]\n        segment_costs[0] += distance_matrix_1[a, b]\n        segment_costs[1] += distance_matrix_2[a, b]\n        segment_costs[2] += distance_matrix_3[a, b]\n\n    # Find the worst objective in the segment\n    worst_obj = np.argmax(segment_costs)\n\n    # Apply 2-opt to the segment, prioritizing improvement in the worst objective\n    if len(segment) > 2:\n        best_improvement = 0\n        best_i, best_j = 0, 0\n\n        for k in range(len(segment)):\n            for l in range(k + 1, len(segment)):\n                a, b = segment[k], segment[l]\n                # Calculate potential improvement in the worst objective\n                old_cost = (distance_matrix_1[a, segment[k+1]] + distance_matrix_1[segment[l-1], b] +\n                            distance_matrix_2[a, segment[k+1]] + distance_matrix_2[segment[l-1], b] +\n                            distance_matrix_3[a, segment[k+1]] + distance_matrix_3[segment[l-1], b])\n\n                new_cost = (distance_matrix_1[a, b] + distance_matrix_1[segment[k+1], segment[l-1]] +\n                            distance_matrix_2[a, b] + distance_matrix_2[segment[k+1], segment[l-1]] +\n                            distance_matrix_3[a, b] + distance_matrix_3[segment[k+1], segment[l-1]])\n\n                improvement = old_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = k, l\n\n        if best_improvement > 0:\n            segment[best_i:best_j+1] = segment[best_i:best_j+1][::-1]\n            new_solution[i:j+1] = segment\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n_nodes:\n        # Fallback to a simple swap if the solution becomes invalid\n        k, l = np.random.choice(n_nodes, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7288857883120702,
            3.2874720811843874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that shows potential for improvement in at least one objective\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Calculate the total cost of the current solution\n    current_cost = sum(current_objectives)\n\n    # Find a solution that is better in at least one objective\n    better_solutions = []\n    for i, (sol, obj) in enumerate(archive):\n        if any(o < current_objectives[j] for j, o in enumerate(obj)):\n            better_solutions.append((i, sol, obj))\n\n    if better_solutions:\n        # Select the solution with the best improvement in any objective\n        best_improvement = float('inf')\n        best_solution = None\n        for i, sol, obj in better_solutions:\n            improvement = sum(min(current_objectives[j] - o, 0) for j, o in enumerate(obj))\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_solution = sol.copy()\n\n        if best_solution is not None:\n            base_solution = best_solution\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Evaluate the segment's contribution to each objective\n    segment_costs = [0.0, 0.0, 0.0]\n    for k in range(len(segment) - 1):\n        a, b = segment[k], segment[k+1]\n        segment_costs[0] += distance_matrix_1[a, b]\n        segment_costs[1] += distance_matrix_2[a, b]\n        segment_costs[2] += distance_matrix_3[a, b]\n\n    # Find the worst objective in the segment\n    worst_obj = np.argmax(segment_costs)\n\n    # Apply 2-opt to the segment, prioritizing improvement in the worst objective\n    if len(segment) > 2:\n        best_improvement = 0\n        best_i, best_j = 0, 0\n\n        for k in range(len(segment)):\n            for l in range(k + 1, len(segment)):\n                a, b = segment[k], segment[l]\n                # Calculate potential improvement in the worst objective\n                old_cost = (distance_matrix_1[a, segment[k+1]] + distance_matrix_1[segment[l-1], b] +\n                            distance_matrix_2[a, segment[k+1]] + distance_matrix_2[segment[l-1], b] +\n                            distance_matrix_3[a, segment[k+1]] + distance_matrix_3[segment[l-1], b])\n\n                new_cost = (distance_matrix_1[a, b] + distance_matrix_1[segment[k+1], segment[l-1]] +\n                            distance_matrix_2[a, b] + distance_matrix_2[segment[k+1], segment[l-1]] +\n                            distance_matrix_3[a, b] + distance_matrix_3[segment[k+1], segment[l-1]])\n\n                improvement = old_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = k, l\n\n        if best_improvement > 0:\n            segment[best_i:best_j+1] = segment[best_i:best_j+1][::-1]\n            new_solution[i:j+1] = segment\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n_nodes:\n        # Fallback to a simple swap if the solution becomes invalid\n        k, l = np.random.choice(n_nodes, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 176,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good in all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    deviations = np.abs(objectives - avg_objectives)\n    scores = np.sum(deviations, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, consider a multi-objective aware move based on the worst objective\n    current_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n    worst_obj = np.argmax(current_costs)\n\n    # Choose a segment to optimize based on the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst segment in the current solution\n    worst_segment_length = -1\n    worst_i, worst_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):  # Limit to small segments to keep computation feasible\n            segment_length = sum(dist_matrix[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            if segment_length > worst_segment_length:\n                worst_segment_length = segment_length\n                worst_i, worst_j = i, j\n\n    # Reverse the worst segment to improve the worst objective\n    new_solution[worst_i:worst_j+1] = new_solution[worst_i:worst_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5146757726229636,
            2.4337456703186033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good in all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    deviations = np.abs(objectives - avg_objectives)\n    scores = np.sum(deviations, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, consider a multi-objective aware move based on the worst objective\n    current_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n    worst_obj = np.argmax(current_costs)\n\n    # Choose a segment to optimize based on the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst segment in the current solution\n    worst_segment_length = -1\n    worst_i, worst_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):  # Limit to small segments to keep computation feasible\n            segment_length = sum(dist_matrix[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            if segment_length > worst_segment_length:\n                worst_segment_length = segment_length\n                worst_i, worst_j = i, j\n\n    # Reverse the worst segment to improve the worst objective\n    new_solution[worst_i:worst_j+1] = new_solution[worst_i:worst_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 177,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on objective diversity and total distance\n    def score_solution(solution_obj):\n        total_dist = sum(solution_obj)\n        diversity = max(solution_obj) - min(solution_obj)\n        return diversity / (1 + total_dist)  # Higher score is better\n\n    scored_solutions = [(score_solution(obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective to prioritize for the local search\n    obj_values = archive[0][1]\n    obj_weights = [1.0 / (1 + val) for val in obj_values]  # Higher weight for smaller objectives\n\n    # Apply weighted 2-opt or 3-opt based on objective weights\n    if random.random() < 0.7:  # 70% chance of 2-opt\n        # Select edges to swap based on objective weights\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement for each objective\n        def calculate_improvement(a, b, c, d):\n            delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d]) - (distance_matrix_1[a, c] + distance_matrix_1[b, d])\n            delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d]) - (distance_matrix_2[a, c] + distance_matrix_2[b, d])\n            delta3 = (distance_matrix_3[a, b] + distance_matrix_3[c, d]) - (distance_matrix_3[a, c] + distance_matrix_3[b, d])\n            return np.dot([delta1, delta2, delta3], obj_weights)\n\n        # Try multiple 2-opt swaps and keep the best one\n        best_improvement = 0\n        best_swap = None\n\n        for _ in range(5):  # Try 5 random swaps\n            a, b = sorted(random.sample(range(n), 2))\n            c, d = sorted(random.sample(range(n), 2))\n            improvement = calculate_improvement(a, b, c, d)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b, c, d)\n\n        if best_swap:\n            a, b, c, d = best_swap\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[c:d] = new_solution[c:d][::-1]\n    else:  # 30% chance of 3-opt\n        # Select three edges to reconnect\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Try different 3-opt configurations\n        configurations = [\n            (i, j, k), (i, k, j),\n            (j, i, k), (j, k, i),\n            (k, i, j), (k, j, i)\n        ]\n\n        best_config = None\n        best_improvement = 0\n\n        for config in configurations:\n            a, b, c = config\n            # Calculate improvement for this configuration\n            # (Simplified - actual implementation would need to compute all possible edge swaps)\n            # Here we just use a placeholder for the improvement calculation\n            improvement = random.random()  # Replace with actual improvement calculation\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_config:\n            a, b, c = best_config\n            # Apply the 3-opt move (simplified - actual implementation would need to handle the tour reconnection)\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.4658166533365817,
            1.8690677046775819
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on objective diversity and total distance\n    def score_solution(solution_obj):\n        total_dist = sum(solution_obj)\n        diversity = max(solution_obj) - min(solution_obj)\n        return diversity / (1 + total_dist)  # Higher score is better\n\n    scored_solutions = [(score_solution(obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective to prioritize for the local search\n    obj_values = archive[0][1]\n    obj_weights = [1.0 / (1 + val) for val in obj_values]  # Higher weight for smaller objectives\n\n    # Apply weighted 2-opt or 3-opt based on objective weights\n    if random.random() < 0.7:  # 70% chance of 2-opt\n        # Select edges to swap based on objective weights\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement for each objective\n        def calculate_improvement(a, b, c, d):\n            delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d]) - (distance_matrix_1[a, c] + distance_matrix_1[b, d])\n            delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d]) - (distance_matrix_2[a, c] + distance_matrix_2[b, d])\n            delta3 = (distance_matrix_3[a, b] + distance_matrix_3[c, d]) - (distance_matrix_3[a, c] + distance_matrix_3[b, d])\n            return np.dot([delta1, delta2, delta3], obj_weights)\n\n        # Try multiple 2-opt swaps and keep the best one\n        best_improvement = 0\n        best_swap = None\n\n        for _ in range(5):  # Try 5 random swaps\n            a, b = sorted(random.sample(range(n), 2))\n            c, d = sorted(random.sample(range(n), 2))\n            improvement = calculate_improvement(a, b, c, d)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b, c, d)\n\n        if best_swap:\n            a, b, c, d = best_swap\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[c:d] = new_solution[c:d][::-1]\n    else:  # 30% chance of 3-opt\n        # Select three edges to reconnect\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Try different 3-opt configurations\n        configurations = [\n            (i, j, k), (i, k, j),\n            (j, i, k), (j, k, i),\n            (k, i, j), (k, j, i)\n        ]\n\n        best_config = None\n        best_improvement = 0\n\n        for config in configurations:\n            a, b, c = config\n            # Calculate improvement for this configuration\n            # (Simplified - actual implementation would need to compute all possible edge swaps)\n            # Here we just use a placeholder for the improvement calculation\n            improvement = random.random()  # Replace with actual improvement calculation\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_config:\n            a, b, c = best_config\n            # Apply the 3-opt move (simplified - actual implementation would need to handle the tour reconnection)\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 178,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (more crowded solutions may have more potential)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% solutions\n        candidate_indices = range(min(3, len(archive_sorted) // 3))\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and edge swapping\n    if N > 3:\n        # Perform 2-opt with probability 0.7\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(N), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Edge swapping: swap two edges from different objectives\n            obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for simplicity\n            obj_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n            # Find edges with high potential for improvement\n            edges = []\n            for k in range(N):\n                u, v = new_solution[k], new_solution[(k+1)%N]\n                for obj_idx, matrix in enumerate(obj_matrices):\n                    edges.append((obj_idx, k, u, v, matrix[u, v]))\n\n            # Sort edges by their cost in their respective objective\n            edges.sort(key=lambda x: x[4] / obj_weights[x[0]])\n\n            # Select top 2 edges to swap\n            if len(edges) >= 2:\n                edge1 = edges[-1]\n                edge2 = edges[-2]\n\n                # Perform edge swap if possible\n                i1, i2 = edge1[1], edge2[1]\n                if abs(i1 - i2) > 1:\n                    # Perform swap\n                    new_solution[i1], new_solution[i2] = new_solution[i2], new_solution[i1]\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(random.sample(range(N), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.612771308758351,
            2.288366103172302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (more crowded solutions may have more potential)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% solutions\n        candidate_indices = range(min(3, len(archive_sorted) // 3))\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and edge swapping\n    if N > 3:\n        # Perform 2-opt with probability 0.7\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(N), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Edge swapping: swap two edges from different objectives\n            obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for simplicity\n            obj_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n            # Find edges with high potential for improvement\n            edges = []\n            for k in range(N):\n                u, v = new_solution[k], new_solution[(k+1)%N]\n                for obj_idx, matrix in enumerate(obj_matrices):\n                    edges.append((obj_idx, k, u, v, matrix[u, v]))\n\n            # Sort edges by their cost in their respective objective\n            edges.sort(key=lambda x: x[4] / obj_weights[x[0]])\n\n            # Select top 2 edges to swap\n            if len(edges) >= 2:\n                edge1 = edges[-1]\n                edge2 = edges[-2]\n\n                # Perform edge swap if possible\n                i1, i2 = edge1[1], edge2[1]\n                if abs(i1 - i2) > 1:\n                    # Perform swap\n                    new_solution[i1], new_solution[i2] = new_solution[i2], new_solution[i1]\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(random.sample(range(N), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 179,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the worst objective value)\n    objectives = [obj for _, obj in archive]\n    worst_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 2-opt on the objective with the highest variance\n        obj1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        obj2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        obj3 = [distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n\n        variances = [np.var(obj1), np.var(obj2), np.var(obj3)]\n        target_obj = np.argmax(variances)\n\n        # Select two non-adjacent edges to swap\n        i = np.random.randint(0, n)\n        j = (i + 2 + np.random.randint(0, n-2)) % n\n\n        # Apply 2-opt swap\n        if target_obj == 0:\n            # Check if swap improves the first objective\n            old_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            if new_cost < old_cost:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        elif target_obj == 1:\n            # Check if swap improves the second objective\n            old_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            if new_cost < old_cost:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # Check if swap improves the third objective\n            old_cost = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            if new_cost < old_cost:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Additional objective-aware swap\n        if np.random.random() < 0.3:  # 30% chance of additional swap\n            k, l = np.random.choice(n, 2, replace=False)\n            # Check if swap improves at least one objective\n            old_costs = (\n                distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            )\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n            new_costs = (\n                distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            )\n            if not any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n                # Revert if no improvement\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7430554180036384,
            2.2872100472450256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the worst objective value)\n    objectives = [obj for _, obj in archive]\n    worst_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 2-opt on the objective with the highest variance\n        obj1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        obj2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        obj3 = [distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n\n        variances = [np.var(obj1), np.var(obj2), np.var(obj3)]\n        target_obj = np.argmax(variances)\n\n        # Select two non-adjacent edges to swap\n        i = np.random.randint(0, n)\n        j = (i + 2 + np.random.randint(0, n-2)) % n\n\n        # Apply 2-opt swap\n        if target_obj == 0:\n            # Check if swap improves the first objective\n            old_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            if new_cost < old_cost:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        elif target_obj == 1:\n            # Check if swap improves the second objective\n            old_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            if new_cost < old_cost:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # Check if swap improves the third objective\n            old_cost = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            if new_cost < old_cost:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Additional objective-aware swap\n        if np.random.random() < 0.3:  # 30% chance of additional swap\n            k, l = np.random.choice(n, 2, replace=False)\n            # Check if swap improves at least one objective\n            old_costs = (\n                distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            )\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n            new_costs = (\n                distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            )\n            if not any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n                # Revert if no improvement\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 180,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find those with higher total cost\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% to encourage exploration\n        selection_pool = sorted_archive[int(0.7 * len(sorted_archive)):]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and segment inversion\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and segment inversion based on objective diversity\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt: select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment inversion: select a segment and invert it\n            seg_size = random.randint(2, min(5, n-1))\n            start = random.randint(0, n - seg_size)\n            new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.554241537632833,
            1.232021951675415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find those with higher total cost\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% to encourage exploration\n        selection_pool = sorted_archive[int(0.7 * len(sorted_archive)):]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and segment inversion\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and segment inversion based on objective diversity\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt: select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment inversion: select a segment and invert it\n            seg_size = random.randint(2, min(5, n-1))\n            start = random.randint(0, n - seg_size)\n            new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 181,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across all three objectives\n    def dominance_score(obj):\n        # Normalize objectives to avoid scale bias\n        max_obj1 = max(o[0] for _, o in archive)\n        max_obj2 = max(o[1] for _, o in archive)\n        max_obj3 = max(o[2] for _, o in archive)\n\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 != 0 else 0\n        norm_obj3 = obj[2] / max_obj3 if max_obj3 != 0 else 0\n\n        # Calculate a score based on normalized objectives (lower is better)\n        return norm_obj1 + norm_obj2 + norm_obj3\n\n    # Sort solutions by their dominance score (ascending)\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Randomly select a segment to reverse (2-opt with random segment)\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Apply a 3-opt move if possible (for more complex local search)\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        if b - a > 1 and c - b > 1:\n            # Apply 3-opt move\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment1, segment2[::-1]])\n\n    # 3. Apply a random swap to ensure diversity\n    if n > 1:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7138804270891776,
            2.6483794331550596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across all three objectives\n    def dominance_score(obj):\n        # Normalize objectives to avoid scale bias\n        max_obj1 = max(o[0] for _, o in archive)\n        max_obj2 = max(o[1] for _, o in archive)\n        max_obj3 = max(o[2] for _, o in archive)\n\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 != 0 else 0\n        norm_obj3 = obj[2] / max_obj3 if max_obj3 != 0 else 0\n\n        # Calculate a score based on normalized objectives (lower is better)\n        return norm_obj1 + norm_obj2 + norm_obj3\n\n    # Sort solutions by their dominance score (ascending)\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Randomly select a segment to reverse (2-opt with random segment)\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Apply a 3-opt move if possible (for more complex local search)\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        if b - a > 1 and c - b > 1:\n            # Apply 3-opt move\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment1, segment2[::-1]])\n\n    # 3. Apply a random swap to ensure diversity\n    if n > 1:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 182,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive.sort(key=lambda x: sum(x[1]))  # Sort by sum of objectives (simple heuristic)\n    selected_idx = min(len(archive) // 2, len(archive) - 1)  # Select from middle to avoid extremes\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply a 2-opt move (standard TSP improvement)\n    # 2. Apply a node swap based on the objective with the highest current cost\n    # 3. Apply a random swap to escape local optima\n\n    # Step 1: 2-opt move\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node swap based on highest cost objective\n    objectives = archive[selected_idx][1]\n    max_obj = np.argmax(objectives)\n\n    # Calculate current cost for each node in the selected objective\n    costs = []\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        if max_obj == 0:\n            cost = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        elif max_obj == 1:\n            cost = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n        costs.append(cost)\n\n    # Find the node with highest cost and swap it with a random neighbor\n    worst_node_idx = np.argmax(costs)\n    neighbor_idx = (worst_node_idx + random.choice([-1, 1])) % n\n    new_solution[worst_node_idx], new_solution[neighbor_idx] = new_solution[neighbor_idx], new_solution[worst_node_idx]\n\n    # Step 3: Random swap to escape local optima\n    if random.random() < 0.3:  # 30% chance\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7380253207563972,
            1.5580679059028626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive.sort(key=lambda x: sum(x[1]))  # Sort by sum of objectives (simple heuristic)\n    selected_idx = min(len(archive) // 2, len(archive) - 1)  # Select from middle to avoid extremes\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply a 2-opt move (standard TSP improvement)\n    # 2. Apply a node swap based on the objective with the highest current cost\n    # 3. Apply a random swap to escape local optima\n\n    # Step 1: 2-opt move\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node swap based on highest cost objective\n    objectives = archive[selected_idx][1]\n    max_obj = np.argmax(objectives)\n\n    # Calculate current cost for each node in the selected objective\n    costs = []\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        if max_obj == 0:\n            cost = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        elif max_obj == 1:\n            cost = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        else:\n            cost = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n        costs.append(cost)\n\n    # Find the node with highest cost and swap it with a random neighbor\n    worst_node_idx = np.argmax(costs)\n    neighbor_idx = (worst_node_idx + random.choice([-1, 1])) % n\n    new_solution[worst_node_idx], new_solution[neighbor_idx] = new_solution[neighbor_idx], new_solution[worst_node_idx]\n\n    # Step 3: Random swap to escape local optima\n    if random.random() < 0.3:  # 30% chance\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 183,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance across all objectives\n    edge_importance = np.zeros(n)\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        edge_importance[i] = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n    # Select edges with high importance for potential improvement\n    threshold = np.percentile(edge_importance, 75)  # Top 25% of edges\n    candidate_edges = np.where(edge_importance >= threshold)[0]\n\n    if len(candidate_edges) >= 2:\n        i, j = np.random.choice(candidate_edges, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Perform 2-opt swap\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Apply a small perturbation to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        k, l = np.random.choice(n, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.4519981194770387,
            2.440870702266693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance across all objectives\n    edge_importance = np.zeros(n)\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        edge_importance[i] = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n    # Select edges with high importance for potential improvement\n    threshold = np.percentile(edge_importance, 75)  # Top 25% of edges\n    candidate_edges = np.where(edge_importance >= threshold)[0]\n\n    if len(candidate_edges) >= 2:\n        i, j = np.random.choice(candidate_edges, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Perform 2-opt swap\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Apply a small perturbation to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        k, l = np.random.choice(n, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 184,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution from the archive\n    # Prefer solutions that are non-dominated and have high potential for improvement\n    selected_solution = None\n    min_score = float('inf')\n\n    for sol, obj in archive:\n        # Calculate a score based on the objective values and potential for improvement\n        # Lower score is better\n        score = sum(obj)  # Simple sum of objectives as a proxy for quality\n        if score < min_score:\n            min_score = score\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: combination of 2-opt and objective-aware swaps\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform 2-opt to improve the solution structure\n    for _ in range(10):  # Limit the number of iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(N), 2))\n        if i == j:\n            continue\n\n        # Try reversing the segment between i and j\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%N]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%N]])\n\n        # Accept if the change improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution = temp_solution\n\n    # Then perform objective-aware swaps to balance the objectives\n    for _ in range(5):  # Limit the number of swaps\n        i, j = random.sample(range(N), 2)\n        if i == j:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                 distance_matrix_1[temp_solution[i], temp_solution[(i+1)%N]] +\n                 distance_matrix_1[temp_solution[j-1], temp_solution[j]] +\n                 distance_matrix_1[temp_solution[j], temp_solution[(j+1)%N]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                 distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n\n        delta2 = (distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                 distance_matrix_2[temp_solution[i], temp_solution[(i+1)%N]] +\n                 distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                 distance_matrix_2[temp_solution[j], temp_solution[(j+1)%N]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                 distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n        delta3 = (distance_matrix_3[temp_solution[i-1], temp_solution[i]] +\n                 distance_matrix_3[temp_solution[i], temp_solution[(i+1)%N]] +\n                 distance_matrix_3[temp_solution[j-1], temp_solution[j]] +\n                 distance_matrix_3[temp_solution[j], temp_solution[(j+1)%N]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%N]] -\n                 distance_matrix_3[new_solution[j-1], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%N]])\n\n        # Accept if the swap improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7196085734996378,
            2.092641317844391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution from the archive\n    # Prefer solutions that are non-dominated and have high potential for improvement\n    selected_solution = None\n    min_score = float('inf')\n\n    for sol, obj in archive:\n        # Calculate a score based on the objective values and potential for improvement\n        # Lower score is better\n        score = sum(obj)  # Simple sum of objectives as a proxy for quality\n        if score < min_score:\n            min_score = score\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: combination of 2-opt and objective-aware swaps\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform 2-opt to improve the solution structure\n    for _ in range(10):  # Limit the number of iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(N), 2))\n        if i == j:\n            continue\n\n        # Try reversing the segment between i and j\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%N]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%N]])\n\n        # Accept if the change improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution = temp_solution\n\n    # Then perform objective-aware swaps to balance the objectives\n    for _ in range(5):  # Limit the number of swaps\n        i, j = random.sample(range(N), 2)\n        if i == j:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                 distance_matrix_1[temp_solution[i], temp_solution[(i+1)%N]] +\n                 distance_matrix_1[temp_solution[j-1], temp_solution[j]] +\n                 distance_matrix_1[temp_solution[j], temp_solution[(j+1)%N]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                 distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n\n        delta2 = (distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                 distance_matrix_2[temp_solution[i], temp_solution[(i+1)%N]] +\n                 distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                 distance_matrix_2[temp_solution[j], temp_solution[(j+1)%N]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                 distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n        delta3 = (distance_matrix_3[temp_solution[i-1], temp_solution[i]] +\n                 distance_matrix_3[temp_solution[i], temp_solution[(i+1)%N]] +\n                 distance_matrix_3[temp_solution[j-1], temp_solution[j]] +\n                 distance_matrix_3[temp_solution[j], temp_solution[(j+1)%N]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%N]] -\n                 distance_matrix_3[new_solution[j-1], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%N]])\n\n        # Accept if the swap improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 185,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions with high crowding distance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective aware perturbation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # 2-opt move (standard local search for TSP)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective aware perturbation: swap segments based on objective improvements\n    if random.random() < 0.3:  # 30% chance to apply the perturbation\n        k = random.randint(1, min(3, n // 2))  # segment length\n        a, b = sorted(random.sample(range(n - k + 1), 2))\n\n        # Evaluate the swap in all three objective spaces\n        original_cost = (\n            distance_matrix_1[base_solution[a-1], base_solution[a]] +\n            distance_matrix_1[base_solution[b+k-1], base_solution[b]] +\n            distance_matrix_2[base_solution[a-1], base_solution[a]] +\n            distance_matrix_2[base_solution[b+k-1], base_solution[b]] +\n            distance_matrix_3[base_solution[a-1], base_solution[a]] +\n            distance_matrix_3[base_solution[b+k-1], base_solution[b]]\n        )\n\n        new_cost = (\n            distance_matrix_1[base_solution[a-1], base_solution[b]] +\n            distance_matrix_1[base_solution[b+k-1], base_solution[a]] +\n            distance_matrix_2[base_solution[a-1], base_solution[b]] +\n            distance_matrix_2[base_solution[b+k-1], base_solution[a]] +\n            distance_matrix_3[base_solution[a-1], base_solution[b]] +\n            distance_matrix_3[base_solution[b+k-1], base_solution[a]]\n        )\n\n        if new_cost < original_cost:  # Accept if it improves at least one objective\n            new_solution[a:a+k], new_solution[b:b+k] = new_solution[b:b+k], new_solution[a:a+k]\n\n    return new_solution\n\n",
        "score": [
            -0.7649148754277698,
            1.2507620453834534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions with high crowding distance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective aware perturbation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # 2-opt move (standard local search for TSP)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective aware perturbation: swap segments based on objective improvements\n    if random.random() < 0.3:  # 30% chance to apply the perturbation\n        k = random.randint(1, min(3, n // 2))  # segment length\n        a, b = sorted(random.sample(range(n - k + 1), 2))\n\n        # Evaluate the swap in all three objective spaces\n        original_cost = (\n            distance_matrix_1[base_solution[a-1], base_solution[a]] +\n            distance_matrix_1[base_solution[b+k-1], base_solution[b]] +\n            distance_matrix_2[base_solution[a-1], base_solution[a]] +\n            distance_matrix_2[base_solution[b+k-1], base_solution[b]] +\n            distance_matrix_3[base_solution[a-1], base_solution[a]] +\n            distance_matrix_3[base_solution[b+k-1], base_solution[b]]\n        )\n\n        new_cost = (\n            distance_matrix_1[base_solution[a-1], base_solution[b]] +\n            distance_matrix_1[base_solution[b+k-1], base_solution[a]] +\n            distance_matrix_2[base_solution[a-1], base_solution[b]] +\n            distance_matrix_2[base_solution[b+k-1], base_solution[a]] +\n            distance_matrix_3[base_solution[a-1], base_solution[b]] +\n            distance_matrix_3[base_solution[b+k-1], base_solution[a]]\n        )\n\n        if new_cost < original_cost:  # Accept if it improves at least one objective\n            new_solution[a:a+k], new_solution[b:b+k] = new_solution[b:b+k], new_solution[a:a+k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 186,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) and pick a middle one for exploration\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = min(len(sorted_solutions) // 2, len(sorted_solutions) - 1)\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware perturbation\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt to improve the tour structure\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective aware perturbation: swap nodes that are improving at least one objective\n    for _ in range(min(3, n // 2)):  # Limit the number of perturbations\n        k, l = sorted(random.sample(range(n), 2))\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate the change in objectives for the swap\n        delta_obj1 = (distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[new_solution[(k+1)%n], node_l] -\n                      distance_matrix_1[new_solution[(k-1)%n], node_l] - distance_matrix_1[node_k, new_solution[(k+1)%n]])\n        delta_obj2 = (distance_matrix_2[node_k, new_solution[(k-1)%n]] + distance_matrix_2[new_solution[(k+1)%n], node_l] -\n                      distance_matrix_2[new_solution[(k-1)%n], node_l] - distance_matrix_2[node_k, new_solution[(k+1)%n]])\n        delta_obj3 = (distance_matrix_3[node_k, new_solution[(k-1)%n]] + distance_matrix_3[new_solution[(k+1)%n], node_l] -\n                      distance_matrix_3[new_solution[(k-1)%n], node_l] - distance_matrix_3[node_k, new_solution[(k+1)%n]])\n\n        # Accept the swap if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6874708280022537,
            1.1529475808143617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) and pick a middle one for exploration\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = min(len(sorted_solutions) // 2, len(sorted_solutions) - 1)\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware perturbation\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt to improve the tour structure\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective aware perturbation: swap nodes that are improving at least one objective\n    for _ in range(min(3, n // 2)):  # Limit the number of perturbations\n        k, l = sorted(random.sample(range(n), 2))\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate the change in objectives for the swap\n        delta_obj1 = (distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[new_solution[(k+1)%n], node_l] -\n                      distance_matrix_1[new_solution[(k-1)%n], node_l] - distance_matrix_1[node_k, new_solution[(k+1)%n]])\n        delta_obj2 = (distance_matrix_2[node_k, new_solution[(k-1)%n]] + distance_matrix_2[new_solution[(k+1)%n], node_l] -\n                      distance_matrix_2[new_solution[(k-1)%n], node_l] - distance_matrix_2[node_k, new_solution[(k+1)%n]])\n        delta_obj3 = (distance_matrix_3[node_k, new_solution[(k-1)%n]] + distance_matrix_3[new_solution[(k+1)%n], node_l] -\n                      distance_matrix_3[new_solution[(k-1)%n], node_l] - distance_matrix_3[node_k, new_solution[(k+1)%n]])\n\n        # Accept the swap if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 187,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_scores = normalized_objectives.sum(axis=1)\n        # Prefer solutions that are not too extreme (middle of the Pareto front)\n        middle_index = np.argsort(np.abs(combined_scores - 0.5))[0]\n        base_solution = archive[middle_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    for _ in range(5):  # Number of 2-opt attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i + 1 == j:\n            continue  # Skip adjacent edges\n\n        # Calculate change in objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j-1]),\n            (new_solution[i], new_solution[j])\n        ]\n\n        delta_obj1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        delta_obj2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        delta_obj3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        # Accept if at least one objective improves\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform 3-opt to further improve the solution\n    for _ in range(3):  # Number of 3-opt attempts\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if i + 1 == j or j + 1 == k:\n            continue  # Skip adjacent edges\n\n        # Generate all possible 3-opt moves and evaluate their impact\n        # This is a simplified version - a full implementation would consider all 8 possible 3-opt moves\n        # Here we just try one possible move for demonstration\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_segment = np.concatenate([segment1[::-1], segment2[::-1]])\n\n        # Calculate change in objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j]),\n            (new_solution[k-1], new_solution[k])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_segment[0]),\n            (new_segment[-1], new_solution[k-1]),\n            (new_segment[len(segment1)-1], new_segment[len(segment1)])\n        ]\n\n        delta_obj1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                      distance_matrix_1[new_edges[2][0], new_edges[2][1]] -\n                      distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_1[old_edges[1][0], old_edges[1][1]] -\n                      distance_matrix_1[old_edges[2][0], old_edges[2][1]])\n\n        delta_obj2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_2[new_edges[1][0], new_edges[1][1]] +\n                      distance_matrix_2[new_edges[2][0], new_edges[2][1]] -\n                      distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_2[old_edges[1][0], old_edges[1][1]] -\n                      distance_matrix_2[old_edges[2][0], old_edges[2][1]])\n\n        delta_obj3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_3[new_edges[1][0], new_edges[1][1]] +\n                      distance_matrix_3[new_edges[2][0], new_edges[2][1]] -\n                      distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_3[old_edges[1][0], old_edges[1][1]] -\n                      distance_matrix_3[old_edges[2][0], old_edges[2][1]])\n\n        # Accept if at least one objective improves\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:k] = new_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7667686082235219,
            2.2442763209342957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_scores = normalized_objectives.sum(axis=1)\n        # Prefer solutions that are not too extreme (middle of the Pareto front)\n        middle_index = np.argsort(np.abs(combined_scores - 0.5))[0]\n        base_solution = archive[middle_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    for _ in range(5):  # Number of 2-opt attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i + 1 == j:\n            continue  # Skip adjacent edges\n\n        # Calculate change in objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j-1]),\n            (new_solution[i], new_solution[j])\n        ]\n\n        delta_obj1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        delta_obj2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        delta_obj3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        # Accept if at least one objective improves\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform 3-opt to further improve the solution\n    for _ in range(3):  # Number of 3-opt attempts\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if i + 1 == j or j + 1 == k:\n            continue  # Skip adjacent edges\n\n        # Generate all possible 3-opt moves and evaluate their impact\n        # This is a simplified version - a full implementation would consider all 8 possible 3-opt moves\n        # Here we just try one possible move for demonstration\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_segment = np.concatenate([segment1[::-1], segment2[::-1]])\n\n        # Calculate change in objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j]),\n            (new_solution[k-1], new_solution[k])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_segment[0]),\n            (new_segment[-1], new_solution[k-1]),\n            (new_segment[len(segment1)-1], new_segment[len(segment1)])\n        ]\n\n        delta_obj1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                      distance_matrix_1[new_edges[2][0], new_edges[2][1]] -\n                      distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_1[old_edges[1][0], old_edges[1][1]] -\n                      distance_matrix_1[old_edges[2][0], old_edges[2][1]])\n\n        delta_obj2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_2[new_edges[1][0], new_edges[1][1]] +\n                      distance_matrix_2[new_edges[2][0], new_edges[2][1]] -\n                      distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_2[old_edges[1][0], old_edges[1][1]] -\n                      distance_matrix_2[old_edges[2][0], old_edges[2][1]])\n\n        delta_obj3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_3[new_edges[1][0], new_edges[1][1]] +\n                      distance_matrix_3[new_edges[2][0], new_edges[2][1]] -\n                      distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_3[old_edges[1][0], old_edges[1][1]] -\n                      distance_matrix_3[old_edges[2][0], old_edges[2][1]])\n\n        # Accept if at least one objective improves\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:k] = new_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 188,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt between a-b and c-d\n    if a < b and c < d:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above operation causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8173134515097793,
            1.7590208649635315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt between a-b and c-d\n    if a < b and c < d:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above operation causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 189,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity scores (crowding distance in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.zeros(len(archive))\n\n    for i in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        min_val, max_val = objectives[sorted_indices[0], i], objectives[sorted_indices[-1], i]\n        if max_val == min_val:\n            continue  # All solutions have the same objective value\n\n        # Normalize the objective values\n        normalized = (objectives[:, i] - min_val) / (max_val - min_val)\n        diversity_scores += normalized\n\n    # Combine quality and diversity for selection\n    selection_scores = diversity_scores  # Could be combined with quality scores if available\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    # Apply a combination of 2-opt and node swap to optimize across multiple objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective to prioritize for the local search\n    obj_values = archive[selected_idx][1]\n    obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for simplicity\n\n    # Randomly select a local search operator with probability based on objective weights\n    operators = ['2opt', 'node_swap', 'random_swap']\n    operator_probs = obj_weights / np.sum(obj_weights)\n    selected_operator = np.random.choice(operators, p=operator_probs)\n\n    if selected_operator == '2opt':\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif selected_operator == 'node_swap':\n        # Node swap: swap two nodes that are far apart in at least one objective space\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif selected_operator == 'random_swap':\n        # Random swap of two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6765354535609414,
            1.6067245483398438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity scores (crowding distance in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.zeros(len(archive))\n\n    for i in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        min_val, max_val = objectives[sorted_indices[0], i], objectives[sorted_indices[-1], i]\n        if max_val == min_val:\n            continue  # All solutions have the same objective value\n\n        # Normalize the objective values\n        normalized = (objectives[:, i] - min_val) / (max_val - min_val)\n        diversity_scores += normalized\n\n    # Combine quality and diversity for selection\n    selection_scores = diversity_scores  # Could be combined with quality scores if available\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    # Apply a combination of 2-opt and node swap to optimize across multiple objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective to prioritize for the local search\n    obj_values = archive[selected_idx][1]\n    obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for simplicity\n\n    # Randomly select a local search operator with probability based on objective weights\n    operators = ['2opt', 'node_swap', 'random_swap']\n    operator_probs = obj_weights / np.sum(obj_weights)\n    selected_operator = np.random.choice(operators, p=operator_probs)\n\n    if selected_operator == '2opt':\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif selected_operator == 'node_swap':\n        # Node swap: swap two nodes that are far apart in at least one objective space\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif selected_operator == 'random_swap':\n        # Random swap of two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 190,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate the standard deviation of each objective across the archive\n        std_devs = np.std(objectives, axis=0)\n        # Select the solution with the highest standard deviation (most diverse objectives)\n        selected_idx = np.argmax(np.sum(std_devs))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # First, perform a 2-opt move (standard local search for TSP)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a random swap to explore different objective trade-offs\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7557853750272656,
            1.5883118629455566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate the standard deviation of each objective across the archive\n        std_devs = np.std(objectives, axis=0)\n        # Select the solution with the highest standard deviation (most diverse objectives)\n        selected_idx = np.argmax(np.sum(std_devs))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # First, perform a 2-opt move (standard local search for TSP)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a random swap to explore different objective trade-offs\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 191,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the total cost across all objectives for each solution\n    total_costs = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest total cost (most promising for improvement)\n    selected_idx = np.argmin(total_costs)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt and insertion moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (swap two edges)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform insertion move (relocate a node to a different position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution is valid (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.6492620348554412,
            1.2475901007652284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the total cost across all objectives for each solution\n    total_costs = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest total cost (most promising for improvement)\n    selected_idx = np.argmin(total_costs)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt and insertion moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (swap two edges)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform insertion move (relocate a node to a different position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution is valid (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 192,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the sum of objectives\n        obj_sum = sum(obj)\n        candidates.append((sol, obj_sum))\n\n    # Sort candidates by objective sum (lower is better)\n    candidates.sort(key=lambda x: x[1])\n    # Select top 20% or at least 1 candidate\n    num_candidates = max(1, int(0.2 * len(candidates)))\n    selected = random.choice(candidates[:num_candidates])[0]\n    base_solution = selected.copy()\n\n    # Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 10, n - 1))  # Limit segment length to 10 nodes\n\n    # Extract the segment\n    segment = new_solution[start:end+1]\n\n    # Apply different operators based on objectives\n    if random.random() < 0.5:\n        # 2-opt for the objective with highest improvement potential\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment inversion with objective-aware selection\n        if random.random() < 0.5:\n            # Invert the segment\n            new_solution[start:end+1] = segment[::-1]\n        else:\n            # Shift segment to a new position\n            new_pos = random.randint(0, n - (end - start + 1))\n            segment = new_solution[start:end+1]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[end+1:new_pos],\n                segment,\n                new_solution[new_pos:]\n            ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7251738550867686,
            1.4125511407852174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the sum of objectives\n        obj_sum = sum(obj)\n        candidates.append((sol, obj_sum))\n\n    # Sort candidates by objective sum (lower is better)\n    candidates.sort(key=lambda x: x[1])\n    # Select top 20% or at least 1 candidate\n    num_candidates = max(1, int(0.2 * len(candidates)))\n    selected = random.choice(candidates[:num_candidates])[0]\n    base_solution = selected.copy()\n\n    # Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 10, n - 1))  # Limit segment length to 10 nodes\n\n    # Extract the segment\n    segment = new_solution[start:end+1]\n\n    # Apply different operators based on objectives\n    if random.random() < 0.5:\n        # 2-opt for the objective with highest improvement potential\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment inversion with objective-aware selection\n        if random.random() < 0.5:\n            # Invert the segment\n            new_solution[start:end+1] = segment[::-1]\n        else:\n            # Shift segment to a new position\n            new_pos = random.randint(0, n - (end - start + 1))\n            segment = new_solution[start:end+1]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[end+1:new_pos],\n                segment,\n                new_solution[new_pos:]\n            ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 193,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.5378964651152696,
            2.13712854385376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 194,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find potential candidates for improvement\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% or at least 1 solution\n        num_candidates = max(1, int(0.3 * len(archive_sorted)))\n        candidates = archive_sorted[:num_candidates]\n        # Randomly select one candidate\n        base_solution, _ = random.choice(candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small TSP instances, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 50% probability, perform 2-opt\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 50% probability, perform multi-objective edge swap\n            # Select two edges to swap based on their potential improvement across all objectives\n            i = random.randint(0, n-2)\n            j = random.randint(i+1, n-1)\n\n            # Calculate current and potential edge costs\n            current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            current_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            potential_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                              distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n            potential_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                              distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n            potential_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                              distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n            # If swapping improves at least one objective, perform the swap\n            if (potential_cost1 < current_cost1 or\n                potential_cost2 < current_cost2 or\n                potential_cost3 < current_cost3):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6345682350660189,
            2.0709416270256042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find potential candidates for improvement\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% or at least 1 solution\n        num_candidates = max(1, int(0.3 * len(archive_sorted)))\n        candidates = archive_sorted[:num_candidates]\n        # Randomly select one candidate\n        base_solution, _ = random.choice(candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small TSP instances, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 50% probability, perform 2-opt\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 50% probability, perform multi-objective edge swap\n            # Select two edges to swap based on their potential improvement across all objectives\n            i = random.randint(0, n-2)\n            j = random.randint(i+1, n-1)\n\n            # Calculate current and potential edge costs\n            current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            current_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            potential_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                              distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n            potential_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                              distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n            potential_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                              distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n            # If swapping improves at least one objective, perform the swap\n            if (potential_cost1 < current_cost1 or\n                potential_cost2 < current_cost2 or\n                potential_cost3 < current_cost3):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 195,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Choose between 2-opt or 3-opt based on a random decision\n    if np.random.rand() < 0.5:\n        # Apply 2-opt local search\n        i, j = sorted(np.random.choice(len(selected_solution), 2, replace=False))\n        selected_solution[i:j+1] = selected_solution[i:j+1][::-1]\n    else:\n        # Apply 3-opt local search\n        i, j, k = sorted(np.random.choice(len(selected_solution), 3, replace=False))\n        selected_solution[i:j+1] = selected_solution[i:j+1][::-1]\n        selected_solution[j:k+1] = selected_solution[j:k+1][::-1]\n\n    return selected_solution\n\n",
        "score": [
            -0.7157915059431784,
            1.622434425354004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Choose between 2-opt or 3-opt based on a random decision\n    if np.random.rand() < 0.5:\n        # Apply 2-opt local search\n        i, j = sorted(np.random.choice(len(selected_solution), 2, replace=False))\n        selected_solution[i:j+1] = selected_solution[i:j+1][::-1]\n    else:\n        # Apply 3-opt local search\n        i, j, k = sorted(np.random.choice(len(selected_solution), 3, replace=False))\n        selected_solution[i:j+1] = selected_solution[i:j+1][::-1]\n        selected_solution[j:k+1] = selected_solution[j:k+1][::-1]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 196,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined score (sum of objectives)\n    scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly choose one of three local search operators\n        operator = np.random.choice(['2opt', 'segment_inversion', 'objective_aware_swap'])\n\n        if operator == '2opt':\n            # Standard 2-opt local search\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i == j:\n                continue\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'segment_inversion':\n            # Invert a random segment of the tour\n            start, end = sorted(np.random.choice(n, 2, replace=False))\n            if start == end:\n                continue\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operator == 'objective_aware_swap':\n            # Swap nodes based on their performance across objectives\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i == j:\n                continue\n\n            # Calculate the change in each objective\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # Accept the swap if it improves any objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6951947174647978,
            2.772490990161896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined score (sum of objectives)\n    scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly choose one of three local search operators\n        operator = np.random.choice(['2opt', 'segment_inversion', 'objective_aware_swap'])\n\n        if operator == '2opt':\n            # Standard 2-opt local search\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i == j:\n                continue\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'segment_inversion':\n            # Invert a random segment of the tour\n            start, end = sorted(np.random.choice(n, 2, replace=False))\n            if start == end:\n                continue\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operator == 'objective_aware_swap':\n            # Swap nodes based on their performance across objectives\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i == j:\n                continue\n\n            # Calculate the change in each objective\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # Accept the swap if it improves any objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 197,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and random swap with objective-aware selection\n    new_solution = base_solution.copy()\n\n    # Decide between 2-opt or random swap based on objective diversity\n    if random.random() < 0.7:  # Higher probability for 2-opt to exploit local structure\n        # 2-opt: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random swap: swap two nodes to explore diverse neighborhoods\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7899870496352912,
            1.121060299873352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and random swap with objective-aware selection\n    new_solution = base_solution.copy()\n\n    # Decide between 2-opt or random swap based on objective diversity\n    if random.random() < 0.7:  # Higher probability for 2-opt to exploit local structure\n        # 2-opt: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random swap: swap two nodes to explore diverse neighborhoods\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 198,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    total_variance = np.sum(objective_variance)\n\n    # If all solutions have similar objectives, select a random one\n    if total_variance < 1e-6:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        # Select solutions with high variance (more potential for improvement)\n        variance_scores = np.sum((objectives - np.mean(objectives, axis=0)) ** 2, axis=1)\n        selected_idx = np.argmax(variance_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with edge exchange for multi-objective optimization\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Ensure indices are valid and different\n    if i == j or k == l or i == k or j == l:\n        return new_solution\n\n    # Perform 2-opt swap (for first objective)\n    new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Perform edge exchange (for other objectives)\n    if k < l:\n        new_solution[k:l] = np.flip(new_solution[k:l])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5658910937453305,
            2.2785708785057066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    total_variance = np.sum(objective_variance)\n\n    # If all solutions have similar objectives, select a random one\n    if total_variance < 1e-6:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        # Select solutions with high variance (more potential for improvement)\n        variance_scores = np.sum((objectives - np.mean(objectives, axis=0)) ** 2, axis=1)\n        selected_idx = np.argmax(variance_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with edge exchange for multi-objective optimization\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Ensure indices are valid and different\n    if i == j or k == l or i == k or j == l:\n        return new_solution\n\n    # Perform 2-opt swap (for first objective)\n    new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Perform edge exchange (for other objectives)\n    if k < l:\n        new_solution[k:l] = np.flip(new_solution[k:l])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 199,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to find less dominant solutions\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list (not too good, not too bad)\n        selected_idx = len(sorted_solutions) // 2\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 2-opt move with objective-aware selection\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate the current and potential new segments\n        current_segments = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        new_segments = [\n            (new_solution[i-1], new_solution[j-1]),\n            (new_solution[i], new_solution[j])\n        ]\n\n        # Calculate the change in objectives\n        delta = [\n            sum(distance_matrix_1[new_segments[k][0], new_segments[k][1]] - distance_matrix_1[current_segments[k][0], current_segments[k][1]] for k in range(2)),\n            sum(distance_matrix_2[new_segments[k][0], new_segments[k][1]] - distance_matrix_2[current_segments[k][0], current_segments[k][1]] for k in range(2)),\n            sum(distance_matrix_3[new_segments[k][0], new_segments[k][1]] - distance_matrix_3[current_segments[k][0], current_segments[k][1]] for k in range(2))\n        ]\n\n        # Accept the move if it improves at least one objective\n        if any(d < 0 for d in delta):\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # If no improvement, try a 3-opt move\n            a, b, c = np.random.choice(n, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n\n            # Evaluate the current and potential new segments\n            current_segments_3opt = [\n                (new_solution[a-1], new_solution[a]),\n                (new_solution[b-1], new_solution[b]),\n                (new_solution[c-1], new_solution[c])\n            ]\n            new_segments_3opt = [\n                (new_solution[a-1], new_solution[b-1]),\n                (new_solution[a], new_solution[c-1]),\n                (new_solution[b], new_solution[c])\n            ]\n\n            # Calculate the change in objectives\n            delta_3opt = [\n                sum(distance_matrix_1[new_segments_3opt[k][0], new_segments_3opt[k][1]] - distance_matrix_1[current_segments_3opt[k][0], current_segments_3opt[k][1]] for k in range(3)),\n                sum(distance_matrix_2[new_segments_3opt[k][0], new_segments_3opt[k][1]] - distance_matrix_2[current_segments_3opt[k][0], current_segments_3opt[k][1]] for k in range(3)),\n                sum(distance_matrix_3[new_segments_3opt[k][0], new_segments_3opt[k][1]] - distance_matrix_3[current_segments_3opt[k][0], current_segments_3opt[k][1]] for k in range(3))\n            ]\n\n            # Accept the move if it improves at least one objective\n            if any(d < 0 for d in delta_3opt):\n                # Perform the 3-opt move\n                new_solution[a:b] = new_solution[a:b][::-1]\n                new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7013397751112453,
            1.8187835693359375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to find less dominant solutions\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list (not too good, not too bad)\n        selected_idx = len(sorted_solutions) // 2\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 2-opt move with objective-aware selection\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate the current and potential new segments\n        current_segments = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        new_segments = [\n            (new_solution[i-1], new_solution[j-1]),\n            (new_solution[i], new_solution[j])\n        ]\n\n        # Calculate the change in objectives\n        delta = [\n            sum(distance_matrix_1[new_segments[k][0], new_segments[k][1]] - distance_matrix_1[current_segments[k][0], current_segments[k][1]] for k in range(2)),\n            sum(distance_matrix_2[new_segments[k][0], new_segments[k][1]] - distance_matrix_2[current_segments[k][0], current_segments[k][1]] for k in range(2)),\n            sum(distance_matrix_3[new_segments[k][0], new_segments[k][1]] - distance_matrix_3[current_segments[k][0], current_segments[k][1]] for k in range(2))\n        ]\n\n        # Accept the move if it improves at least one objective\n        if any(d < 0 for d in delta):\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # If no improvement, try a 3-opt move\n            a, b, c = np.random.choice(n, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n\n            # Evaluate the current and potential new segments\n            current_segments_3opt = [\n                (new_solution[a-1], new_solution[a]),\n                (new_solution[b-1], new_solution[b]),\n                (new_solution[c-1], new_solution[c])\n            ]\n            new_segments_3opt = [\n                (new_solution[a-1], new_solution[b-1]),\n                (new_solution[a], new_solution[c-1]),\n                (new_solution[b], new_solution[c])\n            ]\n\n            # Calculate the change in objectives\n            delta_3opt = [\n                sum(distance_matrix_1[new_segments_3opt[k][0], new_segments_3opt[k][1]] - distance_matrix_1[current_segments_3opt[k][0], current_segments_3opt[k][1]] for k in range(3)),\n                sum(distance_matrix_2[new_segments_3opt[k][0], new_segments_3opt[k][1]] - distance_matrix_2[current_segments_3opt[k][0], current_segments_3opt[k][1]] for k in range(3)),\n                sum(distance_matrix_3[new_segments_3opt[k][0], new_segments_3opt[k][1]] - distance_matrix_3[current_segments_3opt[k][0], current_segments_3opt[k][1]] for k in range(3))\n            ]\n\n            # Accept the move if it improves at least one objective\n            if any(d < 0 for d in delta_3opt):\n                # Perform the 3-opt move\n                new_solution[a:b] = new_solution[a:b][::-1]\n                new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 200,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    variances = [np.var([obj[i] for _, obj in archive]) for i in range(3)]\n    selected_idx = np.argmax(variances)\n    candidates = sorted(archive, key=lambda x: x[1][selected_idx], reverse=True)\n    selected_solution = candidates[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with highest variance\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that improve at least one objective\n    for _ in range(2):  # Limit the number of swaps to avoid excessive computation\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new objectives\n        def calculate_objective(sol, dist_matrix):\n            total = 0\n            for k in range(n):\n                total += dist_matrix[sol[k], sol[(k+1)%n]]\n            return total\n\n        new_obj1 = calculate_objective(temp_solution, distance_matrix_1)\n        new_obj2 = calculate_objective(temp_solution, distance_matrix_2)\n        new_obj3 = calculate_objective(temp_solution, distance_matrix_3)\n\n        old_obj1 = calculate_objective(new_solution, distance_matrix_1)\n        old_obj2 = calculate_objective(new_solution, distance_matrix_2)\n        old_obj3 = calculate_objective(new_solution, distance_matrix_3)\n\n        # Accept if at least one objective improves\n        if (new_obj1 < old_obj1) or (new_obj2 < old_obj2) or (new_obj3 < old_obj3):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6825657881676784,
            2.0101043701171877
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    variances = [np.var([obj[i] for _, obj in archive]) for i in range(3)]\n    selected_idx = np.argmax(variances)\n    candidates = sorted(archive, key=lambda x: x[1][selected_idx], reverse=True)\n    selected_solution = candidates[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with highest variance\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that improve at least one objective\n    for _ in range(2):  # Limit the number of swaps to avoid excessive computation\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new objectives\n        def calculate_objective(sol, dist_matrix):\n            total = 0\n            for k in range(n):\n                total += dist_matrix[sol[k], sol[(k+1)%n]]\n            return total\n\n        new_obj1 = calculate_objective(temp_solution, distance_matrix_1)\n        new_obj2 = calculate_objective(temp_solution, distance_matrix_2)\n        new_obj3 = calculate_objective(temp_solution, distance_matrix_3)\n\n        old_obj1 = calculate_objective(new_solution, distance_matrix_1)\n        old_obj2 = calculate_objective(new_solution, distance_matrix_2)\n        old_obj3 = calculate_objective(new_solution, distance_matrix_3)\n\n        # Accept if at least one objective improves\n        if (new_obj1 < old_obj1) or (new_obj2 < old_obj2) or (new_obj3 < old_obj3):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 201,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and new objective values for each space\n        current_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        new_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        # Accept if at least one objective improves\n        if any(new < current for new, current in zip(new_obj, current_obj)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Additional objective-aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate the change in objectives\n        delta_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n            distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n            distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n            distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        # Accept if at least one objective improves\n        if any(d < 0 for d in delta_obj):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7963132739834744,
            1.890860915184021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and new objective values for each space\n        current_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        new_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        # Accept if at least one objective improves\n        if any(new < current for new, current in zip(new_obj, current_obj)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Additional objective-aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate the change in objectives\n        delta_obj = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n            distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n            distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n            distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        # Accept if at least one objective improves\n        if any(d < 0 for d in delta_obj):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 202,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move (swap edges)\n    if i + 1 < j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Objective-aware swap: find nodes that improve the worst objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    worst_nodes = np.argsort([sum([distance_matrix_1[new_solution[k]][new_solution[k+1]],\n                                   distance_matrix_2[new_solution[k]][new_solution[k+1]],\n                                   distance_matrix_3[new_solution[k]][new_solution[k+1]]])\n                              for k in range(n-1)])[-3:]\n\n    if len(worst_nodes) > 1:\n        a, b = sorted(np.random.choice(worst_nodes, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5664032028064281,
            1.7520813703536988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move (swap edges)\n    if i + 1 < j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Objective-aware swap: find nodes that improve the worst objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    worst_nodes = np.argsort([sum([distance_matrix_1[new_solution[k]][new_solution[k+1]],\n                                   distance_matrix_2[new_solution[k]][new_solution[k+1]],\n                                   distance_matrix_3[new_solution[k]][new_solution[k+1]]])\n                              for k in range(n-1)])[-3:]\n\n    if len(worst_nodes) > 1:\n        a, b = sorted(np.random.choice(worst_nodes, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 203,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly but biased towards worse solutions)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + sum(obj)) for _, obj in archive],  # Higher weight for worse solutions\n        k=1\n    )[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining multiple operators\n    operator = random.choice(['2opt', 'swap', 'reinsertion'])\n\n    if operator == '2opt':\n        # Randomly select two edges to reverse\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'swap':\n        # Randomly swap two nodes\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'reinsertion':\n        # Randomly select a node and reinsert it at a different position\n        i = random.randint(0, len(new_solution) - 1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.823881911791171,
            1.691652762889862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly but biased towards worse solutions)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + sum(obj)) for _, obj in archive],  # Higher weight for worse solutions\n        k=1\n    )[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining multiple operators\n    operator = random.choice(['2opt', 'swap', 'reinsertion'])\n\n    if operator == '2opt':\n        # Randomly select two edges to reverse\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'swap':\n        # Randomly swap two nodes\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'reinsertion':\n        # Randomly select a node and reinsert it at a different position\n        i = random.randint(0, len(new_solution) - 1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 204,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (here, we select the one with the highest sum of objectives)\n    archive_with_scores = [(sol, obj, sum(obj)) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: -x[2])\n    base_solution = archive_with_scores[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    # 1. Randomly choose one of three operations: 2-opt, insertion, or swap\n    operation = np.random.choice(['2opt', 'insertion', 'swap'])\n\n    if operation == '2opt':\n        # Perform 2-opt on a random segment\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operation == 'insertion':\n        # Perform insertion of a random node to a new position\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    elif operation == 'swap':\n        # Perform a swap between two random nodes\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n    return new_solution\n\n",
        "score": [
            -0.6611401997879034,
            1.4731202125549316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (here, we select the one with the highest sum of objectives)\n    archive_with_scores = [(sol, obj, sum(obj)) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: -x[2])\n    base_solution = archive_with_scores[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    # 1. Randomly choose one of three operations: 2-opt, insertion, or swap\n    operation = np.random.choice(['2opt', 'insertion', 'swap'])\n\n    if operation == '2opt':\n        # Perform 2-opt on a random segment\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operation == 'insertion':\n        # Perform insertion of a random node to a new position\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    elif operation == 'swap':\n        # Perform a swap between two random nodes\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 205,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here we select a solution with the highest average objective value\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj) / len(obj) for obj in objectives]\n    selected_idx = np.argmax(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply a 2-opt move to reduce the worst objective\n    worst_obj_idx = np.argmax(archive[selected_idx][1])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_idx]\n\n    # Find the best 2-opt move for the worst objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            # Calculate the change in distance for the worst objective\n            old_dist = (distance_matrices[new_solution[i], new_solution[i+1]] +\n                        distance_matrices[new_solution[j], new_solution[j+1]])\n            new_dist = (distance_matrices[new_solution[i], new_solution[j]] +\n                        distance_matrices[new_solution[i+1], new_solution[j+1]])\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        # Apply the 2-opt move\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Then apply a multi-objective aware swap to improve other objectives\n    # Select two random positions and swap them, but consider the impact on all objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Calculate the change in all objectives\n    old_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_1[new_solution[j-1], new_solution[j]])\n    new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j-1], new_solution[i]])\n\n    old_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_2[new_solution[j-1], new_solution[j]])\n    new_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n    old_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_3[new_solution[j-1], new_solution[j]])\n    new_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[j-1], new_solution[i]])\n\n    # Accept the swap if it improves at least one objective\n    if (new_dist1 < old_dist1) or (new_dist2 < old_dist2) or (new_dist3 < old_dist3):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6980292402288676,
            2.3203458905220034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here we select a solution with the highest average objective value\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj) / len(obj) for obj in objectives]\n    selected_idx = np.argmax(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply a 2-opt move to reduce the worst objective\n    worst_obj_idx = np.argmax(archive[selected_idx][1])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_idx]\n\n    # Find the best 2-opt move for the worst objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            # Calculate the change in distance for the worst objective\n            old_dist = (distance_matrices[new_solution[i], new_solution[i+1]] +\n                        distance_matrices[new_solution[j], new_solution[j+1]])\n            new_dist = (distance_matrices[new_solution[i], new_solution[j]] +\n                        distance_matrices[new_solution[i+1], new_solution[j+1]])\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        # Apply the 2-opt move\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Then apply a multi-objective aware swap to improve other objectives\n    # Select two random positions and swap them, but consider the impact on all objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Calculate the change in all objectives\n    old_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_1[new_solution[j-1], new_solution[j]])\n    new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j-1], new_solution[i]])\n\n    old_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_2[new_solution[j-1], new_solution[j]])\n    new_dist2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n    old_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_3[new_solution[j-1], new_solution[j]])\n    new_dist3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[j-1], new_solution[i]])\n\n    # Accept the swap if it improves at least one objective\n    if (new_dist1 < old_dist1) or (new_dist2 < old_dist2) or (new_dist3 < old_dist3):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 206,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    diversity = np.std(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n_nodes = len(new_solution)\n    if n_nodes < 4:\n        # For small instances, use a simple swap\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, use a combination of 2-opt and random segment insertion\n        if random.random() < 0.5:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Random segment insertion\n            i, j, k = sorted(random.sample(range(n_nodes), 3))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility by repairing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n_nodes or np.any(counts != 1):\n        # If not valid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5479438951764075,
            2.3962624311447143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    diversity = np.std(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n_nodes = len(new_solution)\n    if n_nodes < 4:\n        # For small instances, use a simple swap\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, use a combination of 2-opt and random segment insertion\n        if random.random() < 0.5:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Random segment insertion\n            i, j, k = sorted(random.sample(range(n_nodes), 3))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility by repairing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n_nodes or np.any(counts != 1):\n        # If not valid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 207,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(obj_variance))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    for _ in range(5):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Standard 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify the worst edge in any objective space\n        worst_edge = -1\n        max_reduction = -1\n        for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            current_cost = (dist_matrix[new_solution[i-1], new_solution[i]] +\n                            dist_matrix[new_solution[j], new_solution[(j+1)%n]])\n            new_cost = (dist_matrix[new_solution[i-1], new_solution[j]] +\n                        dist_matrix[new_solution[i], new_solution[(j+1)%n]])\n            reduction = current_cost - new_cost\n            if reduction > max_reduction:\n                max_reduction = reduction\n                worst_edge = obj_idx\n\n        # If improvement found, keep the swap\n        if worst_edge != -1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Also consider a random swap to maintain diversity\n        if np.random.random() < 0.2:\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7275444012217164,
            2.4408207654953005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(obj_variance))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    for _ in range(5):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Standard 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify the worst edge in any objective space\n        worst_edge = -1\n        max_reduction = -1\n        for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            current_cost = (dist_matrix[new_solution[i-1], new_solution[i]] +\n                            dist_matrix[new_solution[j], new_solution[(j+1)%n]])\n            new_cost = (dist_matrix[new_solution[i-1], new_solution[j]] +\n                        dist_matrix[new_solution[i], new_solution[(j+1)%n]])\n            reduction = current_cost - new_cost\n            if reduction > max_reduction:\n                max_reduction = reduction\n                worst_edge = obj_idx\n\n        # If improvement found, keep the swap\n        if worst_edge != -1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Also consider a random swap to maintain diversity\n        if np.random.random() < 0.2:\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 208,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-specific perturbations\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 2-opt with objective-aware edge selection\n        # First, identify edges that are long in at least one objective space\n        long_edges = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            if (distance_matrix_1[u, v] > np.mean(distance_matrix_1) or\n                distance_matrix_2[u, v] > np.mean(distance_matrix_2) or\n                distance_matrix_3[u, v] > np.mean(distance_matrix_3)):\n                long_edges.append((i, (i+1)%n))\n\n        if long_edges:\n            # Select a random long edge to optimize\n            edge_idx = np.random.choice(len(long_edges))\n            a, b = long_edges[edge_idx]\n\n            # Try to reconnect the tour in a way that improves at least one objective\n            for _ in range(10):  # Limited attempts to find improvement\n                c, d = np.random.choice(n, 2, replace=False)\n                if abs(c - d) < 2:  # Ensure we don't create overlapping segments\n                    continue\n\n                # Create two new edges and check if they improve any objective\n                new_edges = [(new_solution[a], new_solution[d]),\n                            (new_solution[c], new_solution[b])]\n                old_edges = [(new_solution[a], new_solution[b]),\n                            (new_solution[c], new_solution[d])]\n\n                # Calculate potential improvement\n                improvement = 0\n                for (u, v), (x, y) in zip(new_edges, old_edges):\n                    improvement += (distance_matrix_1[u, v] - distance_matrix_1[x, y] +\n                                  distance_matrix_2[u, v] - distance_matrix_2[x, y] +\n                                  distance_matrix_3[u, v] - distance_matrix_3[x, y])\n\n                if improvement < 0:  # If we improve at least one objective\n                    # Perform the 2-opt move\n                    if c > d:\n                        c, d = d, c\n                    new_solution[c:d] = new_solution[c:d][::-1]\n                    break\n        else:\n            # If no long edges found, perform a random 3-opt move\n            i, j, k = np.random.choice(n, 3, replace=False)\n            segment = sorted([i, j, k])\n            new_solution[segment[0]:segment[2]] = new_solution[segment[0]:segment[2]][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7400740231406764,
            1.84344140291214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-specific perturbations\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 2-opt with objective-aware edge selection\n        # First, identify edges that are long in at least one objective space\n        long_edges = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            if (distance_matrix_1[u, v] > np.mean(distance_matrix_1) or\n                distance_matrix_2[u, v] > np.mean(distance_matrix_2) or\n                distance_matrix_3[u, v] > np.mean(distance_matrix_3)):\n                long_edges.append((i, (i+1)%n))\n\n        if long_edges:\n            # Select a random long edge to optimize\n            edge_idx = np.random.choice(len(long_edges))\n            a, b = long_edges[edge_idx]\n\n            # Try to reconnect the tour in a way that improves at least one objective\n            for _ in range(10):  # Limited attempts to find improvement\n                c, d = np.random.choice(n, 2, replace=False)\n                if abs(c - d) < 2:  # Ensure we don't create overlapping segments\n                    continue\n\n                # Create two new edges and check if they improve any objective\n                new_edges = [(new_solution[a], new_solution[d]),\n                            (new_solution[c], new_solution[b])]\n                old_edges = [(new_solution[a], new_solution[b]),\n                            (new_solution[c], new_solution[d])]\n\n                # Calculate potential improvement\n                improvement = 0\n                for (u, v), (x, y) in zip(new_edges, old_edges):\n                    improvement += (distance_matrix_1[u, v] - distance_matrix_1[x, y] +\n                                  distance_matrix_2[u, v] - distance_matrix_2[x, y] +\n                                  distance_matrix_3[u, v] - distance_matrix_3[x, y])\n\n                if improvement < 0:  # If we improve at least one objective\n                    # Perform the 2-opt move\n                    if c > d:\n                        c, d = d, c\n                    new_solution[c:d] = new_solution[c:d][::-1]\n                    break\n        else:\n            # If no long edges found, perform a random 3-opt move\n            i, j, k = np.random.choice(n, 3, replace=False)\n            segment = sorted([i, j, k])\n            new_solution[segment[0]:segment[2]] = new_solution[segment[0]:segment[2]][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 209,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-way exchange\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Apply 2-opt between i and j\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-way exchange: move node at k to position between i and j\n    if i < k < j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(i, j)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5967482074296288,
            1.2820085644721986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-way exchange\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Apply 2-opt between i and j\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-way exchange: move node at k to position between i and j\n    if i < k < j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(i, j)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 210,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest total objective value\n    # as it likely has room for improvement in multiple objectives\n    objectives = [obj for _, obj in archive]\n    total_objectives = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(total_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: a combination of 2-opt and edge exchange\n    # First, perform a 2-opt move\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an edge exchange move to improve multiple objectives\n    # Select two random edges to exchange\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    c, d = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Ensure the exchange maintains feasibility\n    if a != c and a != d and b != c and b != d:\n        # Create a new solution with the exchange\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[c] = temp_solution[c], temp_solution[a]\n        temp_solution[b], temp_solution[d] = temp_solution[d], temp_solution[b]\n\n        # Evaluate the new solution across all objectives\n        def calculate_objective(solution):\n            obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (obj1, obj2, obj3)\n\n        current_obj = calculate_objective(new_solution)\n        temp_obj = calculate_objective(temp_solution)\n\n        # Accept the exchange if it improves at least one objective\n        if any(temp < current for temp, current in zip(temp_obj, current_obj)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6518661754161382,
            1.2326517701148987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest total objective value\n    # as it likely has room for improvement in multiple objectives\n    objectives = [obj for _, obj in archive]\n    total_objectives = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(total_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: a combination of 2-opt and edge exchange\n    # First, perform a 2-opt move\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an edge exchange move to improve multiple objectives\n    # Select two random edges to exchange\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    c, d = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Ensure the exchange maintains feasibility\n    if a != c and a != d and b != c and b != d:\n        # Create a new solution with the exchange\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[c] = temp_solution[c], temp_solution[a]\n        temp_solution[b], temp_solution[d] = temp_solution[d], temp_solution[b]\n\n        # Evaluate the new solution across all objectives\n        def calculate_objective(solution):\n            obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (obj1, obj2, obj3)\n\n        current_obj = calculate_objective(new_solution)\n        temp_obj = calculate_objective(temp_solution)\n\n        # Accept the exchange if it improves at least one objective\n        if any(temp < current for temp, current in zip(temp_obj, current_obj)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 211,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    candidate = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware perturbation\n    n = len(candidate)\n    new_solution = candidate.copy()\n\n    # Perform 2-opt move\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation: swap nodes based on their positions in different objective spaces\n    if np.random.random() < 0.3:  # 30% chance for perturbation\n        # Select two nodes based on their relative positions in the three objective spaces\n        node_a, node_b = np.random.choice(range(n), 2, replace=False)\n        idx_a, idx_b = np.where(new_solution == node_a)[0][0], np.where(new_solution == node_b)[0][0]\n\n        # Calculate relative positions in each objective space\n        pos_a = [instance[node_a, :2], instance[node_a, 2:4], instance[node_a, 4:6]]\n        pos_b = [instance[node_b, :2], instance[node_b, 2:4], instance[node_b, 4:6]]\n\n        # Determine if swapping would improve at least one objective\n        delta_costs = []\n        for k in range(3):\n            prev_cost = (distance_matrix_1[new_solution[idx_a-1], new_solution[idx_a]] +\n                         distance_matrix_1[new_solution[idx_b-1], new_solution[idx_b]])\n            new_cost = (distance_matrix_1[new_solution[idx_a-1], new_solution[idx_b]] +\n                        distance_matrix_1[new_solution[idx_b-1], new_solution[idx_a]])\n            delta_costs.append(new_cost - prev_cost)\n\n        # Perform swap if it improves at least one objective\n        if any(d < 0 for d in delta_costs):\n            new_solution[idx_a], new_solution[idx_b] = new_solution[idx_b], new_solution[idx_a]\n\n    return new_solution\n\n",
        "score": [
            -0.6895843974770939,
            1.702975332736969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    candidate = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware perturbation\n    n = len(candidate)\n    new_solution = candidate.copy()\n\n    # Perform 2-opt move\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation: swap nodes based on their positions in different objective spaces\n    if np.random.random() < 0.3:  # 30% chance for perturbation\n        # Select two nodes based on their relative positions in the three objective spaces\n        node_a, node_b = np.random.choice(range(n), 2, replace=False)\n        idx_a, idx_b = np.where(new_solution == node_a)[0][0], np.where(new_solution == node_b)[0][0]\n\n        # Calculate relative positions in each objective space\n        pos_a = [instance[node_a, :2], instance[node_a, 2:4], instance[node_a, 4:6]]\n        pos_b = [instance[node_b, :2], instance[node_b, 2:4], instance[node_b, 4:6]]\n\n        # Determine if swapping would improve at least one objective\n        delta_costs = []\n        for k in range(3):\n            prev_cost = (distance_matrix_1[new_solution[idx_a-1], new_solution[idx_a]] +\n                         distance_matrix_1[new_solution[idx_b-1], new_solution[idx_b]])\n            new_cost = (distance_matrix_1[new_solution[idx_a-1], new_solution[idx_b]] +\n                        distance_matrix_1[new_solution[idx_b-1], new_solution[idx_a]])\n            delta_costs.append(new_cost - prev_cost)\n\n        # Perform swap if it improves at least one objective\n        if any(d < 0 for d in delta_costs):\n            new_solution[idx_a], new_solution[idx_b] = new_solution[idx_b], new_solution[idx_a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 212,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., higher cost in at least one objective)\n    objectives = np.array([obj for _, obj in archive])\n    max_costs = np.max(objectives, axis=0)\n    normalized_costs = objectives / max_costs\n    improvement_potential = np.mean(normalized_costs, axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge selection: choose edges with high cost in any objective\n    def edge_cost(i, j):\n        return (distance_matrix_1[i, j] + distance_matrix_2[i, j] + distance_matrix_3[i, j]) / 3\n\n    # Find the worst edge in the current solution\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        cost = edge_cost(a, b)\n        if cost > worst_edge_cost:\n            worst_edge_cost = cost\n            worst_edge_idx = i\n\n    # Apply 2-opt to the worst edge\n    if worst_edge_idx != -1:\n        i, j = worst_edge_idx, (worst_edge_idx + 1) % n\n        a, b = new_solution[i], new_solution[j]\n\n        # Find the best candidate to swap with\n        best_candidate = -1\n        best_improvement = 0\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n            c = new_solution[k]\n            # Calculate improvement for both possible swaps\n            improvement1 = (edge_cost(a, c) + edge_cost(b, new_solution[(k+1)%n])) - (edge_cost(a, b) + edge_cost(c, new_solution[(k+1)%n]))\n            improvement2 = (edge_cost(b, c) + edge_cost(a, new_solution[(k+1)%n])) - (edge_cost(a, b) + edge_cost(c, new_solution[(k+1)%n]))\n            if improvement1 > best_improvement:\n                best_improvement = improvement1\n                best_candidate = k\n            if improvement2 > best_improvement:\n                best_improvement = improvement2\n                best_candidate = k\n\n        if best_candidate != -1:\n            # Perform the swap that gives the best improvement\n            if best_improvement > 0:\n                k = best_candidate\n                if (k - i) % n < (j - k) % n:\n                    # Reverse the segment between i and k\n                    new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n                else:\n                    # Reverse the segment between k and j\n                    new_solution[k+1:j+1] = new_solution[k+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7315374644145336,
            1.679796302318573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., higher cost in at least one objective)\n    objectives = np.array([obj for _, obj in archive])\n    max_costs = np.max(objectives, axis=0)\n    normalized_costs = objectives / max_costs\n    improvement_potential = np.mean(normalized_costs, axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge selection: choose edges with high cost in any objective\n    def edge_cost(i, j):\n        return (distance_matrix_1[i, j] + distance_matrix_2[i, j] + distance_matrix_3[i, j]) / 3\n\n    # Find the worst edge in the current solution\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        cost = edge_cost(a, b)\n        if cost > worst_edge_cost:\n            worst_edge_cost = cost\n            worst_edge_idx = i\n\n    # Apply 2-opt to the worst edge\n    if worst_edge_idx != -1:\n        i, j = worst_edge_idx, (worst_edge_idx + 1) % n\n        a, b = new_solution[i], new_solution[j]\n\n        # Find the best candidate to swap with\n        best_candidate = -1\n        best_improvement = 0\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n            c = new_solution[k]\n            # Calculate improvement for both possible swaps\n            improvement1 = (edge_cost(a, c) + edge_cost(b, new_solution[(k+1)%n])) - (edge_cost(a, b) + edge_cost(c, new_solution[(k+1)%n]))\n            improvement2 = (edge_cost(b, c) + edge_cost(a, new_solution[(k+1)%n])) - (edge_cost(a, b) + edge_cost(c, new_solution[(k+1)%n]))\n            if improvement1 > best_improvement:\n                best_improvement = improvement1\n                best_candidate = k\n            if improvement2 > best_improvement:\n                best_improvement = improvement2\n                best_candidate = k\n\n        if best_candidate != -1:\n            # Perform the swap that gives the best improvement\n            if best_improvement > 0:\n                k = best_candidate\n                if (k - i) % n < (j - k) % n:\n                    # Reverse the segment between i and k\n                    new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n                else:\n                    # Reverse the segment between k and j\n                    new_solution[k+1:j+1] = new_solution[k+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 213,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives to prioritize solutions with lower values\n    normalized_obj = objectives / (objectives.max(axis=0) + 1e-10)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective aware perturbation\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select a segment to perturb (2-opt)\n    i, j = sorted(random.sample(range(n_nodes - 1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    # Multi-objective aware perturbation: swap nodes based on objective improvement\n    for _ in range(2):  # Limit perturbation to prevent excessive changes\n        a, b = random.sample(range(n_nodes), 2)\n        if a == b:\n            continue\n\n        # Calculate current and new objective values\n        current_obj = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        new_obj = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        # Accept swap if it improves at least one objective\n        if any(new < current for new, current in zip(new_obj, current_obj)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7303638639320387,
            1.6822315335273743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives to prioritize solutions with lower values\n    normalized_obj = objectives / (objectives.max(axis=0) + 1e-10)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective aware perturbation\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select a segment to perturb (2-opt)\n    i, j = sorted(random.sample(range(n_nodes - 1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    # Multi-objective aware perturbation: swap nodes based on objective improvement\n    for _ in range(2):  # Limit perturbation to prevent excessive changes\n        a, b = random.sample(range(n_nodes), 2)\n        if a == b:\n            continue\n\n        # Calculate current and new objective values\n        current_obj = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        new_obj = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        # Accept swap if it improves at least one objective\n        if any(new < current for new, current in zip(new_obj, current_obj)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 214,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on their objective values (lower is better)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select top 20% of solutions for consideration\n    top_k = max(1, len(archive_sorted) // 5)\n    candidates = archive_sorted[:top_k]\n\n    # Select a random candidate\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective aware local search\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a more sophisticated operator\n        # Choose between 2-opt, 3-opt, or a custom multi-objective operator\n        operator = random.choice(['2opt', '3opt', 'multi_obj_opt'])\n\n        if operator == '2opt':\n            # 2-opt: reverse a segment between two random points\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == '3opt':\n            # 3-opt: reverse three segments to reconnect the tour\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        else:  # multi_obj_opt\n            # Custom operator that considers all three objectives\n            # Select three segments and try to improve all objectives simultaneously\n            i, j, k = sorted(random.sample(range(n), 3))\n\n            # Calculate current costs\n            def calculate_cost(solution):\n                cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n))\n                cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n))\n                cost3 = sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(n))\n                return cost1, cost2, cost3\n\n            current_cost = calculate_cost(new_solution)\n\n            # Try different configurations\n            for _ in range(3):\n                temp_solution = new_solution.copy()\n                # Randomly shuffle the selected segment\n                temp_solution[i:j+1] = np.random.permutation(temp_solution[i:j+1])\n                temp_cost = calculate_cost(temp_solution)\n\n                # If all objectives are better or equal, accept the change\n                if all(temp_cost[obj] <= current_cost[obj] for obj in range(3)):\n                    new_solution = temp_solution\n                    current_cost = temp_cost\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7372902866292266,
            2.562664341926575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on their objective values (lower is better)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select top 20% of solutions for consideration\n    top_k = max(1, len(archive_sorted) // 5)\n    candidates = archive_sorted[:top_k]\n\n    # Select a random candidate\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective aware local search\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a more sophisticated operator\n        # Choose between 2-opt, 3-opt, or a custom multi-objective operator\n        operator = random.choice(['2opt', '3opt', 'multi_obj_opt'])\n\n        if operator == '2opt':\n            # 2-opt: reverse a segment between two random points\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == '3opt':\n            # 3-opt: reverse three segments to reconnect the tour\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        else:  # multi_obj_opt\n            # Custom operator that considers all three objectives\n            # Select three segments and try to improve all objectives simultaneously\n            i, j, k = sorted(random.sample(range(n), 3))\n\n            # Calculate current costs\n            def calculate_cost(solution):\n                cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n))\n                cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n))\n                cost3 = sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(n))\n                return cost1, cost2, cost3\n\n            current_cost = calculate_cost(new_solution)\n\n            # Try different configurations\n            for _ in range(3):\n                temp_solution = new_solution.copy()\n                # Randomly shuffle the selected segment\n                temp_solution[i:j+1] = np.random.permutation(temp_solution[i:j+1])\n                temp_cost = calculate_cost(temp_solution)\n\n                # If all objectives are better or equal, accept the change\n                if all(temp_cost[obj] <= current_cost[obj] for obj in range(3)):\n                    new_solution = temp_solution\n                    current_cost = temp_cost\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 215,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the archive (not too good, not too bad)\n        candidate_index = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[candidate_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select two different positions\n    i, j = random.sample(range(len(new_solution)), 2)\n\n    # 2. Apply a 2-opt move (swap edges)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3. Apply a node swap (local improvement)\n    # Find the node with the highest total cost in its current position\n    total_costs = np.zeros(len(new_solution))\n    for k in range(len(new_solution)):\n        node = new_solution[k]\n        prev_node = new_solution[k-1]\n        next_node = new_solution[(k+1) % len(new_solution)]\n        total_costs[k] = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                          distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n\n    # Find the worst node and swap it with a random neighbor\n    worst_node_index = np.argmax(total_costs)\n    worst_node = new_solution[worst_node_index]\n    neighbors = [new_solution[(worst_node_index - 1) % len(new_solution)],\n                 new_solution[(worst_node_index + 1) % len(new_solution)]]\n    neighbor_to_swap = random.choice(neighbors)\n\n    # Swap the worst node with the selected neighbor\n    neighbor_index = np.where(new_solution == neighbor_to_swap)[0][0]\n    new_solution[worst_node_index], new_solution[neighbor_index] = new_solution[neighbor_index], new_solution[worst_node_index]\n\n    return new_solution\n\n",
        "score": [
            -0.6691865034661337,
            1.598706591129303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the archive (not too good, not too bad)\n        candidate_index = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[candidate_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select two different positions\n    i, j = random.sample(range(len(new_solution)), 2)\n\n    # 2. Apply a 2-opt move (swap edges)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3. Apply a node swap (local improvement)\n    # Find the node with the highest total cost in its current position\n    total_costs = np.zeros(len(new_solution))\n    for k in range(len(new_solution)):\n        node = new_solution[k]\n        prev_node = new_solution[k-1]\n        next_node = new_solution[(k+1) % len(new_solution)]\n        total_costs[k] = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                          distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n\n    # Find the worst node and swap it with a random neighbor\n    worst_node_index = np.argmax(total_costs)\n    worst_node = new_solution[worst_node_index]\n    neighbors = [new_solution[(worst_node_index - 1) % len(new_solution)],\n                 new_solution[(worst_node_index + 1) % len(new_solution)]]\n    neighbor_to_swap = random.choice(neighbors)\n\n    # Swap the worst node with the selected neighbor\n    neighbor_index = np.where(new_solution == neighbor_to_swap)[0][0]\n    new_solution[worst_node_index], new_solution[neighbor_index] = new_solution[neighbor_index], new_solution[worst_node_index]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 216,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective value)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # First, perform a 2-opt move considering all three objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if i != 0 and j != n-1:\n        # Evaluate the move across all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        if new_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a 3-opt move considering all three objectives\n    i, j, k = sorted(random.sample(range(n), 3))\n    if i != 0 and j != i+1 and k != j+1 and k != n-1:\n        # Evaluate all possible 3-opt moves\n        moves = [\n            (new_solution[:i+1], new_solution[i+1:j+1][::-1], new_solution[j+1:k+1], new_solution[k+1:]),\n            (new_solution[:i+1], new_solution[j+1:k+1][::-1], new_solution[i+1:j+1], new_solution[k+1:]),\n            (new_solution[:i+1], new_solution[i+1:j+1], new_solution[k+1:][::-1], new_solution[j+1:k+1])\n        ]\n\n        best_move = None\n        best_cost = float('inf')\n\n        for move in moves:\n            current_move_cost = 0\n            for m in range(len(move)-1):\n                segment = move[m]\n                next_segment = move[m+1]\n                if len(segment) > 0 and len(next_segment) > 0:\n                    current_move_cost += (\n                        distance_matrix_1[segment[-1], next_segment[0]] +\n                        distance_matrix_2[segment[-1], next_segment[0]] +\n                        distance_matrix_3[segment[-1], next_segment[0]]\n                    )\n\n            if current_move_cost < best_cost:\n                best_cost = current_move_cost\n                best_move = move\n\n        if best_move is not None:\n            new_solution = np.concatenate([\n                best_move[0],\n                best_move[1],\n                best_move[2],\n                best_move[3]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6012350495786556,
            4.144788527488709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective value)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # First, perform a 2-opt move considering all three objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if i != 0 and j != n-1:\n        # Evaluate the move across all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        if new_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a 3-opt move considering all three objectives\n    i, j, k = sorted(random.sample(range(n), 3))\n    if i != 0 and j != i+1 and k != j+1 and k != n-1:\n        # Evaluate all possible 3-opt moves\n        moves = [\n            (new_solution[:i+1], new_solution[i+1:j+1][::-1], new_solution[j+1:k+1], new_solution[k+1:]),\n            (new_solution[:i+1], new_solution[j+1:k+1][::-1], new_solution[i+1:j+1], new_solution[k+1:]),\n            (new_solution[:i+1], new_solution[i+1:j+1], new_solution[k+1:][::-1], new_solution[j+1:k+1])\n        ]\n\n        best_move = None\n        best_cost = float('inf')\n\n        for move in moves:\n            current_move_cost = 0\n            for m in range(len(move)-1):\n                segment = move[m]\n                next_segment = move[m+1]\n                if len(segment) > 0 and len(next_segment) > 0:\n                    current_move_cost += (\n                        distance_matrix_1[segment[-1], next_segment[0]] +\n                        distance_matrix_2[segment[-1], next_segment[0]] +\n                        distance_matrix_3[segment[-1], next_segment[0]]\n                    )\n\n            if current_move_cost < best_cost:\n                best_cost = current_move_cost\n                best_move = move\n\n        if best_move is not None:\n            new_solution = np.concatenate([\n                best_move[0],\n                best_move[1],\n                best_move[2],\n                best_move[3]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 217,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    sum_normalized = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(sum_normalized)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_size = max(2, int(np.random.uniform(0.1, 0.3) * n))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Apply 2-opt within the segment\n    i, j = np.random.choice(range(start, end), size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a 3-exchange if beneficial\n    if np.random.random() < 0.3:\n        a, b, c = np.random.choice(range(n), size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n        # Evaluate all permutations of the three nodes\n        permutations = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]])\n        ]\n        # Calculate objectives for each permutation\n        objectives = []\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[i+1]] for i in range(n-1)) + distance_matrix_1[perm[-1], perm[0]]\n            cost2 = sum(distance_matrix_2[perm[i], perm[i+1]] for i in range(n-1)) + distance_matrix_2[perm[-1], perm[0]]\n            cost3 = sum(distance_matrix_3[perm[i], perm[i+1]] for i in range(n-1)) + distance_matrix_3[perm[-1], perm[0]]\n            objectives.append((cost1, cost2, cost3))\n        # Select the best permutation based on sum of normalized objectives\n        normalized = np.array([(np.array(obj) - np.array(objectives).min(axis=0)) /\n                              (np.array(objectives).max(axis=0) - np.array(objectives).min(axis=0) + 1e-10) for obj in objectives])\n        best_perm_idx = np.argmin(normalized.sum(axis=1))\n        new_solution = permutations[best_perm_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5940232894865776,
            2.406930458545685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    sum_normalized = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(sum_normalized)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_size = max(2, int(np.random.uniform(0.1, 0.3) * n))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Apply 2-opt within the segment\n    i, j = np.random.choice(range(start, end), size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a 3-exchange if beneficial\n    if np.random.random() < 0.3:\n        a, b, c = np.random.choice(range(n), size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n        # Evaluate all permutations of the three nodes\n        permutations = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]])\n        ]\n        # Calculate objectives for each permutation\n        objectives = []\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[i+1]] for i in range(n-1)) + distance_matrix_1[perm[-1], perm[0]]\n            cost2 = sum(distance_matrix_2[perm[i], perm[i+1]] for i in range(n-1)) + distance_matrix_2[perm[-1], perm[0]]\n            cost3 = sum(distance_matrix_3[perm[i], perm[i+1]] for i in range(n-1)) + distance_matrix_3[perm[-1], perm[0]]\n            objectives.append((cost1, cost2, cost3))\n        # Select the best permutation based on sum of normalized objectives\n        normalized = np.array([(np.array(obj) - np.array(objectives).min(axis=0)) /\n                              (np.array(objectives).max(axis=0) - np.array(objectives).min(axis=0) + 1e-10) for obj in objectives])\n        best_perm_idx = np.argmin(normalized.sum(axis=1))\n        new_solution = permutations[best_perm_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 218,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already highly optimized)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best swap that improves at least one objective\n    best_improvement = 0\n    best_swap = None\n\n    for _ in range(10):  # Limit the number of trials\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        original_costs = [\n            distance_matrix_1[selected_solution[a-1], selected_solution[a]] + distance_matrix_1[selected_solution[b-1], selected_solution[b]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[a]] + distance_matrix_2[selected_solution[b-1], selected_solution[b]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[a]] + distance_matrix_3[selected_solution[b-1], selected_solution[b]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[selected_solution[a-1], selected_solution[b]] + distance_matrix_1[selected_solution[b-1], selected_solution[a]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[b]] + distance_matrix_2[selected_solution[b-1], selected_solution[a]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[b]] + distance_matrix_3[selected_solution[b-1], selected_solution[a]]\n        ]\n\n        improvement = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_swap = (a, b)\n\n    if best_swap:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5080508904193589,
            2.3514185905456544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already highly optimized)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best swap that improves at least one objective\n    best_improvement = 0\n    best_swap = None\n\n    for _ in range(10):  # Limit the number of trials\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        original_costs = [\n            distance_matrix_1[selected_solution[a-1], selected_solution[a]] + distance_matrix_1[selected_solution[b-1], selected_solution[b]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[a]] + distance_matrix_2[selected_solution[b-1], selected_solution[b]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[a]] + distance_matrix_3[selected_solution[b-1], selected_solution[b]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[selected_solution[a-1], selected_solution[b]] + distance_matrix_1[selected_solution[b-1], selected_solution[a]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[b]] + distance_matrix_2[selected_solution[b-1], selected_solution[a]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[b]] + distance_matrix_3[selected_solution[b-1], selected_solution[a]]\n        ]\n\n        improvement = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_swap = (a, b)\n\n    if best_swap:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 219,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high probability for those with better diversity or lower costs\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1/(1 + obj[0] + obj[1] + obj[2]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or path relinking\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Path relinking: combine with another random solution from archive\n        if len(archive) > 1:\n            other_idx = random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0].copy()\n            # Find common segments and relink\n            for i in range(n):\n                if new_solution[i] in other_solution:\n                    j = np.where(other_solution == new_solution[i])[0][0]\n                    # Swap segments to create a new path\n                    if j > i:\n                        new_solution[i:j+1] = other_solution[i:j+1]\n                    else:\n                        new_solution[j:i+1] = other_solution[j:i+1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if path relinking creates duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6962887948621256,
            2.907048738002777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high probability for those with better diversity or lower costs\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1/(1 + obj[0] + obj[1] + obj[2]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or path relinking\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Path relinking: combine with another random solution from archive\n        if len(archive) > 1:\n            other_idx = random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0].copy()\n            # Find common segments and relink\n            for i in range(n):\n                if new_solution[i] in other_solution:\n                    j = np.where(other_solution == new_solution[i])[0][0]\n                    # Swap segments to create a new path\n                    if j > i:\n                        new_solution[i:j+1] = other_solution[i:j+1]\n                    else:\n                        new_solution[j:i+1] = other_solution[j:i+1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if path relinking creates duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 220,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with the highest variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(objective_variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator combining 2-opt, insertion, and swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of three local search operators\n    operator_choice = np.random.randint(0, 3)\n\n    if operator_choice == 0:  # 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator_choice == 1:  # Insertion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    else:  # Swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # Fallback to simple swap if operator causes infeasibility\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4412323690238553,
            1.5672179818153382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with the highest variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(objective_variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator combining 2-opt, insertion, and swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of three local search operators\n    operator_choice = np.random.randint(0, 3)\n\n    if operator_choice == 0:  # 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator_choice == 1:  # Insertion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    else:  # Swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # Fallback to simple swap if operator causes infeasibility\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 221,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt, swap, and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose one of the three operators\n    operator = np.random.choice(['2opt', 'swap', 'insert'])\n\n    if operator == '2opt':\n        # 2-opt: reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator == 'swap':\n        # Swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # insert\n        # Insert a random node at a different position\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Validate the solution (ensure all nodes are present and unique)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7071161025027102,
            1.2586308121681213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt, swap, and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose one of the three operators\n    operator = np.random.choice(['2opt', 'swap', 'insert'])\n\n    if operator == '2opt':\n        # 2-opt: reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator == 'swap':\n        # Swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # insert\n        # Insert a random node at a different position\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Validate the solution (ensure all nodes are present and unique)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 222,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., the one with the highest sum of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_sums = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-opt-inspired move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then, perform a novel 3-opt-inspired move: reverse a segment and insert it elsewhere\n    if n > 3:\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5503455402933337,
            1.5104199409484864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., the one with the highest sum of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_sums = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-opt-inspired move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then, perform a novel 3-opt-inspired move: reverse a segment and insert it elsewhere\n    if n > 3:\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 223,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probabilistic bias towards those with lower objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.sum(objectives, axis=0, keepdims=True)\n    scores = np.prod(1 - normalized_objectives, axis=1)  # Prefer solutions with lower values in all objectives\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Apply a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Apply a node swap operation (intra-space optimization)\n    k, l = random.sample(range(1, n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Apply a cross-space optimization (tri-objective specific)\n    if n > 3:\n        # Select three random nodes and reorder them based on their positions in different spaces\n        a, b, c = random.sample(range(1, n), 3)\n        nodes = [new_solution[a], new_solution[b], new_solution[c]]\n\n        # Calculate distances in all three spaces\n        def calculate_distances(node1, node2):\n            d1 = distance_matrix_1[node1, node2]\n            d2 = distance_matrix_2[node1, node2]\n            d3 = distance_matrix_3[node1, node2]\n            return d1, d2, d3\n\n        # Find the best permutation of these three nodes across all spaces\n        permutations = [\n            (nodes[0], nodes[1], nodes[2]),\n            (nodes[0], nodes[2], nodes[1]),\n            (nodes[1], nodes[0], nodes[2]),\n            (nodes[1], nodes[2], nodes[0]),\n            (nodes[2], nodes[0], nodes[1]),\n            (nodes[2], nodes[1], nodes[0])\n        ]\n\n        best_permutation = None\n        best_score = float('inf')\n\n        for perm in permutations:\n            total_dist = 0\n            for i in range(2):\n                d1, d2, d3 = calculate_distances(perm[i], perm[i+1])\n                total_dist += d1 + d2 + d3\n            if total_dist < best_score:\n                best_score = total_dist\n                best_permutation = perm\n\n        new_solution[a], new_solution[b], new_solution[c] = best_permutation\n\n    return new_solution\n\n",
        "score": [
            -0.8115178272729706,
            1.1800277590751649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probabilistic bias towards those with lower objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.sum(objectives, axis=0, keepdims=True)\n    scores = np.prod(1 - normalized_objectives, axis=1)  # Prefer solutions with lower values in all objectives\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Apply a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Apply a node swap operation (intra-space optimization)\n    k, l = random.sample(range(1, n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Apply a cross-space optimization (tri-objective specific)\n    if n > 3:\n        # Select three random nodes and reorder them based on their positions in different spaces\n        a, b, c = random.sample(range(1, n), 3)\n        nodes = [new_solution[a], new_solution[b], new_solution[c]]\n\n        # Calculate distances in all three spaces\n        def calculate_distances(node1, node2):\n            d1 = distance_matrix_1[node1, node2]\n            d2 = distance_matrix_2[node1, node2]\n            d3 = distance_matrix_3[node1, node2]\n            return d1, d2, d3\n\n        # Find the best permutation of these three nodes across all spaces\n        permutations = [\n            (nodes[0], nodes[1], nodes[2]),\n            (nodes[0], nodes[2], nodes[1]),\n            (nodes[1], nodes[0], nodes[2]),\n            (nodes[1], nodes[2], nodes[0]),\n            (nodes[2], nodes[0], nodes[1]),\n            (nodes[2], nodes[1], nodes[0])\n        ]\n\n        best_permutation = None\n        best_score = float('inf')\n\n        for perm in permutations:\n            total_dist = 0\n            for i in range(2):\n                d1, d2, d3 = calculate_distances(perm[i], perm[i+1])\n                total_dist += d1 + d2 + d3\n            if total_dist < best_score:\n                best_score = total_dist\n                best_permutation = perm\n\n        new_solution[a], new_solution[b], new_solution[c] = best_permutation\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 224,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful improvements\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Objective-aware 2-opt or 3-opt move\n    if np.random.random() < 0.7:  # Higher chance for 2-opt\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move (more complex but can explore better neighborhoods)\n        if j - i >= 2:\n            k = np.random.randint(i+1, j)\n            # Randomly choose one of the possible 3-opt configurations\n            if np.random.random() < 0.5:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            else:\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8117878996910971,
            0.9336742997169495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful improvements\n\n    # Randomly select a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Objective-aware 2-opt or 3-opt move\n    if np.random.random() < 0.7:  # Higher chance for 2-opt\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move (more complex but can explore better neighborhoods)\n        if j - i >= 2:\n            k = np.random.randint(i+1, j)\n            # Randomly choose one of the possible 3-opt configurations\n            if np.random.random() < 0.5:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            else:\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 225,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, min(start + 10, n))  # Limit segment size for efficiency\n\n    # Apply a combination of 2-opt and 3-opt moves\n    if np.random.rand() < 0.5:\n        # 2-opt move\n        i, j = np.random.randint(0, n, size=2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the move is invalid\n        i, j = np.random.randint(0, n, size=2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7152792021015932,
            1.74397873878479
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, min(start + 10, n))  # Limit segment size for efficiency\n\n    # Apply a combination of 2-opt and 3-opt moves\n    if np.random.rand() < 0.5:\n        # 2-opt move\n        i, j = np.random.randint(0, n, size=2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the move is invalid\n        i, j = np.random.randint(0, n, size=2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 226,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [sum(obj) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Apply a multi-objective aware local search operator\n    new_solution = selected_solution.copy()\n\n    # Choose between 2-opt, 3-opt, or a custom multi-objective operator\n    operator_choice = random.random()\n\n    if operator_choice < 0.4:  # 40% chance for 2-opt\n        # Select two random edges to reverse\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator_choice < 0.8:  # 40% chance for 3-opt\n        # Select three random edges to reconnect in a different order\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # 20% chance for multi-objective aware operator\n        # Identify the most critical edge based on all three objectives\n        total_distances = []\n        for i in range(len(new_solution)):\n            u = new_solution[i]\n            v = new_solution[(i+1) % len(new_solution)]\n            dist1 = distance_matrix_1[u, v]\n            dist2 = distance_matrix_2[u, v]\n            dist3 = distance_matrix_3[u, v]\n            total_distances.append((dist1 + dist2 + dist3, i))\n\n        # Sort edges by their total distance (most critical first)\n        total_distances.sort(reverse=True, key=lambda x: x[0])\n        critical_edges = [idx for _, idx in total_distances[:3]]  # Consider top 3 most critical edges\n\n        # Apply a targeted 2-opt on one of these critical edges\n        if critical_edges:\n            i = random.choice(critical_edges)\n            j = (i + 1) % len(new_solution)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    assert len(np.unique(new_solution)) == len(instance), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6919623751809769,
            1.9927005410194396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [sum(obj) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Apply a multi-objective aware local search operator\n    new_solution = selected_solution.copy()\n\n    # Choose between 2-opt, 3-opt, or a custom multi-objective operator\n    operator_choice = random.random()\n\n    if operator_choice < 0.4:  # 40% chance for 2-opt\n        # Select two random edges to reverse\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator_choice < 0.8:  # 40% chance for 3-opt\n        # Select three random edges to reconnect in a different order\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # 20% chance for multi-objective aware operator\n        # Identify the most critical edge based on all three objectives\n        total_distances = []\n        for i in range(len(new_solution)):\n            u = new_solution[i]\n            v = new_solution[(i+1) % len(new_solution)]\n            dist1 = distance_matrix_1[u, v]\n            dist2 = distance_matrix_2[u, v]\n            dist3 = distance_matrix_3[u, v]\n            total_distances.append((dist1 + dist2 + dist3, i))\n\n        # Sort edges by their total distance (most critical first)\n        total_distances.sort(reverse=True, key=lambda x: x[0])\n        critical_edges = [idx for _, idx in total_distances[:3]]  # Consider top 3 most critical edges\n\n        # Apply a targeted 2-opt on one of these critical edges\n        if critical_edges:\n            i = random.choice(critical_edges)\n            j = (i + 1) % len(new_solution)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    assert len(np.unique(new_solution)) == len(instance), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 227,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., lowest total distance across objectives)\n    total_distances = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(total_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Objective-aware swap: find the best swap within the segment to improve all three objectives\n    if len(segment) > 1:\n        best_improvement = 0\n        best_swap = None\n\n        for k in range(len(segment)):\n            for l in range(k + 1, len(segment)):\n                # Calculate the change in total distance for all three objectives\n                node_k, node_l = segment[k], segment[l]\n                original_dist = (distance_matrix_1[node_k, segment[(k-1)%len(segment)]] +\n                                distance_matrix_1[segment[(k+1)%len(segment)], node_k] +\n                                distance_matrix_1[node_l, segment[(l-1)%len(segment)]] +\n                                distance_matrix_1[segment[(l+1)%len(segment)], node_l])\n\n                swapped_dist = (distance_matrix_1[node_l, segment[(k-1)%len(segment)]] +\n                               distance_matrix_1[segment[(k+1)%len(segment)], node_l] +\n                               distance_matrix_1[node_k, segment[(l-1)%len(segment)]] +\n                               distance_matrix_1[segment[(l+1)%len(segment)], node_k])\n\n                improvement = original_dist - swapped_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (k, l)\n\n        if best_swap is not None:\n            k, l = best_swap\n            segment[k], segment[l] = segment[l], segment[k]\n            new_solution[i:j+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6556004559713993,
            3.088390052318573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., lowest total distance across objectives)\n    total_distances = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(total_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Objective-aware swap: find the best swap within the segment to improve all three objectives\n    if len(segment) > 1:\n        best_improvement = 0\n        best_swap = None\n\n        for k in range(len(segment)):\n            for l in range(k + 1, len(segment)):\n                # Calculate the change in total distance for all three objectives\n                node_k, node_l = segment[k], segment[l]\n                original_dist = (distance_matrix_1[node_k, segment[(k-1)%len(segment)]] +\n                                distance_matrix_1[segment[(k+1)%len(segment)], node_k] +\n                                distance_matrix_1[node_l, segment[(l-1)%len(segment)]] +\n                                distance_matrix_1[segment[(l+1)%len(segment)], node_l])\n\n                swapped_dist = (distance_matrix_1[node_l, segment[(k-1)%len(segment)]] +\n                               distance_matrix_1[segment[(k+1)%len(segment)], node_l] +\n                               distance_matrix_1[node_k, segment[(l-1)%len(segment)]] +\n                               distance_matrix_1[segment[(l+1)%len(segment)], node_k])\n\n                improvement = original_dist - swapped_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (k, l)\n\n        if best_swap is not None:\n            k, l = best_swap\n            segment[k], segment[l] = segment[l], segment[k]\n            new_solution[i:j+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 228,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives to find the most balanced solution\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        diversity_scores = np.sum(normalized, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and random segment reversal\n    if len(new_solution) > 3:\n        # Perform 2-opt on a randomly selected segment\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            new_solution[i:j] = segment[::-1]  # Reverse the segment\n\n        # Apply random segment reversal with probability 0.3\n        if random.random() < 0.3:\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            if j - i > 1:\n                segment = new_solution[i:j]\n                new_solution[i:j] = segment[::-1]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid tour: duplicate nodes\"\n    assert len(new_solution) == len(base_solution), \"Invalid tour: length mismatch\"\n\n    return new_solution\n\n",
        "score": [
            -0.6990591014053311,
            1.5178869485855102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives to find the most balanced solution\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        diversity_scores = np.sum(normalized, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and random segment reversal\n    if len(new_solution) > 3:\n        # Perform 2-opt on a randomly selected segment\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            new_solution[i:j] = segment[::-1]  # Reverse the segment\n\n        # Apply random segment reversal with probability 0.3\n        if random.random() < 0.3:\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            if j - i > 1:\n                segment = new_solution[i:j]\n                new_solution[i:j] = segment[::-1]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid tour: duplicate nodes\"\n    assert len(new_solution) == len(base_solution), \"Invalid tour: length mismatch\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 229,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement by considering the diversity of objectives\n    if len(archive) > 1:\n        # Calculate the spread of objectives to identify solutions with potential\n        objectives = np.array([obj for _, obj in archive])\n        objective_spread = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        # Select solutions with the highest spread (indicating potential for improvement)\n        candidate_indices = np.where(objective_spread > np.percentile(objective_spread, 75))[0]\n        if len(candidate_indices) > 0:\n            selected_idx = random.choice(candidate_indices)\n            base_solution = archive[selected_idx][0].copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    if n > 3:\n        # 2-opt move for one objective space (randomly selected)\n        obj_space = random.choice([1, 2, 3])\n        if obj_space == 1:\n            distance_matrix = distance_matrix_1\n        elif obj_space == 2:\n            distance_matrix = distance_matrix_2\n        else:\n            distance_matrix = distance_matrix_3\n\n        # Select two random edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap is valid (does not create sub-tours)\n        if i != j and abs(i - j) > 1:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Node insertion for another objective space (randomly selected)\n        obj_space = random.choice([1, 2, 3])\n        if obj_space == 1:\n            distance_matrix = distance_matrix_1\n        elif obj_space == 2:\n            distance_matrix = distance_matrix_2\n        else:\n            distance_matrix = distance_matrix_3\n\n        # Select a random node to move\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        # Remove the node from its current position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        # Find the best insertion position for the node in the new solution\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(new_solution)):\n            # Insert the node at position pos\n            candidate = np.insert(new_solution, pos, node)\n            # Calculate the cost of the new solution in the selected objective space\n            cost = sum(distance_matrix[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix[candidate[-1], candidate[0]]\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7573984460946664,
            3.2446130514144897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement by considering the diversity of objectives\n    if len(archive) > 1:\n        # Calculate the spread of objectives to identify solutions with potential\n        objectives = np.array([obj for _, obj in archive])\n        objective_spread = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        # Select solutions with the highest spread (indicating potential for improvement)\n        candidate_indices = np.where(objective_spread > np.percentile(objective_spread, 75))[0]\n        if len(candidate_indices) > 0:\n            selected_idx = random.choice(candidate_indices)\n            base_solution = archive[selected_idx][0].copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    if n > 3:\n        # 2-opt move for one objective space (randomly selected)\n        obj_space = random.choice([1, 2, 3])\n        if obj_space == 1:\n            distance_matrix = distance_matrix_1\n        elif obj_space == 2:\n            distance_matrix = distance_matrix_2\n        else:\n            distance_matrix = distance_matrix_3\n\n        # Select two random edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap is valid (does not create sub-tours)\n        if i != j and abs(i - j) > 1:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Node insertion for another objective space (randomly selected)\n        obj_space = random.choice([1, 2, 3])\n        if obj_space == 1:\n            distance_matrix = distance_matrix_1\n        elif obj_space == 2:\n            distance_matrix = distance_matrix_2\n        else:\n            distance_matrix = distance_matrix_3\n\n        # Select a random node to move\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        # Remove the node from its current position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        # Find the best insertion position for the node in the new solution\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(new_solution)):\n            # Insert the node at position pos\n            candidate = np.insert(new_solution, pos, node)\n            # Calculate the cost of the new solution in the selected objective space\n            cost = sum(distance_matrix[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix[candidate[-1], candidate[0]]\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 230,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform standard 2-opt\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-aware swaps\n    for _ in range(2):  # Number of swaps to try\n        # Select a pair of nodes to swap\n        a, b = np.random.choice(n, size=2, replace=False)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6568188356120157,
            2.0106121063232423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform standard 2-opt\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform objective-aware swaps\n    for _ in range(2):  # Number of swaps to try\n        # Select a pair of nodes to swap\n        a, b = np.random.choice(n, size=2, replace=False)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 231,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    n = len(new_solution)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge swapping\n    for _ in range(2):  # Perform multiple swaps\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            # Calculate current and potential costs for all three objectives\n            current_costs = (\n                distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            )\n\n            potential_costs = (\n                distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                distance_matrix_1[new_solution[k], new_solution[(l+1)%n]] +\n                distance_matrix_2[new_solution[k], new_solution[(l+1)%n]] +\n                distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]\n            )\n\n            # Accept the swap if it improves at least one objective\n            if potential_costs < current_costs:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8367913788085467,
            1.2972755312919617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    n = len(new_solution)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge swapping\n    for _ in range(2):  # Perform multiple swaps\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            # Calculate current and potential costs for all three objectives\n            current_costs = (\n                distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            )\n\n            potential_costs = (\n                distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                distance_matrix_1[new_solution[k], new_solution[(l+1)%n]] +\n                distance_matrix_2[new_solution[k], new_solution[(l+1)%n]] +\n                distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]\n            )\n\n            # Accept the swap if it improves at least one objective\n            if potential_costs < current_costs:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 232,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimized)\n    # Here we select a solution that is not the best in any objective\n    non_dominated = [sol for sol, _ in archive]\n    if len(non_dominated) == 1:\n        base_solution = non_dominated[0].copy()\n    else:\n        # Select a solution that is not the best in any objective\n        objectives = np.array([obj for _, obj in archive])\n        best_in_obj1 = np.argmin(objectives[:, 0])\n        best_in_obj2 = np.argmin(objectives[:, 1])\n        best_in_obj3 = np.argmin(objectives[:, 2])\n\n        candidates = set(range(len(non_dominated))) - {best_in_obj1, best_in_obj2, best_in_obj3}\n        if not candidates:\n            candidates = range(len(non_dominated))\n\n        selected_idx = random.choice(list(candidates))\n        base_solution = non_dominated[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly choose between 2-opt and 3-opt (more disruptive)\n    # 2. For 2-opt: select two edges to swap\n    # 3. For 3-opt: select three edges to reconnect\n    search_type = random.choice(['2-opt', '3-opt'])\n\n    if search_type == '2-opt':\n        # 2-opt: select two non-adjacent edges and reverse the segment between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt: select three edges and reconnect them in a different way\n        n = len(new_solution)\n        a, b, c = sorted(random.sample(range(1, n), 3))\n\n        # There are 8 possible reconnections for 3-opt (all permutations of order)\n        reconnection = random.randint(0, 7)\n\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:] if a != 0 else new_solution[:a]\n\n        if reconnection == 0:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, segment3])\n        elif reconnection == 1:\n            new_solution = np.concatenate([new_solution[:a], segment2[::-1], segment1, segment3])\n        elif reconnection == 2:\n            new_solution = np.concatenate([new_solution[:a], segment1, segment2[::-1], segment3])\n        elif reconnection == 3:\n            new_solution = np.concatenate([new_solution[:a], segment1, segment2, segment3[::-1]])\n        elif reconnection == 4:\n            new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2, segment3[::-1]])\n        elif reconnection == 5:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1[::-1], segment3[::-1]])\n        elif reconnection == 6:\n            new_solution = np.concatenate([new_solution[:a], segment2[::-1], segment1[::-1], segment3])\n        else:\n            new_solution = np.concatenate([new_solution[:a], segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.813532216708273,
            1.4345575809478759
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimized)\n    # Here we select a solution that is not the best in any objective\n    non_dominated = [sol for sol, _ in archive]\n    if len(non_dominated) == 1:\n        base_solution = non_dominated[0].copy()\n    else:\n        # Select a solution that is not the best in any objective\n        objectives = np.array([obj for _, obj in archive])\n        best_in_obj1 = np.argmin(objectives[:, 0])\n        best_in_obj2 = np.argmin(objectives[:, 1])\n        best_in_obj3 = np.argmin(objectives[:, 2])\n\n        candidates = set(range(len(non_dominated))) - {best_in_obj1, best_in_obj2, best_in_obj3}\n        if not candidates:\n            candidates = range(len(non_dominated))\n\n        selected_idx = random.choice(list(candidates))\n        base_solution = non_dominated[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly choose between 2-opt and 3-opt (more disruptive)\n    # 2. For 2-opt: select two edges to swap\n    # 3. For 3-opt: select three edges to reconnect\n    search_type = random.choice(['2-opt', '3-opt'])\n\n    if search_type == '2-opt':\n        # 2-opt: select two non-adjacent edges and reverse the segment between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt: select three edges and reconnect them in a different way\n        n = len(new_solution)\n        a, b, c = sorted(random.sample(range(1, n), 3))\n\n        # There are 8 possible reconnections for 3-opt (all permutations of order)\n        reconnection = random.randint(0, 7)\n\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:] if a != 0 else new_solution[:a]\n\n        if reconnection == 0:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, segment3])\n        elif reconnection == 1:\n            new_solution = np.concatenate([new_solution[:a], segment2[::-1], segment1, segment3])\n        elif reconnection == 2:\n            new_solution = np.concatenate([new_solution[:a], segment1, segment2[::-1], segment3])\n        elif reconnection == 3:\n            new_solution = np.concatenate([new_solution[:a], segment1, segment2, segment3[::-1]])\n        elif reconnection == 4:\n            new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2, segment3[::-1]])\n        elif reconnection == 5:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1[::-1], segment3[::-1]])\n        elif reconnection == 6:\n            new_solution = np.concatenate([new_solution[:a], segment2[::-1], segment1[::-1], segment3])\n        else:\n            new_solution = np.concatenate([new_solution[:a], segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 233,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too diverse)\n    selected_solution = archive[0][0].copy()\n    selected_objective = archive[0][1]\n\n    # Intelligent selection: prefer solutions with good balance across objectives\n    for sol, obj in archive[1:]:\n        if (obj[0] < selected_objective[0] and obj[1] < selected_objective[1]) or \\\n           (obj[0] < selected_objective[0] and obj[2] < selected_objective[2]) or \\\n           (obj[1] < selected_objective[1] and obj[2] < selected_objective[2]):\n            selected_solution = sol.copy()\n            selected_objective = obj\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy combining multiple operators\n    operators = [\n        '2-opt',  # Standard 2-opt for single objective\n        'double-bridge',  # More disruptive for multi-objective\n        'random-swap',  # Basic swap for exploration\n        'objective-aware-2opt'  # Custom operator for tri-objective\n    ]\n\n    operator = random.choice(operators)\n\n    if operator == '2-opt':\n        # Perform 2-opt on the objective with highest improvement potential\n        best_improvement = 0\n        best_i, best_j = 0, 0\n\n        # Choose the objective with the highest potential for improvement\n        obj_index = np.argmax([selected_objective[0], selected_objective[1], selected_objective[2]])\n\n        for i in range(len(new_solution) - 1):\n            for j in range(i + 1, len(new_solution)):\n                # Calculate improvement for the selected objective\n                if obj_index == 0:\n                    improvement = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                                  distance_matrix_1[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                                 (distance_matrix_1[new_solution[i], new_solution[j]] +\n                                  distance_matrix_1[new_solution[i+1], new_solution[(j+1)%len(new_solution)]])\n                elif obj_index == 1:\n                    improvement = (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                                  distance_matrix_2[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                                 (distance_matrix_2[new_solution[i], new_solution[j]] +\n                                  distance_matrix_2[new_solution[i+1], new_solution[(j+1)%len(new_solution)]])\n                else:\n                    improvement = (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                                  distance_matrix_3[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                                 (distance_matrix_3[new_solution[i], new_solution[j]] +\n                                  distance_matrix_3[new_solution[i+1], new_solution[(j+1)%len(new_solution)]])\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_improvement > 0:\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    elif operator == 'double-bridge':\n        # Double-bridge operator for more disruptive changes\n        n = len(new_solution)\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_solution[b:c],\n            new_solution[a:b],\n            new_solution[c:d],\n            new_solution[d:]\n        ])\n\n    elif operator == 'random-swap':\n        # Random swap between two nodes\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'objective-aware-2opt':\n        # Custom operator that considers all three objectives\n        best_improvement = 0\n        best_i, best_j = 0, 0\n\n        for i in range(len(new_solution) - 1):\n            for j in range(i + 1, len(new_solution)):\n                # Calculate combined improvement across all objectives\n                improvement = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                              distance_matrix_1[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                             (distance_matrix_1[new_solution[i], new_solution[j]] +\n                              distance_matrix_1[new_solution[i+1], new_solution[(j+1)%len(new_solution)]]) + \\\n                             (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                              distance_matrix_2[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                             (distance_matrix_2[new_solution[i], new_solution[j]] +\n                              distance_matrix_2[new_solution[i+1], new_solution[(j+1)%len(new_solution)]]) + \\\n                             (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                              distance_matrix_3[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                             (distance_matrix_3[new_solution[i], new_solution[j]] +\n                              distance_matrix_3[new_solution[i+1], new_solution[(j+1)%len(new_solution)]])\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_improvement > 0:\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7008316401886675,
            3.916774642467499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too diverse)\n    selected_solution = archive[0][0].copy()\n    selected_objective = archive[0][1]\n\n    # Intelligent selection: prefer solutions with good balance across objectives\n    for sol, obj in archive[1:]:\n        if (obj[0] < selected_objective[0] and obj[1] < selected_objective[1]) or \\\n           (obj[0] < selected_objective[0] and obj[2] < selected_objective[2]) or \\\n           (obj[1] < selected_objective[1] and obj[2] < selected_objective[2]):\n            selected_solution = sol.copy()\n            selected_objective = obj\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy combining multiple operators\n    operators = [\n        '2-opt',  # Standard 2-opt for single objective\n        'double-bridge',  # More disruptive for multi-objective\n        'random-swap',  # Basic swap for exploration\n        'objective-aware-2opt'  # Custom operator for tri-objective\n    ]\n\n    operator = random.choice(operators)\n\n    if operator == '2-opt':\n        # Perform 2-opt on the objective with highest improvement potential\n        best_improvement = 0\n        best_i, best_j = 0, 0\n\n        # Choose the objective with the highest potential for improvement\n        obj_index = np.argmax([selected_objective[0], selected_objective[1], selected_objective[2]])\n\n        for i in range(len(new_solution) - 1):\n            for j in range(i + 1, len(new_solution)):\n                # Calculate improvement for the selected objective\n                if obj_index == 0:\n                    improvement = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                                  distance_matrix_1[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                                 (distance_matrix_1[new_solution[i], new_solution[j]] +\n                                  distance_matrix_1[new_solution[i+1], new_solution[(j+1)%len(new_solution)]])\n                elif obj_index == 1:\n                    improvement = (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                                  distance_matrix_2[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                                 (distance_matrix_2[new_solution[i], new_solution[j]] +\n                                  distance_matrix_2[new_solution[i+1], new_solution[(j+1)%len(new_solution)]])\n                else:\n                    improvement = (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                                  distance_matrix_3[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                                 (distance_matrix_3[new_solution[i], new_solution[j]] +\n                                  distance_matrix_3[new_solution[i+1], new_solution[(j+1)%len(new_solution)]])\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_improvement > 0:\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    elif operator == 'double-bridge':\n        # Double-bridge operator for more disruptive changes\n        n = len(new_solution)\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_solution[b:c],\n            new_solution[a:b],\n            new_solution[c:d],\n            new_solution[d:]\n        ])\n\n    elif operator == 'random-swap':\n        # Random swap between two nodes\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'objective-aware-2opt':\n        # Custom operator that considers all three objectives\n        best_improvement = 0\n        best_i, best_j = 0, 0\n\n        for i in range(len(new_solution) - 1):\n            for j in range(i + 1, len(new_solution)):\n                # Calculate combined improvement across all objectives\n                improvement = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                              distance_matrix_1[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                             (distance_matrix_1[new_solution[i], new_solution[j]] +\n                              distance_matrix_1[new_solution[i+1], new_solution[(j+1)%len(new_solution)]]) + \\\n                             (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                              distance_matrix_2[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                             (distance_matrix_2[new_solution[i], new_solution[j]] +\n                              distance_matrix_2[new_solution[i+1], new_solution[(j+1)%len(new_solution)]]) + \\\n                             (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                              distance_matrix_3[new_solution[j], new_solution[(j+1)%len(new_solution)]]) - \\\n                             (distance_matrix_3[new_solution[i], new_solution[j]] +\n                              distance_matrix_3[new_solution[i+1], new_solution[(j+1)%len(new_solution)]])\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_improvement > 0:\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 234,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    # Normalize objectives to identify solutions with high potential\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n    # Calculate a score combining all three objectives (e.g., sum of normalized values)\n    scores = normalized.sum(axis=1)\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel 3-way swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-way swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-way swap: randomly select three edges and swap their order\n        if n >= 3:\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Split the tour into three segments and rearrange them\n            segment1 = new_solution[:i]\n            segment2 = new_solution[i:j]\n            segment3 = new_solution[j:k]\n            segment4 = new_solution[k:]\n            # Reconstruct the tour with segments in a different order\n            new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        # Fallback to 2-opt if the 3-way swap is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.735500850106497,
            1.7732418417930602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    # Normalize objectives to identify solutions with high potential\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n    # Calculate a score combining all three objectives (e.g., sum of normalized values)\n    scores = normalized.sum(axis=1)\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel 3-way swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-way swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-way swap: randomly select three edges and swap their order\n        if n >= 3:\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Split the tour into three segments and rearrange them\n            segment1 = new_solution[:i]\n            segment2 = new_solution[i:j]\n            segment3 = new_solution[j:k]\n            segment4 = new_solution[k:]\n            # Reconstruct the tour with segments in a different order\n            new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        # Fallback to 2-opt if the 3-way swap is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 235,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a weighted sum of objectives to identify promising candidates\n    weighted_solutions = []\n    for sol, obj in archive:\n        # Weighted sum with random weights to encourage diversity\n        weight1, weight2, weight3 = random.random(), random.random(), random.random()\n        total = weight1 * obj[0] + weight2 * obj[1] + weight3 * obj[2]\n        weighted_solutions.append((total, sol))\n\n    # Select top 30% of solutions based on weighted sum\n    weighted_solutions.sort(key=lambda x: x[0])\n    top_solutions = [sol for (_, sol) in weighted_solutions[:max(1, len(weighted_solutions) // 3)]]\n\n    if not top_solutions:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(top_solutions).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt and edge insertion\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion move\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8399847092432878,
            1.8260511994361877
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a weighted sum of objectives to identify promising candidates\n    weighted_solutions = []\n    for sol, obj in archive:\n        # Weighted sum with random weights to encourage diversity\n        weight1, weight2, weight3 = random.random(), random.random(), random.random()\n        total = weight1 * obj[0] + weight2 * obj[1] + weight3 * obj[2]\n        weighted_solutions.append((total, sol))\n\n    # Select top 30% of solutions based on weighted sum\n    weighted_solutions.sort(key=lambda x: x[0])\n    top_solutions = [sol for (_, sol) in weighted_solutions[:max(1, len(weighted_solutions) // 3)]]\n\n    if not top_solutions:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(top_solutions).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt and edge insertion\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion move\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 236,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in at least one objective\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and Or-opt\n    new_solution = base_solution.copy()\n\n    # Choose between 2-opt and Or-opt based on a probability\n    if random.random() < 0.5:\n        # 2-opt move: select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        if i + 1 != j:  # Ensure they are not adjacent\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:\n        # Or-opt move: relocate a segment of 2-3 nodes to another position\n        segment_length = random.randint(2, min(3, len(new_solution) - 1))\n        i = random.randint(0, len(new_solution) - segment_length)\n        segment = new_solution[i:i+segment_length]\n        remaining = np.concatenate([new_solution[:i], new_solution[i+segment_length:]])\n        j = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:j], segment, remaining[j:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7349937476518659,
            1.6916495442390442
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in at least one objective\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and Or-opt\n    new_solution = base_solution.copy()\n\n    # Choose between 2-opt and Or-opt based on a probability\n    if random.random() < 0.5:\n        # 2-opt move: select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        if i + 1 != j:  # Ensure they are not adjacent\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:\n        # Or-opt move: relocate a segment of 2-3 nodes to another position\n        segment_length = random.randint(2, min(3, len(new_solution) - 1))\n        i = random.randint(0, len(new_solution) - segment_length)\n        segment = new_solution[i:i+segment_length]\n        remaining = np.concatenate([new_solution[:i], new_solution[i+segment_length:]])\n        j = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:j], segment, remaining[j:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 237,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    total_distances = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(total_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-opt-like operation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt swap (standard local search)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel 3-opt-like operation that considers all three objectives\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Calculate the current and potential costs for each objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            cost += distance_matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_costs = [\n        calculate_cost(new_solution, distance_matrix_1),\n        calculate_cost(new_solution, distance_matrix_2),\n        calculate_cost(new_solution, distance_matrix_3)\n    ]\n\n    # Generate all possible 3-opt moves and select the one that improves the most in the combined objectives\n    best_move = None\n    best_improvement = 0\n\n    for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n        temp_solution = new_solution.copy()\n        temp_solution[perm[0]:perm[1]] = temp_solution[perm[0]:perm[1]][::-1]\n        temp_solution[perm[1]:perm[2]] = temp_solution[perm[1]:perm[2]][::-1]\n\n        new_costs = [\n            calculate_cost(temp_solution, distance_matrix_1),\n            calculate_cost(temp_solution, distance_matrix_2),\n            calculate_cost(temp_solution, distance_matrix_3)\n        ]\n\n        improvement = sum(current_costs) - sum(new_costs)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_move = temp_solution.copy()\n\n    if best_move is not None:\n        new_solution = best_move\n\n    return new_solution\n\n",
        "score": [
            -0.5420400777695551,
            2.3960201025009153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    total_distances = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(total_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-opt-like operation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt swap (standard local search)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel 3-opt-like operation that considers all three objectives\n    a, b, c = np.random.choice(n, 3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Calculate the current and potential costs for each objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            cost += distance_matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_costs = [\n        calculate_cost(new_solution, distance_matrix_1),\n        calculate_cost(new_solution, distance_matrix_2),\n        calculate_cost(new_solution, distance_matrix_3)\n    ]\n\n    # Generate all possible 3-opt moves and select the one that improves the most in the combined objectives\n    best_move = None\n    best_improvement = 0\n\n    for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n        temp_solution = new_solution.copy()\n        temp_solution[perm[0]:perm[1]] = temp_solution[perm[0]:perm[1]][::-1]\n        temp_solution[perm[1]:perm[2]] = temp_solution[perm[1]:perm[2]][::-1]\n\n        new_costs = [\n            calculate_cost(temp_solution, distance_matrix_1),\n            calculate_cost(temp_solution, distance_matrix_2),\n            calculate_cost(temp_solution, distance_matrix_3)\n        ]\n\n        improvement = sum(current_costs) - sum(new_costs)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_move = temp_solution.copy()\n\n    if best_move is not None:\n        new_solution = best_move\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 238,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move (for general improvement)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform an objective-aware swap (prioritize objectives with higher costs)\n    if np.random.random() < 0.7:  # Higher probability to apply this\n        # Calculate current costs for each objective\n        cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # Identify which objective has the highest cost\n        max_obj = np.argmax([cost1, cost2, cost3])\n\n        # Apply swap to improve the highest-cost objective\n        if max_obj == 0:\n            # Find the worst edge in objective 1\n            worst_edge = max((distance_matrix_1[new_solution[k], new_solution[(k+1)%n]], k) for k in range(n))[1]\n        elif max_obj == 1:\n            worst_edge = max((distance_matrix_2[new_solution[k], new_solution[(k+1)%n]], k) for k in range(n))[1]\n        else:\n            worst_edge = max((distance_matrix_3[new_solution[k], new_solution[(k+1)%n]], k) for k in range(n))[1]\n\n        # Perform a swap to improve this edge\n        k = worst_edge\n        l = np.random.choice([i for i in range(n) if i != k and i != (k+1)%n])\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7370429698005547,
            1.852179753780365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move (for general improvement)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform an objective-aware swap (prioritize objectives with higher costs)\n    if np.random.random() < 0.7:  # Higher probability to apply this\n        # Calculate current costs for each objective\n        cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # Identify which objective has the highest cost\n        max_obj = np.argmax([cost1, cost2, cost3])\n\n        # Apply swap to improve the highest-cost objective\n        if max_obj == 0:\n            # Find the worst edge in objective 1\n            worst_edge = max((distance_matrix_1[new_solution[k], new_solution[(k+1)%n]], k) for k in range(n))[1]\n        elif max_obj == 1:\n            worst_edge = max((distance_matrix_2[new_solution[k], new_solution[(k+1)%n]], k) for k in range(n))[1]\n        else:\n            worst_edge = max((distance_matrix_3[new_solution[k], new_solution[(k+1)%n]], k) for k in range(n))[1]\n\n        # Perform a swap to improve this edge\n        k = worst_edge\n        l = np.random.choice([i for i in range(n) if i != k and i != (k+1)%n])\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 239,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with the best combined objective values\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to operate on\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt swap between segments\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    # Invert segments with probability 0.5 to encourage exploration\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([\n        new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]\n    ])\n\n    # Ensure feasibility (remove duplicates while preserving order)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If any nodes are missing, append them in a random order\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        np.random.shuffle(missing_nodes)\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.6961226752280194,
            2.52342826128006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with the best combined objective values\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to operate on\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt swap between segments\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    # Invert segments with probability 0.5 to encourage exploration\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([\n        new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]\n    ])\n\n    # Ensure feasibility (remove duplicates while preserving order)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If any nodes are missing, append them in a random order\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        np.random.shuffle(missing_nodes)\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 240,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are not too close to the Pareto front\n    # and have diverse objectives to ensure exploration\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + (obj[0] + obj[1] + obj[2])) for sol, obj in archive],\n        k=1\n    )[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining:\n    # 1. 2-opt for one objective\n    # 2. Or-opt for another objective\n    # 3. Swap for the third objective\n    strategy = random.choice(['2opt', 'oropt', 'swap'])\n\n    if strategy == '2opt':\n        # Apply 2-opt to the objective with the highest current cost\n        obj = archive[selected_idx][1]\n        max_obj_idx = np.argmax(obj)\n\n        if max_obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif max_obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Select random edges to reverse\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif strategy == 'oropt':\n        # Apply Or-opt to the objective with the lowest current cost\n        obj = archive[selected_idx][1]\n        min_obj_idx = np.argmin(obj)\n\n        if min_obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif min_obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Select a random segment to move\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    else:  # swap\n        # Apply swap to balance objectives\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, use the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.829684611553074,
            1.622924256324768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are not too close to the Pareto front\n    # and have diverse objectives to ensure exploration\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + (obj[0] + obj[1] + obj[2])) for sol, obj in archive],\n        k=1\n    )[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining:\n    # 1. 2-opt for one objective\n    # 2. Or-opt for another objective\n    # 3. Swap for the third objective\n    strategy = random.choice(['2opt', 'oropt', 'swap'])\n\n    if strategy == '2opt':\n        # Apply 2-opt to the objective with the highest current cost\n        obj = archive[selected_idx][1]\n        max_obj_idx = np.argmax(obj)\n\n        if max_obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif max_obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Select random edges to reverse\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif strategy == 'oropt':\n        # Apply Or-opt to the objective with the lowest current cost\n        obj = archive[selected_idx][1]\n        min_obj_idx = np.argmin(obj)\n\n        if min_obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif min_obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Select a random segment to move\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    else:  # swap\n        # Apply swap to balance objectives\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, use the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 241,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt move for the first objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap for the other two objectives\n        # Calculate potential improvements\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # Try swapping nodes that are far in the worst-performing objective\n        worst_obj = np.argmax(current_costs[1:]) + 1  # +1 because we skip the first objective\n        if worst_obj == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find the worst edge in this objective\n        max_edge = -1\n        max_dist = -1\n        for k in range(n):\n            dist = dm[new_solution[k], new_solution[(k+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = k\n\n        # Swap nodes around this worst edge\n        if max_edge != -1:\n            i = max_edge\n            j = (i + 1) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7361056778255752,
            1.266509747505188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt move for the first objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap for the other two objectives\n        # Calculate potential improvements\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # Try swapping nodes that are far in the worst-performing objective\n        worst_obj = np.argmax(current_costs[1:]) + 1  # +1 because we skip the first objective\n        if worst_obj == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find the worst edge in this objective\n        max_edge = -1\n        max_dist = -1\n        for k in range(n):\n            dist = dm[new_solution[k], new_solution[(k+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = k\n\n        # Swap nodes around this worst edge\n        if max_edge != -1:\n            i = max_edge\n            j = (i + 1) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 242,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (for one objective)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge exchange (for another objective)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if edge exchange causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7128324740694074,
            1.5456732869148255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (for one objective)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge exchange (for another objective)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if edge exchange causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 243,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.sum(objectives, axis=0, keepdims=True)\n    weights = 1 / (1 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Determine the local search operator to apply\n    if random.random() < 0.7:  # Higher probability for 3-opt to explore more complex neighborhoods\n        # Apply 3-opt move\n        i, j, k = sorted(random.sample(range(1, len(new_solution)-1), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Apply 2-opt move\n        i, j = sorted(random.sample(range(1, len(new_solution)-1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7631105114618397,
            1.4226585268974303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.sum(objectives, axis=0, keepdims=True)\n    weights = 1 / (1 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Determine the local search operator to apply\n    if random.random() < 0.7:  # Higher probability for 3-opt to explore more complex neighborhoods\n        # Apply 3-opt move\n        i, j, k = sorted(random.sample(range(1, len(new_solution)-1), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Apply 2-opt move\n        i, j = sorted(random.sample(range(1, len(new_solution)-1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 244,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt move)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate the improvement in all three objectives\n    def calculate_improvement(sol):\n        total_cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        total_cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        total_cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return total_cost1, total_cost2, total_cost3\n\n    original_cost = calculate_improvement(new_solution)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment between i and j\n    new_cost = calculate_improvement(new_solution)\n\n    # If the move worsens all objectives, revert it (but allow some exploration)\n    if all(nc >= oc for nc, oc in zip(new_cost, original_cost)) and np.random.rand() < 0.3:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Revert\n\n    # Additionally, apply a small perturbation to escape local optima\n    if np.random.rand() < 0.2:\n        k, l = np.random.choice(n, size=2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6639032884511784,
            2.0394833087921143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt move)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate the improvement in all three objectives\n    def calculate_improvement(sol):\n        total_cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        total_cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        total_cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return total_cost1, total_cost2, total_cost3\n\n    original_cost = calculate_improvement(new_solution)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment between i and j\n    new_cost = calculate_improvement(new_solution)\n\n    # If the move worsens all objectives, revert it (but allow some exploration)\n    if all(nc >= oc for nc, oc in zip(new_cost, original_cost)) and np.random.rand() < 0.3:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Revert\n\n    # Additionally, apply a small perturbation to escape local optima\n    if np.random.rand() < 0.2:\n        k, l = np.random.choice(n, size=2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 245,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Potential is defined as the sum of normalized improvements across all objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential = normalized_objectives.sum(axis=1)\n    probabilities = potential / potential.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly choose between 2-opt and 3-opt\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains a valid tour\n    # Verify that all nodes are visited exactly once\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7352437934849224,
            1.5247518420219421
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Potential is defined as the sum of normalized improvements across all objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential = normalized_objectives.sum(axis=1)\n    probabilities = potential / potential.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly choose between 2-opt and 3-opt\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains a valid tour\n    # Verify that all nodes are visited exactly once\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 246,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a bias towards those with high potential for improvement\n    # We define potential as solutions that are not too close to the Pareto front in any objective\n    # and have a good balance across objectives\n    candidates = []\n    for sol, obj in archive:\n        # Calculate a score based on objective diversity and potential for improvement\n        obj1, obj2, obj3 = obj\n        score = (obj1 + obj2 + obj3) / 3  # Simple average, can be replaced with more sophisticated metric\n        candidates.append((sol, obj, score))\n\n    # Sort candidates by score (ascending) to prioritize those with lower average objectives\n    candidates.sort(key=lambda x: x[2])\n    selected_sol = candidates[0][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment of the tour and reverse it (2-opt)\n    # 2. If the reversed segment doesn't improve any objective, perform a 3-opt move\n    # 3. If still no improvement, perform a random swap between objectives\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # 1. 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check if the move improves any objective\n    original_obj1 = sum(distance_matrix_1[selected_sol[k], selected_sol[(k+1)%n]] for k in range(n))\n    original_obj2 = sum(distance_matrix_2[selected_sol[k], selected_sol[(k+1)%n]] for k in range(n))\n    original_obj3 = sum(distance_matrix_3[selected_sol[k], selected_sol[(k+1)%n]] for k in range(n))\n\n    new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    if (new_obj1 >= original_obj1 and new_obj2 >= original_obj2 and new_obj3 >= original_obj3):\n        # 2. 3-opt move if 2-opt didn't help\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n        new_obj1 = sum(distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n        new_obj2 = sum(distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n        new_obj3 = sum(distance_matrix_3[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n\n        if (new_obj1 >= original_obj1 and new_obj2 >= original_obj2 and new_obj3 >= original_obj3):\n            # 3. Random swap between objectives if still no improvement\n            if random.random() < 0.5:  # 50% chance to perform swap\n                # Randomly choose two objectives to swap\n                obj_to_swap = random.choice([(distance_matrix_1, distance_matrix_2),\n                                           (distance_matrix_2, distance_matrix_3),\n                                           (distance_matrix_1, distance_matrix_3)])\n\n                # Find the best swap that improves at least one objective\n                best_swap = None\n                best_improvement = 0\n\n                for a in range(n):\n                    for b in range(a+1, n):\n                        # Calculate original distances\n                        original_dist1 = obj_to_swap[0][new_solution[a], new_solution[(a+1)%n]] + obj_to_swap[0][new_solution[b], new_solution[(b+1)%n]]\n                        original_dist2 = obj_to_swap[1][new_solution[a], new_solution[(a+1)%n]] + obj_to_swap[1][new_solution[b], new_solution[(b+1)%n]]\n\n                        # Calculate swapped distances\n                        new_dist1 = obj_to_swap[0][new_solution[a], new_solution[b]] + obj_to_swap[0][new_solution[(a+1)%n], new_solution[(b+1)%n]]\n                        new_dist2 = obj_to_swap[1][new_solution[a], new_solution[b]] + obj_to_swap[1][new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n                        improvement = (original_dist1 + original_dist2) - (new_dist1 + new_dist2)\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_swap = (a, b)\n\n                if best_swap is not None:\n                    a, b = best_swap\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5729473943848034,
            2.96657247543335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a bias towards those with high potential for improvement\n    # We define potential as solutions that are not too close to the Pareto front in any objective\n    # and have a good balance across objectives\n    candidates = []\n    for sol, obj in archive:\n        # Calculate a score based on objective diversity and potential for improvement\n        obj1, obj2, obj3 = obj\n        score = (obj1 + obj2 + obj3) / 3  # Simple average, can be replaced with more sophisticated metric\n        candidates.append((sol, obj, score))\n\n    # Sort candidates by score (ascending) to prioritize those with lower average objectives\n    candidates.sort(key=lambda x: x[2])\n    selected_sol = candidates[0][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment of the tour and reverse it (2-opt)\n    # 2. If the reversed segment doesn't improve any objective, perform a 3-opt move\n    # 3. If still no improvement, perform a random swap between objectives\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # 1. 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check if the move improves any objective\n    original_obj1 = sum(distance_matrix_1[selected_sol[k], selected_sol[(k+1)%n]] for k in range(n))\n    original_obj2 = sum(distance_matrix_2[selected_sol[k], selected_sol[(k+1)%n]] for k in range(n))\n    original_obj3 = sum(distance_matrix_3[selected_sol[k], selected_sol[(k+1)%n]] for k in range(n))\n\n    new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    if (new_obj1 >= original_obj1 and new_obj2 >= original_obj2 and new_obj3 >= original_obj3):\n        # 2. 3-opt move if 2-opt didn't help\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n        new_obj1 = sum(distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n        new_obj2 = sum(distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n        new_obj3 = sum(distance_matrix_3[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n\n        if (new_obj1 >= original_obj1 and new_obj2 >= original_obj2 and new_obj3 >= original_obj3):\n            # 3. Random swap between objectives if still no improvement\n            if random.random() < 0.5:  # 50% chance to perform swap\n                # Randomly choose two objectives to swap\n                obj_to_swap = random.choice([(distance_matrix_1, distance_matrix_2),\n                                           (distance_matrix_2, distance_matrix_3),\n                                           (distance_matrix_1, distance_matrix_3)])\n\n                # Find the best swap that improves at least one objective\n                best_swap = None\n                best_improvement = 0\n\n                for a in range(n):\n                    for b in range(a+1, n):\n                        # Calculate original distances\n                        original_dist1 = obj_to_swap[0][new_solution[a], new_solution[(a+1)%n]] + obj_to_swap[0][new_solution[b], new_solution[(b+1)%n]]\n                        original_dist2 = obj_to_swap[1][new_solution[a], new_solution[(a+1)%n]] + obj_to_swap[1][new_solution[b], new_solution[(b+1)%n]]\n\n                        # Calculate swapped distances\n                        new_dist1 = obj_to_swap[0][new_solution[a], new_solution[b]] + obj_to_swap[0][new_solution[(a+1)%n], new_solution[(b+1)%n]]\n                        new_dist2 = obj_to_swap[1][new_solution[a], new_solution[b]] + obj_to_swap[1][new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n                        improvement = (original_dist1 + original_dist2) - (new_dist1 + new_dist2)\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_swap = (a, b)\n\n                if best_swap is not None:\n                    a, b = best_swap\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 247,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (lowest total cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt and random edge swap\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a random swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 2-opt with probability 0.7, otherwise random edge swap\n        if np.random.random() < 0.7:\n            # 2-opt: select two edges and reverse the segment between them\n            i, j = np.random.choice(n, size=2, replace=False)\n            i, j = min(i, j), max(i, j)\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Random edge swap: select two edges and swap them\n            i, j = np.random.choice(n, size=2, replace=False)\n            i, j = min(i, j), max(i, j)\n            if j > i + 1:\n                # Ensure the swap maintains feasibility\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != len(selected_solution):\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6754809417460421,
            1.6587095618247987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (lowest total cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt and random edge swap\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a random swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 2-opt with probability 0.7, otherwise random edge swap\n        if np.random.random() < 0.7:\n            # 2-opt: select two edges and reverse the segment between them\n            i, j = np.random.choice(n, size=2, replace=False)\n            i, j = min(i, j), max(i, j)\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Random edge swap: select two edges and swap them\n            i, j = np.random.choice(n, size=2, replace=False)\n            i, j = min(i, j), max(i, j)\n            if j > i + 1:\n                # Ensure the swap maintains feasibility\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != len(selected_solution):\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 248,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement in at least one objective\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and insertion moves\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply insertion move (relocate a random segment)\n    if n > 3:\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n        segment = new_solution[k:k+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        insert_pos = np.random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6107365380848186,
            1.7545580506324767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement in at least one objective\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and insertion moves\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply insertion move (relocate a random segment)\n    if n > 3:\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n        segment = new_solution[k:k+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        insert_pos = np.random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 249,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest average objective value)\n    archive_with_avg = [(sol, obj, (obj[0] + obj[1] + obj[2]) / 3) for sol, obj in archive]\n    archive_with_avg.sort(key=lambda x: x[2])\n    selected = archive_with_avg[0][0].copy()\n\n    # Apply hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # First, apply 2-opt with multi-objective awareness\n    for _ in range(min(10, n)):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid modifying the tour structure\n\n        # Calculate delta for all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[j-1]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[j-1]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[j-1]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply 3-opt for further improvement\n    for _ in range(min(5, n)):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if i == 0 and k == n-1:\n            continue  # Avoid modifying the tour structure\n\n        # Try different 3-opt configurations\n        for config in [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i)\n        ]:\n            a, b, c = config\n            # Calculate delta for all three objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_1[new_solution[c-1], new_solution[(a+1)%n]] -\n                      distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] -\n                      distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[c-1], new_solution[(a+1)%n]] -\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_2[new_solution[b-1], new_solution[b]] -\n                      distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n            delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_3[new_solution[c-1], new_solution[(a+1)%n]] -\n                      distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_3[new_solution[b-1], new_solution[b]] -\n                      distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                # Apply the best configuration found\n                new_solution[a:b] = new_solution[a:b][::-1]\n                new_solution[b:c] = new_solution[b:c][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7229588257347656,
            3.1026803851127625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest average objective value)\n    archive_with_avg = [(sol, obj, (obj[0] + obj[1] + obj[2]) / 3) for sol, obj in archive]\n    archive_with_avg.sort(key=lambda x: x[2])\n    selected = archive_with_avg[0][0].copy()\n\n    # Apply hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # First, apply 2-opt with multi-objective awareness\n    for _ in range(min(10, n)):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid modifying the tour structure\n\n        # Calculate delta for all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[j-1]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[j-1]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[j-1]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply 3-opt for further improvement\n    for _ in range(min(5, n)):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if i == 0 and k == n-1:\n            continue  # Avoid modifying the tour structure\n\n        # Try different 3-opt configurations\n        for config in [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i)\n        ]:\n            a, b, c = config\n            # Calculate delta for all three objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_1[new_solution[c-1], new_solution[(a+1)%n]] -\n                      distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] -\n                      distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[c-1], new_solution[(a+1)%n]] -\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_2[new_solution[b-1], new_solution[b]] -\n                      distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n            delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[b-1], new_solution[c]] +\n                      distance_matrix_3[new_solution[c-1], new_solution[(a+1)%n]] -\n                      distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_3[new_solution[b-1], new_solution[b]] -\n                      distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                # Apply the best configuration found\n                new_solution[a:b] = new_solution[a:b][::-1]\n                new_solution[b:c] = new_solution[b:c][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 250,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    scores = [sum(w * obj for w, obj in zip(weights, objective)) for _, objective in archive]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two non-adjacent edges to swap\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    while j - i == 1 or j == i:  # Ensure edges are not adjacent\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Calculate potential improvement in all three objectives\n    def edge_cost(a, b, c, d, dm1, dm2, dm3):\n        return (dm1[a, b] + dm1[c, d] - dm1[a, c] - dm1[b, d],\n                dm2[a, b] + dm2[c, d] - dm2[a, c] - dm2[b, d],\n                dm3[a, b] + dm3[c, d] - dm3[a, c] - dm3[b, d])\n\n    # Current edges: (i, i+1) and (j, j+1)\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    # Calculate cost difference for all three objectives\n    delta1, delta2, delta3 = edge_cost(a, b, c, d, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Apply 2-opt if it improves at least one objective\n    if any(delta < 0 for delta in [delta1, delta2, delta3]):\n        # Reverse the segment between i+1 and j\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Additional: Try inserting a node to improve the worst objective\n    worst_obj = np.argmax(archive[best_idx][1])\n    if worst_obj == 0:\n        dm = distance_matrix_1\n    elif worst_obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    # Find the node with the highest insertion cost in the worst objective\n    max_cost = -np.inf\n    best_insert_pos = -1\n    best_node = -1\n\n    for node in range(n):\n        for pos in range(n):\n            # Calculate insertion cost\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n            cost = dm[prev_node, node] + dm[node, next_node] - dm[prev_node, next_node]\n\n            if cost > max_cost:\n                max_cost = cost\n                best_insert_pos = pos\n                best_node = node\n\n    if best_node != -1:\n        # Remove the node\n        new_solution = np.delete(new_solution, best_node)\n        # Insert it at the best position\n        new_solution = np.insert(new_solution, best_insert_pos, best_node)\n\n    return new_solution\n\n",
        "score": [
            -0.6308470232680538,
            2.2537482023239135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    scores = [sum(w * obj for w, obj in zip(weights, objective)) for _, objective in archive]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two non-adjacent edges to swap\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    while j - i == 1 or j == i:  # Ensure edges are not adjacent\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Calculate potential improvement in all three objectives\n    def edge_cost(a, b, c, d, dm1, dm2, dm3):\n        return (dm1[a, b] + dm1[c, d] - dm1[a, c] - dm1[b, d],\n                dm2[a, b] + dm2[c, d] - dm2[a, c] - dm2[b, d],\n                dm3[a, b] + dm3[c, d] - dm3[a, c] - dm3[b, d])\n\n    # Current edges: (i, i+1) and (j, j+1)\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    # Calculate cost difference for all three objectives\n    delta1, delta2, delta3 = edge_cost(a, b, c, d, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Apply 2-opt if it improves at least one objective\n    if any(delta < 0 for delta in [delta1, delta2, delta3]):\n        # Reverse the segment between i+1 and j\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Additional: Try inserting a node to improve the worst objective\n    worst_obj = np.argmax(archive[best_idx][1])\n    if worst_obj == 0:\n        dm = distance_matrix_1\n    elif worst_obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    # Find the node with the highest insertion cost in the worst objective\n    max_cost = -np.inf\n    best_insert_pos = -1\n    best_node = -1\n\n    for node in range(n):\n        for pos in range(n):\n            # Calculate insertion cost\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n            cost = dm[prev_node, node] + dm[node, next_node] - dm[prev_node, next_node]\n\n            if cost > max_cost:\n                max_cost = cost\n                best_insert_pos = pos\n                best_node = node\n\n    if best_node != -1:\n        # Remove the node\n        new_solution = np.delete(new_solution, best_node)\n        # Insert it at the best position\n        new_solution = np.insert(new_solution, best_insert_pos, best_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 251,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 or all if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Randomly choose one of three operators\n    operator = np.random.choice(['2opt', 'insertion', 'swap'])\n\n    if operator == '2opt':\n        # Apply 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'insertion':\n        # Apply node insertion: remove a random node and reinsert it in a random position\n        node_idx = np.random.randint(n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        # Apply random edge swap: swap two random edges\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7125882593035382,
            1.9520175457000732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 or all if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Randomly choose one of three operators\n    operator = np.random.choice(['2opt', 'insertion', 'swap'])\n\n    if operator == '2opt':\n        # Apply 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'insertion':\n        # Apply node insertion: remove a random node and reinsert it in a random position\n        node_idx = np.random.randint(n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        # Apply random edge swap: swap two random edges\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 252,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [sum(w * obj for w, obj in zip(weights, objective)) for _, objective in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel multi-objective edge swap\n    # Select two edges that are likely to improve at least one objective\n    for _ in range(10):  # Try up to 10 times to find an improving swap\n        a, b = np.random.choice(n, size=2, replace=False)\n        c, d = np.random.choice(n, size=2, replace=False)\n\n        # Ensure we're not creating invalid edges\n        if a == b or c == d or {a, b} == {c, d}:\n            continue\n\n        # Calculate the change in objectives\n        original_costs = (\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[a], new_solution[d]] +\n            distance_matrix_1[new_solution[c], new_solution[b]],\n            distance_matrix_2[new_solution[a], new_solution[d]] +\n            distance_matrix_2[new_solution[c], new_solution[b]],\n            distance_matrix_3[new_solution[a], new_solution[d]] +\n            distance_matrix_3[new_solution[c], new_solution[b]]\n        )\n\n        # Count how many objectives improve\n        improvements = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n\n        if improvements >= 1:  # Accept if at least one objective improves\n            # Perform the swap\n            temp = new_solution[b]\n            new_solution[b] = new_solution[d]\n            new_solution[d] = temp\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7652268397732948,
            2.352301740646362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [sum(w * obj for w, obj in zip(weights, objective)) for _, objective in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel multi-objective edge swap\n    # Select two edges that are likely to improve at least one objective\n    for _ in range(10):  # Try up to 10 times to find an improving swap\n        a, b = np.random.choice(n, size=2, replace=False)\n        c, d = np.random.choice(n, size=2, replace=False)\n\n        # Ensure we're not creating invalid edges\n        if a == b or c == d or {a, b} == {c, d}:\n            continue\n\n        # Calculate the change in objectives\n        original_costs = (\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[a], new_solution[d]] +\n            distance_matrix_1[new_solution[c], new_solution[b]],\n            distance_matrix_2[new_solution[a], new_solution[d]] +\n            distance_matrix_2[new_solution[c], new_solution[b]],\n            distance_matrix_3[new_solution[a], new_solution[d]] +\n            distance_matrix_3[new_solution[c], new_solution[b]]\n        )\n\n        # Count how many objectives improve\n        improvements = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n\n        if improvements >= 1:  # Accept if at least one objective improves\n            # Perform the swap\n            temp = new_solution[b]\n            new_solution[b] = new_solution[d]\n            new_solution[d] = temp\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 253,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, objective_variance)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and insertion moves, weighted by objective variance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with higher probability for objectives with higher variance\n    for _ in range(10):  # Number of 2-opt attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate potential improvement across all objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Weighted acceptance probability based on objective variance\n        total_delta = delta1 * objective_variance[0] + delta2 * objective_variance[1] + delta3 * objective_variance[2]\n        if total_delta < 0 or np.random.rand() < 0.1:  # Accept if improvement or with small probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform insertion move with probability weighted by objective variance\n    if np.random.rand() < 0.5:\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6632608938255282,
            2.7685161232948303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, objective_variance)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and insertion moves, weighted by objective variance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with higher probability for objectives with higher variance\n    for _ in range(10):  # Number of 2-opt attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate potential improvement across all objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Weighted acceptance probability based on objective variance\n        total_delta = delta1 * objective_variance[0] + delta2 * objective_variance[1] + delta3 * objective_variance[2]\n        if total_delta < 0 or np.random.rand() < 0.1:  # Accept if improvement or with small probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform insertion move with probability weighted by objective variance\n    if np.random.rand() < 0.5:\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 254,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objective values (promising for further improvement)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity)  # Normalize weights\n\n    # Compute a score for each solution based on weighted diversity\n    scores = np.sum(weights * objectives, axis=1)\n    selected_idx = np.argmin(scores)  # Prefer solutions with lower scores (more balanced objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and insertion for multi-objective optimization\n    n = len(new_solution)\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a segment to modify\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Apply 2-opt (swap segment)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply insertion (move a random node to a new position)\n        k = np.random.randint(n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution) and np.array_equal(np.sort(new_solution), np.sort(base_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.7712795472587074,
            2.4954485177993773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objective values (promising for further improvement)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity)  # Normalize weights\n\n    # Compute a score for each solution based on weighted diversity\n    scores = np.sum(weights * objectives, axis=1)\n    selected_idx = np.argmin(scores)  # Prefer solutions with lower scores (more balanced objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and insertion for multi-objective optimization\n    n = len(new_solution)\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a segment to modify\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Apply 2-opt (swap segment)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply insertion (move a random node to a new position)\n        k = np.random.randint(n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution) and np.array_equal(np.sort(new_solution), np.sort(base_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 255,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with the worst objective value)\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_obj_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and edge insertion based on objective diversity\n        if random.random() < 0.5:\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge insertion with objective-aware selection\n            # Select a node with high potential for improvement in any objective\n            node_to_move = random.choice(new_solution)\n\n            # Find the best insertion point considering all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n):\n                if pos > 0:\n                    # Calculate cost for all three objectives\n                    cost1 = (distance_matrix_1[new_solution[pos-1], node_to_move] +\n                             distance_matrix_1[node_to_move, new_solution[pos % n]])\n                    cost2 = (distance_matrix_2[new_solution[pos-1], node_to_move] +\n                             distance_matrix_2[node_to_move, new_solution[pos % n]])\n                    cost3 = (distance_matrix_3[new_solution[pos-1], node_to_move] +\n                             distance_matrix_3[node_to_move, new_solution[pos % n]])\n\n                    total_cost = cost1 + cost2 + cost3\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = pos\n\n            # Perform the insertion\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.5822308711680522,
            1.679267132282257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with the worst objective value)\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_obj_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt and edge insertion based on objective diversity\n        if random.random() < 0.5:\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge insertion with objective-aware selection\n            # Select a node with high potential for improvement in any objective\n            node_to_move = random.choice(new_solution)\n\n            # Find the best insertion point considering all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n):\n                if pos > 0:\n                    # Calculate cost for all three objectives\n                    cost1 = (distance_matrix_1[new_solution[pos-1], node_to_move] +\n                             distance_matrix_1[node_to_move, new_solution[pos % n]])\n                    cost2 = (distance_matrix_2[new_solution[pos-1], node_to_move] +\n                             distance_matrix_2[node_to_move, new_solution[pos % n]])\n                    cost3 = (distance_matrix_3[new_solution[pos-1], node_to_move] +\n                             distance_matrix_3[node_to_move, new_solution[pos % n]])\n\n                    total_cost = cost1 + cost2 + cost3\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = pos\n\n            # Perform the insertion\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 256,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a random segment reversal and objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt like operation)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps: swap nodes that are far apart in at least one objective space\n    for _ in range(3):  # Perform 3 swaps\n        a, b = np.random.choice(range(n), 2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate the distance improvement in all three objectives\n        delta1 = (distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_b] -\n                 (distance_matrix_1[node_b, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_a]))\n\n        delta2 = (distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], node_b] -\n                 (distance_matrix_2[node_b, new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], node_a]))\n\n        delta3 = (distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], node_b] -\n                 (distance_matrix_3[node_b, new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], node_a]))\n\n        # If the swap improves at least one objective, perform it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7076944664140642,
            1.7632732033729552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a random segment reversal and objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt like operation)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps: swap nodes that are far apart in at least one objective space\n    for _ in range(3):  # Perform 3 swaps\n        a, b = np.random.choice(range(n), 2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate the distance improvement in all three objectives\n        delta1 = (distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_b] -\n                 (distance_matrix_1[node_b, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_a]))\n\n        delta2 = (distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], node_b] -\n                 (distance_matrix_2[node_b, new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], node_a]))\n\n        delta3 = (distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], node_b] -\n                 (distance_matrix_3[node_b, new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], node_a]))\n\n        # If the swap improves at least one objective, perform it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 257,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # First apply 2-opt to reduce total distance in all objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate potential improvement in all objectives\n    def calculate_improvement(sol, i, j):\n        old_cost = (distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_1[sol[j-1], sol[j]] +\n                     distance_matrix_2[sol[i-1], sol[i]] + distance_matrix_2[sol[j-1], sol[j]] +\n                     distance_matrix_3[sol[i-1], sol[i]] + distance_matrix_3[sol[j-1], sol[j]])\n        new_cost = (distance_matrix_1[sol[i-1], sol[j-1]] + distance_matrix_1[sol[i], sol[j]] +\n                     distance_matrix_2[sol[i-1], sol[j-1]] + distance_matrix_2[sol[i], sol[j]] +\n                     distance_matrix_3[sol[i-1], sol[j-1]] + distance_matrix_3[sol[i], sol[j]])\n        return new_cost - old_cost\n\n    improvement = calculate_improvement(new_solution, i, j)\n\n    if improvement < 0:  # If improvement is possible\n        new_solution[i:j] = new_solution[i:j][::-1]  # Perform 2-opt swap\n\n    # Then apply objective-aware swaps to improve specific objectives\n    # Identify which objective has the highest potential for improvement\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Select two nodes to swap based on the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the pair of nodes that would most improve the worst objective\n    best_improvement = 0\n    best_pair = (0, 1)\n\n    for k in range(n):\n        for l in range(k+1, n):\n            # Calculate potential improvement for this pair\n            old_dist = dist_matrix[new_solution[k-1], new_solution[k]] + dist_matrix[new_solution[l-1], new_solution[l]]\n            new_dist = dist_matrix[new_solution[k-1], new_solution[l]] + dist_matrix[new_solution[l-1], new_solution[k]]\n            current_improvement = old_dist - new_dist\n\n            if current_improvement > best_improvement:\n                best_improvement = current_improvement\n                best_pair = (k, l)\n\n    if best_improvement > 0:\n        k, l = best_pair\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6901774838271579,
            3.8001306653022766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # First apply 2-opt to reduce total distance in all objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate potential improvement in all objectives\n    def calculate_improvement(sol, i, j):\n        old_cost = (distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_1[sol[j-1], sol[j]] +\n                     distance_matrix_2[sol[i-1], sol[i]] + distance_matrix_2[sol[j-1], sol[j]] +\n                     distance_matrix_3[sol[i-1], sol[i]] + distance_matrix_3[sol[j-1], sol[j]])\n        new_cost = (distance_matrix_1[sol[i-1], sol[j-1]] + distance_matrix_1[sol[i], sol[j]] +\n                     distance_matrix_2[sol[i-1], sol[j-1]] + distance_matrix_2[sol[i], sol[j]] +\n                     distance_matrix_3[sol[i-1], sol[j-1]] + distance_matrix_3[sol[i], sol[j]])\n        return new_cost - old_cost\n\n    improvement = calculate_improvement(new_solution, i, j)\n\n    if improvement < 0:  # If improvement is possible\n        new_solution[i:j] = new_solution[i:j][::-1]  # Perform 2-opt swap\n\n    # Then apply objective-aware swaps to improve specific objectives\n    # Identify which objective has the highest potential for improvement\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Select two nodes to swap based on the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the pair of nodes that would most improve the worst objective\n    best_improvement = 0\n    best_pair = (0, 1)\n\n    for k in range(n):\n        for l in range(k+1, n):\n            # Calculate potential improvement for this pair\n            old_dist = dist_matrix[new_solution[k-1], new_solution[k]] + dist_matrix[new_solution[l-1], new_solution[l]]\n            new_dist = dist_matrix[new_solution[k-1], new_solution[l]] + dist_matrix[new_solution[l-1], new_solution[k]]\n            current_improvement = old_dist - new_dist\n\n            if current_improvement > best_improvement:\n                best_improvement = current_improvement\n                best_pair = (k, l)\n\n    if best_improvement > 0:\n        k, l = best_pair\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 258,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, objective_variance)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-weighted edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and objective-weighted edge swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-weighted edge swap\n        # Calculate improvement potential for each edge\n        improvements = []\n        for i in range(n):\n            for j in range(i+1, n):\n                # Calculate change in all three objectives\n                a, b, c, d = new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]\n                old_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                old_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n                old_cost3 = distance_matrix_3[a, b] + distance_matrix_3[c, d]\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n                new_cost3 = distance_matrix_3[a, c] + distance_matrix_3[b, d]\n                delta1 = new_cost1 - old_cost1\n                delta2 = new_cost2 - old_cost2\n                delta3 = new_cost3 - old_cost3\n\n                # Weighted improvement (prioritize objectives with higher variance)\n                weighted_improvement = delta1 * objective_variance[0] + delta2 * objective_variance[1] + delta3 * objective_variance[2]\n                improvements.append((weighted_improvement, i, j))\n\n        if improvements:\n            # Select the swap with the best weighted improvement\n            best_improvement, i, j = min(improvements, key=lambda x: x[0])\n            if best_improvement < 0:  # Only apply if it improves at least one objective\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6434103091776179,
            2.6909466862678526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, objective_variance)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-weighted edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and objective-weighted edge swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-weighted edge swap\n        # Calculate improvement potential for each edge\n        improvements = []\n        for i in range(n):\n            for j in range(i+1, n):\n                # Calculate change in all three objectives\n                a, b, c, d = new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]\n                old_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                old_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n                old_cost3 = distance_matrix_3[a, b] + distance_matrix_3[c, d]\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n                new_cost3 = distance_matrix_3[a, c] + distance_matrix_3[b, d]\n                delta1 = new_cost1 - old_cost1\n                delta2 = new_cost2 - old_cost2\n                delta3 = new_cost3 - old_cost3\n\n                # Weighted improvement (prioritize objectives with higher variance)\n                weighted_improvement = delta1 * objective_variance[0] + delta2 * objective_variance[1] + delta3 * objective_variance[2]\n                improvements.append((weighted_improvement, i, j))\n\n        if improvements:\n            # Select the swap with the best weighted improvement\n            best_improvement, i, j = min(improvements, key=lambda x: x[0])\n            if best_improvement < 0:  # Only apply if it improves at least one objective\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 259,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: choose edges that improve at least one objective\n    def calculate_objective(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective(base_solution)\n    new_obj = calculate_objective(new_solution)\n\n    # If improvement in at least one objective, accept; otherwise, try another swap\n    if any(new_obj[k] < current_obj[k] for k in range(3)):\n        return new_solution\n\n    # If no improvement, try a different local search operator (3-opt)\n    k = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8141051107585913,
            1.6821983098983764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: choose edges that improve at least one objective\n    def calculate_objective(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective(base_solution)\n    new_obj = calculate_objective(new_solution)\n\n    # If improvement in at least one objective, accept; otherwise, try another swap\n    if any(new_obj[k] < current_obj[k] for k in range(3)):\n        return new_solution\n\n    # If no improvement, try a different local search operator (3-opt)\n    k = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 260,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Choose two distinct edges to swap (objective-aware selection)\n    obj_weights = np.array([obj[0] + obj[1] + obj[2] for _, obj in archive]) / np.sum(objectives, axis=1)\n    obj_weights = obj_weights / np.sum(obj_weights)\n\n    if np.random.rand() < 0.7:  # 70% chance of 2-opt\n        # Select edges based on their potential improvement\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        k, l = sorted(random.sample(range(n_nodes), 2))\n\n        # Evaluate potential improvement across all objectives\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[j]] +\n                        distance_matrix_1[new_solution[k], new_solution[l]] +\n                        distance_matrix_2[new_solution[k], new_solution[l]] +\n                        distance_matrix_3[new_solution[k], new_solution[l]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                    distance_matrix_2[new_solution[i], new_solution[k]] +\n                    distance_matrix_3[new_solution[i], new_solution[k]] +\n                    distance_matrix_1[new_solution[j], new_solution[l]] +\n                    distance_matrix_2[new_solution[j], new_solution[l]] +\n                    distance_matrix_3[new_solution[j], new_solution[l]])\n\n        if new_cost < current_cost:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n            new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n    else:  # 30% chance of objective-aware node swap\n        # Select nodes to swap based on their contribution to different objectives\n        node_contributions = np.zeros(n_nodes)\n        for i in range(n_nodes):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1) % n_nodes]\n\n            # Calculate contribution to each objective\n            contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                      distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                      distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n            node_contributions[i] = contrib\n\n        # Select nodes with high contribution to swap\n        high_contrib_nodes = np.argsort(node_contributions)[-2:]\n        new_solution[high_contrib_nodes[0]], new_solution[high_contrib_nodes[1]] = (\n            new_solution[high_contrib_nodes[1]], new_solution[high_contrib_nodes[0]])\n\n    return new_solution\n\n",
        "score": [
            -0.6724615079776812,
            2.1241316318511965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Choose two distinct edges to swap (objective-aware selection)\n    obj_weights = np.array([obj[0] + obj[1] + obj[2] for _, obj in archive]) / np.sum(objectives, axis=1)\n    obj_weights = obj_weights / np.sum(obj_weights)\n\n    if np.random.rand() < 0.7:  # 70% chance of 2-opt\n        # Select edges based on their potential improvement\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        k, l = sorted(random.sample(range(n_nodes), 2))\n\n        # Evaluate potential improvement across all objectives\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[j]] +\n                        distance_matrix_1[new_solution[k], new_solution[l]] +\n                        distance_matrix_2[new_solution[k], new_solution[l]] +\n                        distance_matrix_3[new_solution[k], new_solution[l]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                    distance_matrix_2[new_solution[i], new_solution[k]] +\n                    distance_matrix_3[new_solution[i], new_solution[k]] +\n                    distance_matrix_1[new_solution[j], new_solution[l]] +\n                    distance_matrix_2[new_solution[j], new_solution[l]] +\n                    distance_matrix_3[new_solution[j], new_solution[l]])\n\n        if new_cost < current_cost:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n            new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n    else:  # 30% chance of objective-aware node swap\n        # Select nodes to swap based on their contribution to different objectives\n        node_contributions = np.zeros(n_nodes)\n        for i in range(n_nodes):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1) % n_nodes]\n\n            # Calculate contribution to each objective\n            contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                      distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                      distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n            node_contributions[i] = contrib\n\n        # Select nodes with high contribution to swap\n        high_contrib_nodes = np.argsort(node_contributions)[-2:]\n        new_solution[high_contrib_nodes[0]], new_solution[high_contrib_nodes[1]] = (\n            new_solution[high_contrib_nodes[1]], new_solution[high_contrib_nodes[0]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 261,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = [sum(w * obj for w, obj in zip(weights, obj_tuple)) for _, obj_tuple in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with a twist for multi-objective optimization\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Additionally, consider swapping two nodes that are far apart in at least one objective space\n    # to encourage diversity and better exploration\n    if np.random.random() < 0.3:  # 30% chance to apply this additional move\n        # Find the pair of nodes with the maximum distance in any objective space\n        max_dist = -1\n        a, b = 0, 0\n        for k in range(n):\n            for l in range(k+1, n):\n                dist1 = distance_matrix_1[new_solution[k], new_solution[l]]\n                dist2 = distance_matrix_2[new_solution[k], new_solution[l]]\n                dist3 = distance_matrix_3[new_solution[k], new_solution[l]]\n                if max(dist1, dist2, dist3) > max_dist:\n                    max_dist = max(dist1, dist2, dist3)\n                    a, b = k, l\n        # Swap the nodes to reduce the maximum distance\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7573962650256297,
            2.909831690788269
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    weighted_scores = [sum(w * obj for w, obj in zip(weights, obj_tuple)) for _, obj_tuple in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with a twist for multi-objective optimization\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Additionally, consider swapping two nodes that are far apart in at least one objective space\n    # to encourage diversity and better exploration\n    if np.random.random() < 0.3:  # 30% chance to apply this additional move\n        # Find the pair of nodes with the maximum distance in any objective space\n        max_dist = -1\n        a, b = 0, 0\n        for k in range(n):\n            for l in range(k+1, n):\n                dist1 = distance_matrix_1[new_solution[k], new_solution[l]]\n                dist2 = distance_matrix_2[new_solution[k], new_solution[l]]\n                dist3 = distance_matrix_3[new_solution[k], new_solution[l]]\n                if max(dist1, dist2, dist3) > max_dist:\n                    max_dist = max(dist1, dist2, dist3)\n                    a, b = k, l\n        # Swap the nodes to reduce the maximum distance\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 262,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 2:\n        # Sort by the sum of objectives to find solutions in the middle of the Pareto front\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the middle 60% of the archive to balance exploration and exploitation\n        candidate_indices = range(len(archive) // 5, len(archive) * 4 // 5)\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine the best operator based on the objectives\n        # Calculate the current costs for each objective\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Choose the operator that can most improve the worst-performing objective\n        worst_objective = np.argmax([current_cost1, current_cost2, current_cost3])\n\n        if worst_objective == 0:\n            # 2-opt for the first objective space\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif worst_objective == 1:\n            # Node insertion for the second objective space\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n        else:\n            # Or-opt (or 3-opt) for the third objective space\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.794288303143567,
            1.844723916053772
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 2:\n        # Sort by the sum of objectives to find solutions in the middle of the Pareto front\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the middle 60% of the archive to balance exploration and exploitation\n        candidate_indices = range(len(archive) // 5, len(archive) * 4 // 5)\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine the best operator based on the objectives\n        # Calculate the current costs for each objective\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Choose the operator that can most improve the worst-performing objective\n        worst_objective = np.argmax([current_cost1, current_cost2, current_cost3])\n\n        if worst_objective == 0:\n            # 2-opt for the first objective space\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif worst_objective == 1:\n            # Node insertion for the second objective space\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n        else:\n            # Or-opt (or 3-opt) for the third objective space\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 263,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from scipy.stats import rankdata\n\n    # Select a solution with high potential for improvement\n    if len(archive) > 1:\n        # Rank solutions based on objective values (lower is better)\n        objectives = np.array([obj for _, obj in archive])\n        ranks = np.zeros_like(objectives)\n        for i in range(3):\n            ranks[:, i] = rankdata(objectives[:, i], method='min')\n\n        # Calculate a composite score (lower is better)\n        scores = np.sum(ranks, axis=1)\n        # Select top 30% of solutions with the highest potential\n        threshold = np.percentile(scores, 30)\n        candidates = [sol for (sol, _), score in zip(archive, scores) if score <= threshold]\n\n        if candidates:\n            base_solution = random.choice(candidates).copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for objective-aware swap\n        # Calculate edge costs in all three objectives\n        edge_costs = np.zeros(n)\n        for k in range(n):\n            prev = new_solution[k-1]\n            curr = new_solution[k]\n            next_node = new_solution[(k+1) % n]\n            # Sum of edge costs in all three objectives\n            edge_costs[k] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] +\n                           distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node])\n\n        # Find the node with the highest edge cost (most critical for improvement)\n        critical_node = np.argmax(edge_costs)\n        # Swap with a random neighbor to diversify\n        neighbor = random.choice([(critical_node-1) % n, (critical_node+1) % n])\n        new_solution[critical_node], new_solution[neighbor] = new_solution[neighbor], new_solution[critical_node]\n\n    return new_solution\n\n",
        "score": [
            -0.6796568361514777,
            3.1373443603515625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from scipy.stats import rankdata\n\n    # Select a solution with high potential for improvement\n    if len(archive) > 1:\n        # Rank solutions based on objective values (lower is better)\n        objectives = np.array([obj for _, obj in archive])\n        ranks = np.zeros_like(objectives)\n        for i in range(3):\n            ranks[:, i] = rankdata(objectives[:, i], method='min')\n\n        # Calculate a composite score (lower is better)\n        scores = np.sum(ranks, axis=1)\n        # Select top 30% of solutions with the highest potential\n        threshold = np.percentile(scores, 30)\n        candidates = [sol for (sol, _), score in zip(archive, scores) if score <= threshold]\n\n        if candidates:\n            base_solution = random.choice(candidates).copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for objective-aware swap\n        # Calculate edge costs in all three objectives\n        edge_costs = np.zeros(n)\n        for k in range(n):\n            prev = new_solution[k-1]\n            curr = new_solution[k]\n            next_node = new_solution[(k+1) % n]\n            # Sum of edge costs in all three objectives\n            edge_costs[k] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] +\n                           distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node])\n\n        # Find the node with the highest edge cost (most critical for improvement)\n        critical_node = np.argmax(edge_costs)\n        # Swap with a random neighbor to diversify\n        neighbor = random.choice([(critical_node-1) % n, (critical_node+1) % n])\n        new_solution[critical_node], new_solution[neighbor] = new_solution[neighbor], new_solution[critical_node]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 264,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with lower objectives)\n    archive.sort(key=lambda x: sum(x[1]))  # Sort by sum of objectives (can be replaced with other criteria)\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and edge swapping\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt move (local improvement)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge swapping based on multiple objectives (novel approach)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n\n    # Calculate edge improvements across all three objectives\n    def edge_improvement(sol, i1, i2, j1, j2):\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[sol[i1], sol[j1]] + distance_matrix_1[sol[i2], sol[j2]]\n                 - distance_matrix_1[sol[i1], sol[i2]] - distance_matrix_1[sol[j1], sol[j2]])\n        delta2 = (distance_matrix_2[sol[i1], sol[j1]] + distance_matrix_2[sol[i2], sol[j2]]\n                 - distance_matrix_2[sol[i1], sol[i2]] - distance_matrix_2[sol[j1], sol[j2]])\n        delta3 = (distance_matrix_3[sol[i1], sol[j1]] + distance_matrix_3[sol[i2], sol[j2]]\n                 - distance_matrix_3[sol[i1], sol[i2]] - distance_matrix_3[sol[j1], sol[j2]])\n        return delta1, delta2, delta3\n\n    # Try to find an improving edge swap\n    for _ in range(10):  # Limit the number of attempts\n        i1, i2 = np.random.choice(n, 2, replace=False)\n        j1, j2 = np.random.choice(n, 2, replace=False)\n\n        delta1, delta2, delta3 = edge_improvement(new_solution, i1, i2, j1, j2)\n\n        # Accept if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            temp = new_solution[i1]\n            new_solution[i1] = new_solution[j1]\n            new_solution[j1] = temp\n            break\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8151335661947761,
            1.9166044473648072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with lower objectives)\n    archive.sort(key=lambda x: sum(x[1]))  # Sort by sum of objectives (can be replaced with other criteria)\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and edge swapping\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt move (local improvement)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge swapping based on multiple objectives (novel approach)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n\n    # Calculate edge improvements across all three objectives\n    def edge_improvement(sol, i1, i2, j1, j2):\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[sol[i1], sol[j1]] + distance_matrix_1[sol[i2], sol[j2]]\n                 - distance_matrix_1[sol[i1], sol[i2]] - distance_matrix_1[sol[j1], sol[j2]])\n        delta2 = (distance_matrix_2[sol[i1], sol[j1]] + distance_matrix_2[sol[i2], sol[j2]]\n                 - distance_matrix_2[sol[i1], sol[i2]] - distance_matrix_2[sol[j1], sol[j2]])\n        delta3 = (distance_matrix_3[sol[i1], sol[j1]] + distance_matrix_3[sol[i2], sol[j2]]\n                 - distance_matrix_3[sol[i1], sol[i2]] - distance_matrix_3[sol[j1], sol[j2]])\n        return delta1, delta2, delta3\n\n    # Try to find an improving edge swap\n    for _ in range(10):  # Limit the number of attempts\n        i1, i2 = np.random.choice(n, 2, replace=False)\n        j1, j2 = np.random.choice(n, 2, replace=False)\n\n        delta1, delta2, delta3 = edge_improvement(new_solution, i1, i2, j1, j2)\n\n        # Accept if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            temp = new_solution[i1]\n            new_solution[i1] = new_solution[j1]\n            new_solution[j1] = temp\n            break\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 265,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Objective-aware 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if j - i > 1:\n        # Evaluate the move across all objectives\n        old_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        if new_costs < old_costs:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap move\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if k != l:\n        # Evaluate the move across all objectives\n        old_costs = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]] +\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]] +\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        )\n\n        if new_costs < old_costs:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.4899636964008233,
            1.7098463773727417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Objective-aware 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if j - i > 1:\n        # Evaluate the move across all objectives\n        old_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        if new_costs < old_costs:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap move\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if k != l:\n        # Evaluate the move across all objectives\n        old_costs = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]] +\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]] +\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        )\n\n        if new_costs < old_costs:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 266,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy combining 2-opt, 3-opt, and objective-aware swaps\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for improvement\n        obj = archive[selected_idx][1]\n        obj_weights = np.array(obj) / np.sum(obj)\n\n        # With probability proportional to objective weights, perform a specialized operation\n        operation = random.choices(\n            ['2opt', '3opt', 'objective_aware_swap'],\n            weights=obj_weights,\n            k=1\n        )[0]\n\n        if operation == '2opt':\n            # Standard 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif operation == '3opt':\n            # 3-opt move (more complex but potentially better)\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            # Objective-aware swap: swap nodes that are \"outliers\" in the worst objective\n            worst_obj = np.argmax(obj)\n            if worst_obj == 0:\n                dist_matrix = distance_matrix_1\n            elif worst_obj == 1:\n                dist_matrix = distance_matrix_2\n            else:\n                dist_matrix = distance_matrix_3\n\n            # Find the pair of nodes that would most improve the worst objective\n            max_improvement = -1\n            best_pair = (0, 1)\n            for i in range(n):\n                for j in range(i+1, n):\n                    original_cost = (dist_matrix[new_solution[i-1], new_solution[i]] +\n                                   dist_matrix[new_solution[j-1], new_solution[j]] +\n                                   dist_matrix[new_solution[i], new_solution[j]])\n                    swapped_cost = (dist_matrix[new_solution[i-1], new_solution[j]] +\n                                   dist_matrix[new_solution[j-1], new_solution[i]] +\n                                   dist_matrix[new_solution[j], new_solution[i]])\n                    improvement = original_cost - swapped_cost\n                    if improvement > max_improvement:\n                        max_improvement = improvement\n                        best_pair = (i, j)\n\n            if max_improvement > 0:\n                i, j = best_pair\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7283303594557518,
            1.6941354990005493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy combining 2-opt, 3-opt, and objective-aware swaps\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for improvement\n        obj = archive[selected_idx][1]\n        obj_weights = np.array(obj) / np.sum(obj)\n\n        # With probability proportional to objective weights, perform a specialized operation\n        operation = random.choices(\n            ['2opt', '3opt', 'objective_aware_swap'],\n            weights=obj_weights,\n            k=1\n        )[0]\n\n        if operation == '2opt':\n            # Standard 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif operation == '3opt':\n            # 3-opt move (more complex but potentially better)\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            # Objective-aware swap: swap nodes that are \"outliers\" in the worst objective\n            worst_obj = np.argmax(obj)\n            if worst_obj == 0:\n                dist_matrix = distance_matrix_1\n            elif worst_obj == 1:\n                dist_matrix = distance_matrix_2\n            else:\n                dist_matrix = distance_matrix_3\n\n            # Find the pair of nodes that would most improve the worst objective\n            max_improvement = -1\n            best_pair = (0, 1)\n            for i in range(n):\n                for j in range(i+1, n):\n                    original_cost = (dist_matrix[new_solution[i-1], new_solution[i]] +\n                                   dist_matrix[new_solution[j-1], new_solution[j]] +\n                                   dist_matrix[new_solution[i], new_solution[j]])\n                    swapped_cost = (dist_matrix[new_solution[i-1], new_solution[j]] +\n                                   dist_matrix[new_solution[j-1], new_solution[i]] +\n                                   dist_matrix[new_solution[j], new_solution[i]])\n                    improvement = original_cost - swapped_cost\n                    if improvement > max_improvement:\n                        max_improvement = improvement\n                        best_pair = (i, j)\n\n            if max_improvement > 0:\n                i, j = best_pair\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 267,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives (prioritize solutions with lower total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify (2-opt inspired)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Reverse the segment\n\n    # Objective-aware edge swap: try to improve the solution in all three objectives\n    for _ in range(3):  # Try a few objective-aware swaps\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs in all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        potential_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        if potential_cost < current_cost:\n            # Swap edges if it improves the total cost\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.667067411951326,
            1.2772991895675658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives (prioritize solutions with lower total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify (2-opt inspired)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Reverse the segment\n\n    # Objective-aware edge swap: try to improve the solution in all three objectives\n    for _ in range(3):  # Try a few objective-aware swaps\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs in all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        potential_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        if potential_cost < current_cost:\n            # Swap edges if it improves the total cost\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 268,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    n = len(base_solution)\n\n    # First, perform standard 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel multi-objective edge swap\n    # Select two edges that are critical in at least one objective\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Calculate edge costs in all three objectives\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        # Current edges\n        old_edges = [\n            edge_cost(base_solution[a], base_solution[(a+1)%n]),\n            edge_cost(base_solution[b], base_solution[(b+1)%n]),\n            edge_cost(base_solution[c], base_solution[(c+1)%n]),\n            edge_cost(base_solution[d], base_solution[(d+1)%n])\n        ]\n\n        # Proposed edges\n        new_edges = [\n            edge_cost(base_solution[a], base_solution[c]),\n            edge_cost(base_solution[b], base_solution[d]),\n            edge_cost(base_solution[a], base_solution[b]),\n            edge_cost(base_solution[c], base_solution[d])\n        ]\n\n        # Calculate improvement in each objective\n        improvements = [\n            sum(new - old for new, old in zip(new_edges[i], old_edges[i]))\n            for i in range(4)\n        ]\n\n        # If at least one objective improves, perform the swap\n        if any(improvement < 0 for improvement in improvements):\n            # Perform the swap\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.7930987855335285,
            1.4421815872192383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    n = len(base_solution)\n\n    # First, perform standard 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel multi-objective edge swap\n    # Select two edges that are critical in at least one objective\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Calculate edge costs in all three objectives\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        # Current edges\n        old_edges = [\n            edge_cost(base_solution[a], base_solution[(a+1)%n]),\n            edge_cost(base_solution[b], base_solution[(b+1)%n]),\n            edge_cost(base_solution[c], base_solution[(c+1)%n]),\n            edge_cost(base_solution[d], base_solution[(d+1)%n])\n        ]\n\n        # Proposed edges\n        new_edges = [\n            edge_cost(base_solution[a], base_solution[c]),\n            edge_cost(base_solution[b], base_solution[d]),\n            edge_cost(base_solution[a], base_solution[b]),\n            edge_cost(base_solution[c], base_solution[d])\n        ]\n\n        # Calculate improvement in each objective\n        improvements = [\n            sum(new - old for new, old in zip(new_edges[i], old_edges[i]))\n            for i in range(4)\n        ]\n\n        # If at least one objective improves, perform the swap\n        if any(improvement < 0 for improvement in improvements):\n            # Perform the swap\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 269,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (simplified for this example)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]), reverse=True)\n        # Select a solution that is not the best in all objectives\n        selected_idx = min(1, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment and reverse it (2-opt local search)\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Randomly swap two nodes (to escape local optima)\n    if np.random.rand() < 0.3:  # 30% chance to perform swap\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Randomly select a node and insert it elsewhere (to improve multi-objective performance)\n    if np.random.rand() < 0.5:  # 50% chance to perform insertion\n        m = np.random.randint(0, n)\n        node = new_solution[m]\n        new_solution = np.delete(new_solution, m)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.5366809166622096,
            1.5476255655288695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (simplified for this example)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]), reverse=True)\n        # Select a solution that is not the best in all objectives\n        selected_idx = min(1, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment and reverse it (2-opt local search)\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Randomly swap two nodes (to escape local optima)\n    if np.random.rand() < 0.3:  # 30% chance to perform swap\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # 3. Randomly select a node and insert it elsewhere (to improve multi-objective performance)\n    if np.random.rand() < 0.5:  # 50% chance to perform insertion\n        m = np.random.randint(0, n)\n        node = new_solution[m]\n        new_solution = np.delete(new_solution, m)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 270,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest crowding distance in the archive (promising for further improvement)\n    crowding_distances = []\n    for sol, _ in archive:\n        crowding = 0.0\n        for i in range(1, len(sol) - 1):\n            prev_node = sol[i-1]\n            next_node = sol[i+1]\n            crowding += (distance_matrix_1[prev_node, next_node] +\n                         distance_matrix_2[prev_node, next_node] +\n                         distance_matrix_3[prev_node, next_node])\n        crowding_distances.append(crowding)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a multi-objective aware local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random segments to swap (ensuring feasibility)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform a segment swap between segments [a:b] and [c:d]\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Reconstruct the solution with swapped segments\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b:c],\n        segment1,\n        new_solution[d:]\n    ])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7132247369276195,
            3.530370533466339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest crowding distance in the archive (promising for further improvement)\n    crowding_distances = []\n    for sol, _ in archive:\n        crowding = 0.0\n        for i in range(1, len(sol) - 1):\n            prev_node = sol[i-1]\n            next_node = sol[i+1]\n            crowding += (distance_matrix_1[prev_node, next_node] +\n                         distance_matrix_2[prev_node, next_node] +\n                         distance_matrix_3[prev_node, next_node])\n        crowding_distances.append(crowding)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a multi-objective aware local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random segments to swap (ensuring feasibility)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform a segment swap between segments [a:b] and [c:d]\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Reconstruct the solution with swapped segments\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b:c],\n        segment1,\n        new_solution[d:]\n    ])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 271,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    weights = variance / np.sum(variance)  # Normalize variance to get weights\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Randomly select a segment to perturb (smaller segment for more fine-grained changes)\n    segment_length = max(3, n // 10)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # 2. Apply different operators based on the objective space with highest variance\n    dominant_obj = np.argmax(variance)\n\n    if dominant_obj == 0:\n        # For the first objective, use 2-opt with distance matrix 1\n        i, j = np.random.choice(np.arange(start, end), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif dominant_obj == 1:\n        # For the second objective, use a combination of 2-opt and insertion\n        i, j = np.random.choice(np.arange(start, end), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Additional insertion step\n        k = np.random.randint(start, end)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # For the third objective, use a more aggressive operator: 3-opt\n        i, j, k = np.random.choice(np.arange(start, end), 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.5965110508800346,
            1.9914100289344787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    weights = variance / np.sum(variance)  # Normalize variance to get weights\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Randomly select a segment to perturb (smaller segment for more fine-grained changes)\n    segment_length = max(3, n // 10)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # 2. Apply different operators based on the objective space with highest variance\n    dominant_obj = np.argmax(variance)\n\n    if dominant_obj == 0:\n        # For the first objective, use 2-opt with distance matrix 1\n        i, j = np.random.choice(np.arange(start, end), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif dominant_obj == 1:\n        # For the second objective, use a combination of 2-opt and insertion\n        i, j = np.random.choice(np.arange(start, end), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Additional insertion step\n        k = np.random.randint(start, end)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # For the third objective, use a more aggressive operator: 3-opt\n        i, j, k = np.random.choice(np.arange(start, end), 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 272,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions with high potential for improvement\n    # Here, we prioritize solutions that are not too close to the current Pareto front\n    # by selecting a solution with a high average objective value\n    objectives = [obj for (sol, obj) in archive]\n    avg_objectives = [sum(obj) / len(obj) for obj in objectives]\n    selected_idx = np.argmax(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve one of the objectives\n    # Choose the objective with the highest current value to prioritize\n    obj_idx = np.argmax(archive[selected_idx][1])\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the selected objective\n    best_delta = 0\n    best_i, best_j = 0, 0\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the change in total distance for the selected objective\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n            delta = (dist_matrix[a, d] + dist_matrix[b, c]) - (dist_matrix[a, b] + dist_matrix[c, d])\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_delta < 0:  # Only perform the move if it improves the selected objective\n        # Perform the 2-opt swap\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Second, apply a novel multi-objective edge selection to further improve the solution\n    # This step considers all three objectives simultaneously\n    for _ in range(2):  # Limit the number of attempts to balance exploration and exploitation\n        # Select two random edges to consider for swapping\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        a, b = new_solution[i], new_solution[i+1]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        delta1 = (distance_matrix_1[a, d] + distance_matrix_1[b, c]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, d] + distance_matrix_2[b, c]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, d] + distance_matrix_3[b, c]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n        # Only perform the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.708850648184008,
            2.20332065820694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions with high potential for improvement\n    # Here, we prioritize solutions that are not too close to the current Pareto front\n    # by selecting a solution with a high average objective value\n    objectives = [obj for (sol, obj) in archive]\n    avg_objectives = [sum(obj) / len(obj) for obj in objectives]\n    selected_idx = np.argmax(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve one of the objectives\n    # Choose the objective with the highest current value to prioritize\n    obj_idx = np.argmax(archive[selected_idx][1])\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the selected objective\n    best_delta = 0\n    best_i, best_j = 0, 0\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the change in total distance for the selected objective\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n            delta = (dist_matrix[a, d] + dist_matrix[b, c]) - (dist_matrix[a, b] + dist_matrix[c, d])\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_delta < 0:  # Only perform the move if it improves the selected objective\n        # Perform the 2-opt swap\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Second, apply a novel multi-objective edge selection to further improve the solution\n    # This step considers all three objectives simultaneously\n    for _ in range(2):  # Limit the number of attempts to balance exploration and exploitation\n        # Select two random edges to consider for swapping\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        a, b = new_solution[i], new_solution[i+1]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        delta1 = (distance_matrix_1[a, d] + distance_matrix_1[b, c]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, d] + distance_matrix_2[b, c]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, d] + distance_matrix_3[b, c]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n        # Only perform the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 273,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = archive[np.random.choice(len(archive))][0].copy()\n\n    # Hybrid local search strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between 2-opt or 3-opt move\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        # 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply 3-opt transformation\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7764795371410715,
            1.7623343825340272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = archive[np.random.choice(len(archive))][0].copy()\n\n    # Hybrid local search strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between 2-opt or 3-opt move\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        # 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply 3-opt transformation\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 274,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a multi-objective aware swap\n    # Select nodes based on their contribution to the objectives\n    # Calculate the total contribution of each node to the objectives\n    contributions = np.zeros(n)\n    for k in range(n):\n        prev_node = new_solution[k-1]\n        next_node = new_solution[(k+1)%n]\n        contributions[k] = (distance_matrix_1[prev_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node] +\n                            distance_matrix_2[prev_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node] +\n                            distance_matrix_3[prev_node, new_solution[k]] + distance_matrix_3[new_solution[k], next_node])\n\n    # Find the two nodes with the highest contributions (potential for improvement)\n    swap_indices = np.argsort(contributions)[-2:]\n\n    # Perform the swap if it improves any objective\n    if len(swap_indices) == 2:\n        a, b = swap_indices\n        # Calculate the change in objectives\n        prev_a, next_a = new_solution[a-1], new_solution[(a+1)%n]\n        prev_b, next_b = new_solution[b-1], new_solution[(b+1)%n]\n\n        old_cost = (distance_matrix_1[prev_a, new_solution[a]] + distance_matrix_1[new_solution[a], next_a] +\n                     distance_matrix_2[prev_a, new_solution[a]] + distance_matrix_2[new_solution[a], next_a] +\n                     distance_matrix_3[prev_a, new_solution[a]] + distance_matrix_3[new_solution[a], next_a] +\n                     distance_matrix_1[prev_b, new_solution[b]] + distance_matrix_1[new_solution[b], next_b] +\n                     distance_matrix_2[prev_b, new_solution[b]] + distance_matrix_2[new_solution[b], next_b] +\n                     distance_matrix_3[prev_b, new_solution[b]] + distance_matrix_3[new_solution[b], next_b])\n\n        new_cost = (distance_matrix_1[prev_a, new_solution[b]] + distance_matrix_1[new_solution[b], next_a] +\n                    distance_matrix_2[prev_a, new_solution[b]] + distance_matrix_2[new_solution[b], next_a] +\n                    distance_matrix_3[prev_a, new_solution[b]] + distance_matrix_3[new_solution[b], next_a] +\n                    distance_matrix_1[prev_b, new_solution[a]] + distance_matrix_1[new_solution[a], next_b] +\n                    distance_matrix_2[prev_b, new_solution[a]] + distance_matrix_2[new_solution[a], next_b] +\n                    distance_matrix_3[prev_b, new_solution[a]] + distance_matrix_3[new_solution[a], next_b])\n\n        if new_cost < old_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7255960357917391,
            1.9809966325759887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a multi-objective aware swap\n    # Select nodes based on their contribution to the objectives\n    # Calculate the total contribution of each node to the objectives\n    contributions = np.zeros(n)\n    for k in range(n):\n        prev_node = new_solution[k-1]\n        next_node = new_solution[(k+1)%n]\n        contributions[k] = (distance_matrix_1[prev_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node] +\n                            distance_matrix_2[prev_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node] +\n                            distance_matrix_3[prev_node, new_solution[k]] + distance_matrix_3[new_solution[k], next_node])\n\n    # Find the two nodes with the highest contributions (potential for improvement)\n    swap_indices = np.argsort(contributions)[-2:]\n\n    # Perform the swap if it improves any objective\n    if len(swap_indices) == 2:\n        a, b = swap_indices\n        # Calculate the change in objectives\n        prev_a, next_a = new_solution[a-1], new_solution[(a+1)%n]\n        prev_b, next_b = new_solution[b-1], new_solution[(b+1)%n]\n\n        old_cost = (distance_matrix_1[prev_a, new_solution[a]] + distance_matrix_1[new_solution[a], next_a] +\n                     distance_matrix_2[prev_a, new_solution[a]] + distance_matrix_2[new_solution[a], next_a] +\n                     distance_matrix_3[prev_a, new_solution[a]] + distance_matrix_3[new_solution[a], next_a] +\n                     distance_matrix_1[prev_b, new_solution[b]] + distance_matrix_1[new_solution[b], next_b] +\n                     distance_matrix_2[prev_b, new_solution[b]] + distance_matrix_2[new_solution[b], next_b] +\n                     distance_matrix_3[prev_b, new_solution[b]] + distance_matrix_3[new_solution[b], next_b])\n\n        new_cost = (distance_matrix_1[prev_a, new_solution[b]] + distance_matrix_1[new_solution[b], next_a] +\n                    distance_matrix_2[prev_a, new_solution[b]] + distance_matrix_2[new_solution[b], next_a] +\n                    distance_matrix_3[prev_a, new_solution[b]] + distance_matrix_3[new_solution[b], next_a] +\n                    distance_matrix_1[prev_b, new_solution[a]] + distance_matrix_1[new_solution[a], next_b] +\n                    distance_matrix_2[prev_b, new_solution[a]] + distance_matrix_2[new_solution[a], next_b] +\n                    distance_matrix_3[prev_b, new_solution[a]] + distance_matrix_3[new_solution[a], next_b])\n\n        if new_cost < old_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 275,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance or random if all are non-dominated\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution in the archive\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            normalized_diff = (objectives[sorted_indices, m].max() - objectives[sorted_indices, m].min())\n            if normalized_diff == 0:\n                continue\n            crowding_distances[sorted_indices[1:-1]] += (objectives[sorted_indices[2:], m] - objectives[sorted_indices[:-2], m]) / normalized_diff\n\n        # Select the solution with the highest crowding distance (promising for improvement)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Choose between 2-opt and 3-opt based on objective diversity\n    if np.random.random() < 0.7:  # Higher chance for 2-opt (more local but faster)\n        # 2-opt: reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt: apply a more complex move\n        if i < k < j:\n            # Case 1: i < k < j\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k+1:j+1] = new_solution[k+1:j+1][::-1]\n        else:\n            # Case 2: k < i < j or other permutations\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.4853075263998277,
            1.7581719517707826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance or random if all are non-dominated\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution in the archive\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            normalized_diff = (objectives[sorted_indices, m].max() - objectives[sorted_indices, m].min())\n            if normalized_diff == 0:\n                continue\n            crowding_distances[sorted_indices[1:-1]] += (objectives[sorted_indices[2:], m] - objectives[sorted_indices[:-2], m]) / normalized_diff\n\n        # Select the solution with the highest crowding distance (promising for improvement)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Choose between 2-opt and 3-opt based on objective diversity\n    if np.random.random() < 0.7:  # Higher chance for 2-opt (more local but faster)\n        # 2-opt: reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt: apply a more complex move\n        if i < k < j:\n            # Case 1: i < k < j\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k+1:j+1] = new_solution[k+1:j+1][::-1]\n        else:\n            # Case 2: k < i < j or other permutations\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 276,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already well-optimized in all objectives)\n    def potential_score(solution_obj):\n        # Simple heuristic: sum of normalized objective values (lower is better)\n        return sum(solution_obj) / (sum(solution_obj) + 1e-6)  # Avoid division by zero\n\n    # Sort solutions by their potential score (descending)\n    archive_sorted = sorted(archive, key=lambda x: -potential_score(x[1]))\n\n    # Select top 20% of solutions with highest potential\n    top_k = max(1, len(archive_sorted) // 5)\n    selected_solutions = archive_sorted[:top_k]\n\n    # Randomly select one of the top solutions\n    base_solution, _ = random.choice(selected_solutions)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly choose between 2-opt or node insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion: move a random node to a new position\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid (no duplicate nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6456576290739073,
            1.4009695410728455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already well-optimized in all objectives)\n    def potential_score(solution_obj):\n        # Simple heuristic: sum of normalized objective values (lower is better)\n        return sum(solution_obj) / (sum(solution_obj) + 1e-6)  # Avoid division by zero\n\n    # Sort solutions by their potential score (descending)\n    archive_sorted = sorted(archive, key=lambda x: -potential_score(x[1]))\n\n    # Select top 20% of solutions with highest potential\n    top_k = max(1, len(archive_sorted) // 5)\n    selected_solutions = archive_sorted[:top_k]\n\n    # Randomly select one of the top solutions\n    base_solution, _ = random.choice(selected_solutions)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly choose between 2-opt or node insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion: move a random node to a new position\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid (no duplicate nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 277,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Apply 2-opt move (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify worst segments in each objective\n    def calculate_segment_cost(solution, d1, d2, d3):\n        cost1 = sum(d1[solution[k], solution[k+1]] for k in range(len(solution)-1)) + d1[solution[-1], solution[0]]\n        cost2 = sum(d2[solution[k], solution[k+1]] for k in range(len(solution)-1)) + d2[solution[-1], solution[0]]\n        cost3 = sum(d3[solution[k], solution[k+1]] for k in range(len(solution)-1)) + d3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    original_cost = calculate_segment_cost(new_solution, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Find the worst objective and try to improve it\n    worst_obj = np.argmax(original_cost)\n\n    # Find the edge with highest cost in the worst objective\n    if worst_obj == 0:\n        d_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        d_matrix = distance_matrix_2\n    else:\n        d_matrix = distance_matrix_3\n\n    max_cost_edge = 0\n    max_cost = d_matrix[new_solution[-1], new_solution[0]]\n    for k in range(n-1):\n        current_cost = d_matrix[new_solution[k], new_solution[k+1]]\n        if current_cost > max_cost:\n            max_cost = current_cost\n            max_cost_edge = k\n\n    # Perform a swap to try to reduce the worst segment\n    if max_cost_edge < n-2:\n        new_solution[max_cost_edge], new_solution[max_cost_edge+1] = new_solution[max_cost_edge+1], new_solution[max_cost_edge]\n    else:\n        new_solution[-1], new_solution[0] = new_solution[0], new_solution[-1]\n\n    # Verify the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid - contains duplicate nodes\")\n\n    return new_solution\n\n",
        "score": [
            -0.770317905225495,
            1.4865979313850404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Apply 2-opt move (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify worst segments in each objective\n    def calculate_segment_cost(solution, d1, d2, d3):\n        cost1 = sum(d1[solution[k], solution[k+1]] for k in range(len(solution)-1)) + d1[solution[-1], solution[0]]\n        cost2 = sum(d2[solution[k], solution[k+1]] for k in range(len(solution)-1)) + d2[solution[-1], solution[0]]\n        cost3 = sum(d3[solution[k], solution[k+1]] for k in range(len(solution)-1)) + d3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    original_cost = calculate_segment_cost(new_solution, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Find the worst objective and try to improve it\n    worst_obj = np.argmax(original_cost)\n\n    # Find the edge with highest cost in the worst objective\n    if worst_obj == 0:\n        d_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        d_matrix = distance_matrix_2\n    else:\n        d_matrix = distance_matrix_3\n\n    max_cost_edge = 0\n    max_cost = d_matrix[new_solution[-1], new_solution[0]]\n    for k in range(n-1):\n        current_cost = d_matrix[new_solution[k], new_solution[k+1]]\n        if current_cost > max_cost:\n            max_cost = current_cost\n            max_cost_edge = k\n\n    # Perform a swap to try to reduce the worst segment\n    if max_cost_edge < n-2:\n        new_solution[max_cost_edge], new_solution[max_cost_edge+1] = new_solution[max_cost_edge+1], new_solution[max_cost_edge]\n    else:\n        new_solution[-1], new_solution[0] = new_solution[0], new_solution[-1]\n\n    # Verify the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid - contains duplicate nodes\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 278,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate a combined objective score to identify promising solutions\n    combined_scores = [sum(obj) for obj in objectives]\n    max_score = max(combined_scores)\n    promising_indices = [i for i, score in enumerate(combined_scores) if score >= max_score * 0.9]\n\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n\n    selected_idx = random.choice(promising_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 5, n - 1))  # Limit segment length for efficiency\n\n    # Apply a 2-opt move within the selected segment\n    if end - start >= 2:\n        i, j = random.sample(range(start, end), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a node swap based on the objective with the highest improvement potential\n    obj_values = np.array(objectives[selected_idx])\n    worst_obj_idx = np.argmax(obj_values)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Find the best swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the change in the worst objective\n            a, b, c = new_solution[i-1], new_solution[i], new_solution[(i+1)%n]\n            d, e, f = new_solution[j-1], new_solution[j], new_solution[(j+1)%n]\n\n            old_cost = (distance_matrices[worst_obj_idx][a, b] +\n                        distance_matrices[worst_obj_idx][b, c] +\n                        distance_matrices[worst_obj_idx][d, e] +\n                        distance_matrices[worst_obj_idx][e, f])\n\n            new_cost = (distance_matrices[worst_obj_idx][a, e] +\n                        distance_matrices[worst_obj_idx][e, c] +\n                        distance_matrices[worst_obj_idx][d, b] +\n                        distance_matrices[worst_obj_idx][b, f])\n\n            improvement = old_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n    if best_swap is not None:\n        i, j = best_swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.777212273707671,
            3.7233001708984377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate a combined objective score to identify promising solutions\n    combined_scores = [sum(obj) for obj in objectives]\n    max_score = max(combined_scores)\n    promising_indices = [i for i, score in enumerate(combined_scores) if score >= max_score * 0.9]\n\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n\n    selected_idx = random.choice(promising_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 5, n - 1))  # Limit segment length for efficiency\n\n    # Apply a 2-opt move within the selected segment\n    if end - start >= 2:\n        i, j = random.sample(range(start, end), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a node swap based on the objective with the highest improvement potential\n    obj_values = np.array(objectives[selected_idx])\n    worst_obj_idx = np.argmax(obj_values)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Find the best swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the change in the worst objective\n            a, b, c = new_solution[i-1], new_solution[i], new_solution[(i+1)%n]\n            d, e, f = new_solution[j-1], new_solution[j], new_solution[(j+1)%n]\n\n            old_cost = (distance_matrices[worst_obj_idx][a, b] +\n                        distance_matrices[worst_obj_idx][b, c] +\n                        distance_matrices[worst_obj_idx][d, e] +\n                        distance_matrices[worst_obj_idx][e, f])\n\n            new_cost = (distance_matrices[worst_obj_idx][a, e] +\n                        distance_matrices[worst_obj_idx][e, c] +\n                        distance_matrices[worst_obj_idx][d, b] +\n                        distance_matrices[worst_obj_idx][b, f])\n\n            improvement = old_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n    if best_swap is not None:\n        i, j = best_swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 279,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_costs = [sum(cost) for _, cost in archive]\n    selected_idx = np.argmin(archive_costs)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or edge insertion based on current costs\n        current_costs = archive[selected_idx][1]\n        max_cost_idx = np.argmax(current_costs)\n\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # Perform 2-opt on the objective with highest current cost\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Perform edge insertion to improve the worst objective\n            # Select a random node and insert it in a better position\n            node_to_move = random.choice(new_solution)\n            current_pos = np.where(new_solution == node_to_move)[0][0]\n\n            # Find best insertion position for the worst objective\n            best_pos = current_pos\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == current_pos:\n                    continue\n\n                # Try inserting at position pos\n                temp_solution = np.delete(new_solution, current_pos)\n                temp_solution = np.insert(temp_solution, pos, node_to_move)\n\n                # Calculate improvement for the worst objective\n                if max_cost_idx == 0:\n                    old_cost = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                               distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n                    new_cost = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + \\\n                               distance_matrix_1[temp_solution[pos], temp_solution[(pos+1)%n]]\n                    improvement = old_cost - new_cost\n                elif max_cost_idx == 1:\n                    old_cost = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                               distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n                    new_cost = distance_matrix_2[temp_solution[pos-1], temp_solution[pos]] + \\\n                               distance_matrix_2[temp_solution[pos], temp_solution[(pos+1)%n]]\n                    improvement = old_cost - new_cost\n                else:\n                    old_cost = distance_matrix_3[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                               distance_matrix_3[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n                    new_cost = distance_matrix_3[temp_solution[pos-1], temp_solution[pos]] + \\\n                               distance_matrix_3[temp_solution[pos], temp_solution[(pos+1)%n]]\n                    improvement = old_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != current_pos:\n                new_solution = np.delete(new_solution, current_pos)\n                new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.6199042805367112,
            2.5675842642784117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_costs = [sum(cost) for _, cost in archive]\n    selected_idx = np.argmin(archive_costs)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or edge insertion based on current costs\n        current_costs = archive[selected_idx][1]\n        max_cost_idx = np.argmax(current_costs)\n\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # Perform 2-opt on the objective with highest current cost\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Perform edge insertion to improve the worst objective\n            # Select a random node and insert it in a better position\n            node_to_move = random.choice(new_solution)\n            current_pos = np.where(new_solution == node_to_move)[0][0]\n\n            # Find best insertion position for the worst objective\n            best_pos = current_pos\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == current_pos:\n                    continue\n\n                # Try inserting at position pos\n                temp_solution = np.delete(new_solution, current_pos)\n                temp_solution = np.insert(temp_solution, pos, node_to_move)\n\n                # Calculate improvement for the worst objective\n                if max_cost_idx == 0:\n                    old_cost = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                               distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n                    new_cost = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + \\\n                               distance_matrix_1[temp_solution[pos], temp_solution[(pos+1)%n]]\n                    improvement = old_cost - new_cost\n                elif max_cost_idx == 1:\n                    old_cost = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                               distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n                    new_cost = distance_matrix_2[temp_solution[pos-1], temp_solution[pos]] + \\\n                               distance_matrix_2[temp_solution[pos], temp_solution[(pos+1)%n]]\n                    improvement = old_cost - new_cost\n                else:\n                    old_cost = distance_matrix_3[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                               distance_matrix_3[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n                    new_cost = distance_matrix_3[temp_solution[pos-1], temp_solution[pos]] + \\\n                               distance_matrix_3[temp_solution[pos], temp_solution[(pos+1)%n]]\n                    improvement = old_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != current_pos:\n                new_solution = np.delete(new_solution, current_pos)\n                new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 280,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding_distances = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(10):  # Number of attempts\n        # First try 2-opt for the first objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid full reversal which would be equivalent to a swap\n\n        # Calculate change in objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        delta_obj1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]] -\n                      distance_matrix_1[old_edges[0]] - distance_matrix_1[old_edges[1]])\n        delta_obj2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]] -\n                      distance_matrix_2[old_edges[0]] - distance_matrix_2[old_edges[1]])\n        delta_obj3 = (distance_matrix_3[new_edges[0]] + distance_matrix_3[new_edges[1]] -\n                      distance_matrix_3[old_edges[0]] - distance_matrix_3[old_edges[1]])\n\n        # If 2-opt improves at least one objective, accept it\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            continue\n\n        # If no improvement, try objective-aware swap\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k == l:\n            continue\n\n        old_edges_swap = [\n            (new_solution[k-1], new_solution[k]),\n            (new_solution[k], new_solution[(k+1)%n]),\n            (new_solution[l-1], new_solution[l]),\n            (new_solution[l], new_solution[(l+1)%n])\n        ]\n        new_edges_swap = [\n            (new_solution[k-1], new_solution[l]),\n            (new_solution[l], new_solution[(k+1)%n]),\n            (new_solution[l-1], new_solution[k]),\n            (new_solution[k], new_solution[(l+1)%n])\n        ]\n\n        delta_obj1_swap = (distance_matrix_1[new_edges_swap[0]] + distance_matrix_1[new_edges_swap[1]] +\n                          distance_matrix_1[new_edges_swap[2]] + distance_matrix_1[new_edges_swap[3]] -\n                          distance_matrix_1[old_edges_swap[0]] - distance_matrix_1[old_edges_swap[1]] -\n                          distance_matrix_1[old_edges_swap[2]] - distance_matrix_1[old_edges_swap[3]])\n        delta_obj2_swap = (distance_matrix_2[new_edges_swap[0]] + distance_matrix_2[new_edges_swap[1]] +\n                          distance_matrix_2[new_edges_swap[2]] + distance_matrix_2[new_edges_swap[3]] -\n                          distance_matrix_2[old_edges_swap[0]] - distance_matrix_2[old_edges_swap[1]] -\n                          distance_matrix_2[old_edges_swap[2]] - distance_matrix_2[old_edges_swap[3]])\n        delta_obj3_swap = (distance_matrix_3[new_edges_swap[0]] + distance_matrix_3[new_edges_swap[1]] +\n                          distance_matrix_3[new_edges_swap[2]] + distance_matrix_3[new_edges_swap[3]] -\n                          distance_matrix_3[old_edges_swap[0]] - distance_matrix_3[old_edges_swap[1]] -\n                          distance_matrix_3[old_edges_swap[2]] - distance_matrix_3[old_edges_swap[3]])\n\n        # If swap improves at least one objective, accept it\n        if delta_obj1_swap < 0 or delta_obj2_swap < 0 or delta_obj3_swap < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7420218416708322,
            2.875640559196472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding_distances = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(10):  # Number of attempts\n        # First try 2-opt for the first objective\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid full reversal which would be equivalent to a swap\n\n        # Calculate change in objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        delta_obj1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]] -\n                      distance_matrix_1[old_edges[0]] - distance_matrix_1[old_edges[1]])\n        delta_obj2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]] -\n                      distance_matrix_2[old_edges[0]] - distance_matrix_2[old_edges[1]])\n        delta_obj3 = (distance_matrix_3[new_edges[0]] + distance_matrix_3[new_edges[1]] -\n                      distance_matrix_3[old_edges[0]] - distance_matrix_3[old_edges[1]])\n\n        # If 2-opt improves at least one objective, accept it\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            continue\n\n        # If no improvement, try objective-aware swap\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k == l:\n            continue\n\n        old_edges_swap = [\n            (new_solution[k-1], new_solution[k]),\n            (new_solution[k], new_solution[(k+1)%n]),\n            (new_solution[l-1], new_solution[l]),\n            (new_solution[l], new_solution[(l+1)%n])\n        ]\n        new_edges_swap = [\n            (new_solution[k-1], new_solution[l]),\n            (new_solution[l], new_solution[(k+1)%n]),\n            (new_solution[l-1], new_solution[k]),\n            (new_solution[k], new_solution[(l+1)%n])\n        ]\n\n        delta_obj1_swap = (distance_matrix_1[new_edges_swap[0]] + distance_matrix_1[new_edges_swap[1]] +\n                          distance_matrix_1[new_edges_swap[2]] + distance_matrix_1[new_edges_swap[3]] -\n                          distance_matrix_1[old_edges_swap[0]] - distance_matrix_1[old_edges_swap[1]] -\n                          distance_matrix_1[old_edges_swap[2]] - distance_matrix_1[old_edges_swap[3]])\n        delta_obj2_swap = (distance_matrix_2[new_edges_swap[0]] + distance_matrix_2[new_edges_swap[1]] +\n                          distance_matrix_2[new_edges_swap[2]] + distance_matrix_2[new_edges_swap[3]] -\n                          distance_matrix_2[old_edges_swap[0]] - distance_matrix_2[old_edges_swap[1]] -\n                          distance_matrix_2[old_edges_swap[2]] - distance_matrix_2[old_edges_swap[3]])\n        delta_obj3_swap = (distance_matrix_3[new_edges_swap[0]] + distance_matrix_3[new_edges_swap[1]] +\n                          distance_matrix_3[new_edges_swap[2]] + distance_matrix_3[new_edges_swap[3]] -\n                          distance_matrix_3[old_edges_swap[0]] - distance_matrix_3[old_edges_swap[1]] -\n                          distance_matrix_3[old_edges_swap[2]] - distance_matrix_3[old_edges_swap[3]])\n\n        # If swap improves at least one objective, accept it\n        if delta_obj1_swap < 0 or delta_obj2_swap < 0 or delta_obj3_swap < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 281,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by the sum of objectives to identify potentially good solutions\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]  # Top 1/3 or at least 1\n\n    # Randomly select one of the top candidates\n    selected = random.choice(candidate_solutions)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware segment swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware segment swap\n    # Identify segments with high potential for improvement in any objective\n    def calculate_segment_cost(solution, start, end, distance_matrix):\n        cost = 0\n        for k in range(start, end):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[end], solution[(start-1)%n]]\n        return cost\n\n    # Find segments that are expensive in any objective\n    max_cost = -1\n    best_i, best_j = 0, 0\n    for _ in range(min(10, n)):  # Limit evaluations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        cost1 = calculate_segment_cost(new_solution, i, j, distance_matrix_1)\n        cost2 = calculate_segment_cost(new_solution, i, j, distance_matrix_2)\n        cost3 = calculate_segment_cost(new_solution, i, j, distance_matrix_3)\n        total_cost = cost1 + cost2 + cost3\n        if total_cost > max_cost:\n            max_cost = total_cost\n            best_i, best_j = i, j\n\n    # Reverse the identified segment\n    if best_i != best_j:\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7281976029965833,
            2.2103961586952208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by the sum of objectives to identify potentially good solutions\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]  # Top 1/3 or at least 1\n\n    # Randomly select one of the top candidates\n    selected = random.choice(candidate_solutions)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware segment swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware segment swap\n    # Identify segments with high potential for improvement in any objective\n    def calculate_segment_cost(solution, start, end, distance_matrix):\n        cost = 0\n        for k in range(start, end):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[end], solution[(start-1)%n]]\n        return cost\n\n    # Find segments that are expensive in any objective\n    max_cost = -1\n    best_i, best_j = 0, 0\n    for _ in range(min(10, n)):  # Limit evaluations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        cost1 = calculate_segment_cost(new_solution, i, j, distance_matrix_1)\n        cost2 = calculate_segment_cost(new_solution, i, j, distance_matrix_2)\n        cost3 = calculate_segment_cost(new_solution, i, j, distance_matrix_3)\n        total_cost = cost1 + cost2 + cost3\n        if total_cost > max_cost:\n            max_cost = total_cost\n            best_i, best_j = i, j\n\n    # Reverse the identified segment\n    if best_i != best_j:\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 282,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Compute cost change for each objective\n        cost_change_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost_change_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        cost_change_3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if cost_change_1 < 0 or cost_change_2 < 0 or cost_change_3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional diversification: random swap if no improvement found\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.798816517049697,
            2.409106504917145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Compute cost change for each objective\n        cost_change_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost_change_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        cost_change_3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if cost_change_1 < 0 or cost_change_2 < 0 or cost_change_3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional diversification: random swap if no improvement found\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 283,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # Select three random edges to reconnect\n        i, j, k = sorted(random.sample(range(1, n_nodes), 3))\n        # Reconnect the edges in a different order\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:  # 30% chance for objective-aware 2-opt\n        # Select the objective with the highest improvement potential\n        current_obj = archive[selected_idx][1]\n        best_obj_idx = np.argmax(current_obj)\n        if best_obj_idx == 0:\n            distance_matrix = distance_matrix_1\n        elif best_obj_idx == 1:\n            distance_matrix = distance_matrix_2\n        else:\n            distance_matrix = distance_matrix_3\n\n        # Find the best 2-opt move for the selected objective\n        best_improvement = 0\n        best_i, best_j = 0, 0\n\n        for i in range(1, n_nodes):\n            for j in range(i + 1, n_nodes):\n                a, b, c, d = new_solution[i-1], new_solution[i], new_solution[j-1], new_solution[j]\n                current = distance_matrix[a, b] + distance_matrix[c, d]\n                new = distance_matrix[a, c] + distance_matrix[b, d]\n                improvement = current - new\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_improvement > 0:\n            new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6653822770473448,
            2.825374126434326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(normalized_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # Select three random edges to reconnect\n        i, j, k = sorted(random.sample(range(1, n_nodes), 3))\n        # Reconnect the edges in a different order\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:  # 30% chance for objective-aware 2-opt\n        # Select the objective with the highest improvement potential\n        current_obj = archive[selected_idx][1]\n        best_obj_idx = np.argmax(current_obj)\n        if best_obj_idx == 0:\n            distance_matrix = distance_matrix_1\n        elif best_obj_idx == 1:\n            distance_matrix = distance_matrix_2\n        else:\n            distance_matrix = distance_matrix_3\n\n        # Find the best 2-opt move for the selected objective\n        best_improvement = 0\n        best_i, best_j = 0, 0\n\n        for i in range(1, n_nodes):\n            for j in range(i + 1, n_nodes):\n                a, b, c, d = new_solution[i-1], new_solution[i], new_solution[j-1], new_solution[j]\n                current = distance_matrix[a, b] + distance_matrix[c, d]\n                new = distance_matrix[a, c] + distance_matrix[b, d]\n                improvement = current - new\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_improvement > 0:\n            new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 284,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selection_probs = 1 - np.mean(normalized_objectives, axis=1)  # Higher probability for worse solutions (more potential)\n    selection_probs = selection_probs / selection_probs.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective to prioritize for initial improvement\n    obj_values = archive[selected_idx][1]\n    priority_obj = np.argmax(obj_values)  # Focus on the worst objective\n\n    # Hybrid local search operator\n    # 1. 2-opt swap targeting the priority objective\n    improved = False\n    for _ in range(10):  # Limited attempts to find improvement\n        i, j = sorted(random.sample(range(n), 2))\n        # Evaluate before and after swap in the priority objective space\n        if priority_obj == 0:\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        elif priority_obj == 1:\n            current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n        else:\n            current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j-1]]\n\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n            improved = True\n            break\n\n    # 2. 3-opt swap to improve all objectives\n    if not improved or random.random() < 0.3:  # Sometimes do 3-opt even if 2-opt didn't improve\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try all possible 3-opt configurations\n        configurations = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]])\n        ]\n\n        # Evaluate all configurations in all three objective spaces\n        costs = []\n        for config in configurations:\n            cost1 = sum(distance_matrix_1[config[i-1], config[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[config[i-1], config[i]] for i in range(n))\n            cost3 = sum(distance_matrix_3[config[i-1], config[i]] for i in range(n))\n            costs.append((cost1, cost2, cost3))\n\n        # Pareto dominance check\n        current_costs = costs[0]\n        better_configs = []\n        for idx, cost in enumerate(costs[1:]):\n            if all(c <= cc for c, cc in zip(cost, current_costs)):\n                better_configs.append(idx + 1)\n\n        if better_configs:\n            selected_config = random.choice(better_configs)\n            new_solution = configurations[selected_config]\n\n    return new_solution\n\n",
        "score": [
            -0.6917857395400093,
            2.8711174964904784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selection_probs = 1 - np.mean(normalized_objectives, axis=1)  # Higher probability for worse solutions (more potential)\n    selection_probs = selection_probs / selection_probs.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective to prioritize for initial improvement\n    obj_values = archive[selected_idx][1]\n    priority_obj = np.argmax(obj_values)  # Focus on the worst objective\n\n    # Hybrid local search operator\n    # 1. 2-opt swap targeting the priority objective\n    improved = False\n    for _ in range(10):  # Limited attempts to find improvement\n        i, j = sorted(random.sample(range(n), 2))\n        # Evaluate before and after swap in the priority objective space\n        if priority_obj == 0:\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        elif priority_obj == 1:\n            current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n        else:\n            current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j-1]]\n\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n            improved = True\n            break\n\n    # 2. 3-opt swap to improve all objectives\n    if not improved or random.random() < 0.3:  # Sometimes do 3-opt even if 2-opt didn't improve\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try all possible 3-opt configurations\n        configurations = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]])\n        ]\n\n        # Evaluate all configurations in all three objective spaces\n        costs = []\n        for config in configurations:\n            cost1 = sum(distance_matrix_1[config[i-1], config[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[config[i-1], config[i]] for i in range(n))\n            cost3 = sum(distance_matrix_3[config[i-1], config[i]] for i in range(n))\n            costs.append((cost1, cost2, cost3))\n\n        # Pareto dominance check\n        current_costs = costs[0]\n        better_configs = []\n        for idx, cost in enumerate(costs[1:]):\n            if all(c <= cc for c, cc in zip(cost, current_costs)):\n                better_configs.append(idx + 1)\n\n        if better_configs:\n            selected_config = random.choice(better_configs)\n            new_solution = configurations[selected_config]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 285,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [sum(obj) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and swap with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware 2-opt move\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Evaluate the move across all three objectives\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]] +\n                     distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            break\n\n    # Objective-aware swap move\n    if random.random() < 0.5:  # 50% chance to perform swap\n        for _ in range(5):  # Limit iterations\n            a, b = random.sample(range(n), 2)\n            if a == b:\n                continue\n\n            # Evaluate the swap\n            old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] +\n                         distance_matrix_3[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n\n            if new_cost < old_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7658711511968539,
            2.8936028718948363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [sum(obj) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and swap with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware 2-opt move\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Evaluate the move across all three objectives\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]] +\n                     distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            break\n\n    # Objective-aware swap move\n    if random.random() < 0.5:  # 50% chance to perform swap\n        for _ in range(5):  # Limit iterations\n            a, b = random.sample(range(n), 2)\n            if a == b:\n                continue\n\n            # Evaluate the swap\n            old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                         distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] +\n                         distance_matrix_3[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n\n            if new_cost < old_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 286,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value (sum of all three objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap (2-opt like operation)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel multi-objective edge swap: evaluate potential swaps based on all three objectives\n    for _ in range(10):  # Limit the number of attempts to balance exploration and exploitation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Calculate current and potential costs for all three objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        current_cost3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n\n        potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        potential_cost3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n\n        # Accept the swap if it improves at least one objective without worsening others too much\n        if (potential_cost1 <= current_cost1 and potential_cost2 <= current_cost2 and potential_cost3 <= current_cost3) or \\\n           (random.random() < 0.3 and (potential_cost1 < current_cost1 or potential_cost2 < current_cost2 or potential_cost3 < current_cost3)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7031706116447893,
            1.6845581531524658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value (sum of all three objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap (2-opt like operation)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel multi-objective edge swap: evaluate potential swaps based on all three objectives\n    for _ in range(10):  # Limit the number of attempts to balance exploration and exploitation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Calculate current and potential costs for all three objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        current_cost3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n\n        potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        potential_cost3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n\n        # Accept the swap if it improves at least one objective without worsening others too much\n        if (potential_cost1 <= current_cost1 and potential_cost2 <= current_cost2 and potential_cost3 <= current_cost3) or \\\n           (random.random() < 0.3 and (potential_cost1 < current_cost1 or potential_cost2 < current_cost2 or potential_cost3 < current_cost3)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 287,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with path relocation\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Decide between 2-opt or path relocation based on current solution's characteristics\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt: select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Path relocation: move a segment to a different position\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(0, n-1)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains valid (no duplicates and all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If invalid, revert to the base solution with a small modification\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7902847116126338,
            1.6052414774894714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with path relocation\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Decide between 2-opt or path relocation based on current solution's characteristics\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt: select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Path relocation: move a segment to a different position\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(0, n-1)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains valid (no duplicates and all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If invalid, revert to the base solution with a small modification\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 288,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        selected_idx = np.random.choice(min(3, len(archive) // 3), size=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange move (swap two edges)\n    if n > 4:\n        k, l = sorted(random.sample(range(n), 2))\n        if k != i and l != j and abs(k - l) > 1:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution (though unlikely with proper implementation)\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.701517971550888,
            1.6664866089820862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        selected_idx = np.random.choice(min(3, len(archive) // 3), size=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange move (swap two edges)\n    if n > 4:\n        k, l = sorted(random.sample(range(n), 2))\n        if k != i and l != j and abs(k - l) > 1:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution (though unlikely with proper implementation)\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 289,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1.0 / (1 + sum(obj)) for _, obj in archive],\n        k=1\n    )[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and swap with objective-aware selection\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more sophisticated operation\n        operation = random.choice(['2opt', 'swap', 'reverse'])\n\n        if operation == '2opt':\n            # Select two edges to disconnect and reconnect\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Reverse the segment between i and j\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        elif operation == 'swap':\n            # Select two nodes to swap, considering their impact on all objectives\n            i, j = random.sample(range(n), 2)\n            # Calculate potential improvement in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i+1 if i+1 < n else 0]]) - \\\n                    (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i+1 if i+1 < n else 0]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i+1 if i+1 < n else 0]]) - \\\n                    (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i+1 if i+1 < n else 0]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[j], new_solution[i+1 if i+1 < n else 0]]) - \\\n                    (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]] +\n                     distance_matrix_3[new_solution[j], new_solution[i+1 if i+1 < n else 0]])\n\n            # Only perform swap if it improves at least one objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # reverse\n            # Select a segment to reverse, considering its impact on all objectives\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Calculate potential improvement\n                delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i+1]]) - \\\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[j]])\n\n                delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i+1]]) - \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[j]])\n\n                delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[i+1]]) - \\\n                        (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[j]])\n\n                # Only perform reverse if it improves at least one objective\n                if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains valid (all nodes are visited exactly once)\n    assert len(set(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7786888201495439,
            1.8209200024604797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1.0 / (1 + sum(obj)) for _, obj in archive],\n        k=1\n    )[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and swap with objective-aware selection\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more sophisticated operation\n        operation = random.choice(['2opt', 'swap', 'reverse'])\n\n        if operation == '2opt':\n            # Select two edges to disconnect and reconnect\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Reverse the segment between i and j\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        elif operation == 'swap':\n            # Select two nodes to swap, considering their impact on all objectives\n            i, j = random.sample(range(n), 2)\n            # Calculate potential improvement in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i+1 if i+1 < n else 0]]) - \\\n                    (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i+1 if i+1 < n else 0]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i+1 if i+1 < n else 0]]) - \\\n                    (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i+1 if i+1 < n else 0]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[j], new_solution[i+1 if i+1 < n else 0]]) - \\\n                    (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]] +\n                     distance_matrix_3[new_solution[j], new_solution[i+1 if i+1 < n else 0]])\n\n            # Only perform swap if it improves at least one objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # reverse\n            # Select a segment to reverse, considering its impact on all objectives\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Calculate potential improvement\n                delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i+1]]) - \\\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[j]])\n\n                delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i+1]]) - \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[j]])\n\n                delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[i+1]]) - \\\n                        (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[j]])\n\n                # Only perform reverse if it improves at least one objective\n                if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains valid (all nodes are visited exactly once)\n    assert len(set(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 290,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30% of the archive)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    num_candidates = max(1, int(len(archive) * 0.3))\n    candidate_indices = np.argsort([sum(obj) for obj in archive_objectives])[:num_candidates]\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and segment inversion\n    if random.random() < 0.5:\n        # 2-opt: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion: select a segment and reverse it\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(new_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6791700566255392,
            1.8331830024719238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30% of the archive)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    num_candidates = max(1, int(len(archive) * 0.3))\n    candidate_indices = np.argsort([sum(obj) for obj in archive_objectives])[:num_candidates]\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and segment inversion\n    if random.random() < 0.5:\n        # 2-opt: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion: select a segment and reverse it\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(new_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 291,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives (higher sum indicates more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 5% or at least 1 solution\n        top_k = max(1, len(archive_sorted) // 20)\n        selected = random.choice(archive_sorted[:top_k])\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node reinsertion\n    n = len(new_solution)\n    if n > 3:\n        # Choose between 2-opt and node reinsertion based on the solution's characteristics\n        if random.random() < 0.7:  # Higher chance for 2-opt\n            # 2-opt: randomly select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node reinsertion: remove a random node and reinsert it at a better position\n            node_pos = random.randint(1, n-1)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n\n            # Find the best insertion point considering all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n\n            for i in range(1, n):\n                temp_solution = np.insert(new_solution, i, node)\n                cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                cost3 = sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                total_cost = cost1 + cost2 + cost3\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6310309424398431,
            2.0875964760780334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives (higher sum indicates more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 5% or at least 1 solution\n        top_k = max(1, len(archive_sorted) // 20)\n        selected = random.choice(archive_sorted[:top_k])\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node reinsertion\n    n = len(new_solution)\n    if n > 3:\n        # Choose between 2-opt and node reinsertion based on the solution's characteristics\n        if random.random() < 0.7:  # Higher chance for 2-opt\n            # 2-opt: randomly select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node reinsertion: remove a random node and reinsert it at a better position\n            node_pos = random.randint(1, n-1)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n\n            # Find the best insertion point considering all three objectives\n            best_pos = 0\n            best_cost = float('inf')\n\n            for i in range(1, n):\n                temp_solution = np.insert(new_solution, i, node)\n                cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                cost3 = sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                total_cost = cost1 + cost2 + cost3\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 292,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (inverse of objective values, normalized)\n    total_objectives = np.array(objectives)\n    normalized_objectives = (total_objectives - total_objectives.min(axis=0)) / (total_objectives.max(axis=0) - total_objectives.min(axis=0) + 1e-10)\n    potential = 1 - normalized_objectives.mean(axis=1)\n    potential = potential / potential.sum()\n\n    selected_idx = np.random.choice(len(solutions), p=potential)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt, 3-opt, or objective-specific swap\n    operator = random.choice(['2-opt', '3-opt', 'objective-swap'])\n\n    if operator == '2-opt':\n        # Randomly select two edges to reverse\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3-opt':\n        # Randomly select three edges and reorder them\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # objective-swap\n        # Select a node and swap it with its neighbor in the space where it contributes most\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Calculate contribution in each objective space\n        prev_node = new_solution[node_idx-1]\n        next_node = new_solution[(node_idx+1) % n]\n\n        contrib1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        contrib2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        contrib3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n        # Choose the space with highest contribution\n        if max(contrib1, contrib2, contrib3) == contrib1:\n            # Swap with neighbor in space 1\n            neighbor_idx = (node_idx + random.choice([-1, 1])) % n\n            new_solution[node_idx], new_solution[neighbor_idx] = new_solution[neighbor_idx], new_solution[node_idx]\n        elif max(contrib1, contrib2, contrib3) == contrib2:\n            # Swap with neighbor in space 2\n            neighbor_idx = (node_idx + random.choice([-1, 1])) % n\n            new_solution[node_idx], new_solution[neighbor_idx] = new_solution[neighbor_idx], new_solution[node_idx]\n        else:\n            # Swap with neighbor in space 3\n            neighbor_idx = (node_idx + random.choice([-1, 1])) % n\n            new_solution[node_idx], new_solution[neighbor_idx] = new_solution[neighbor_idx], new_solution[node_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.814804668090971,
            2.2133520007133485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (inverse of objective values, normalized)\n    total_objectives = np.array(objectives)\n    normalized_objectives = (total_objectives - total_objectives.min(axis=0)) / (total_objectives.max(axis=0) - total_objectives.min(axis=0) + 1e-10)\n    potential = 1 - normalized_objectives.mean(axis=1)\n    potential = potential / potential.sum()\n\n    selected_idx = np.random.choice(len(solutions), p=potential)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt, 3-opt, or objective-specific swap\n    operator = random.choice(['2-opt', '3-opt', 'objective-swap'])\n\n    if operator == '2-opt':\n        # Randomly select two edges to reverse\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3-opt':\n        # Randomly select three edges and reorder them\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # objective-swap\n        # Select a node and swap it with its neighbor in the space where it contributes most\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Calculate contribution in each objective space\n        prev_node = new_solution[node_idx-1]\n        next_node = new_solution[(node_idx+1) % n]\n\n        contrib1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        contrib2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        contrib3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n        # Choose the space with highest contribution\n        if max(contrib1, contrib2, contrib3) == contrib1:\n            # Swap with neighbor in space 1\n            neighbor_idx = (node_idx + random.choice([-1, 1])) % n\n            new_solution[node_idx], new_solution[neighbor_idx] = new_solution[neighbor_idx], new_solution[node_idx]\n        elif max(contrib1, contrib2, contrib3) == contrib2:\n            # Swap with neighbor in space 2\n            neighbor_idx = (node_idx + random.choice([-1, 1])) % n\n            new_solution[node_idx], new_solution[neighbor_idx] = new_solution[neighbor_idx], new_solution[node_idx]\n        else:\n            # Swap with neighbor in space 3\n            neighbor_idx = (node_idx + random.choice([-1, 1])) % n\n            new_solution[node_idx], new_solution[neighbor_idx] = new_solution[neighbor_idx], new_solution[node_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 293,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Number of attempts to find improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                        distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n                        distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                        distance_matrix_2[base_solution[j], base_solution[(j+1)%n]] +\n                        distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                        distance_matrix_3[base_solution[j], base_solution[(j+1)%n]])\n\n        potential_cost = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                          distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] +\n                          distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                          distance_matrix_2[base_solution[i], base_solution[(j+1)%n]] +\n                          distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                          distance_matrix_3[base_solution[i], base_solution[(j+1)%n]])\n\n        # If potential cost is better in any objective, perform the swap\n        if potential_cost < current_cost:\n            new_solution = base_solution.copy()\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n            base_solution = new_solution.copy()\n\n        # Also consider objective-aware swaps\n        if np.random.rand() < 0.3:  # 30% chance for objective-aware swap\n            # Select a segment to swap based on objective diversity\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n\n            # Calculate segment costs in each objective\n            segment_costs = [\n                sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(start, end+1)),\n                sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(start, end+1)),\n                sum(distance_matrix_3[base_solution[k-1], base_solution[k]] for k in range(start, end+1))\n            ]\n\n            # Find the objective with highest segment cost (most room for improvement)\n            worst_obj = np.argmax(segment_costs)\n\n            # Perform a segment swap that prioritizes improving the worst objective\n            if worst_obj == 0:\n                new_solution[start:end+1] = np.flip(new_solution[start:end+1])\n            elif worst_obj == 1:\n                # More complex operation for second objective\n                new_solution[start:end+1] = np.roll(new_solution[start:end+1], 1)\n            else:\n                # Different operation for third objective\n                new_solution[start:end+1] = np.roll(new_solution[start:end+1], -1)\n\n            # Ensure solution remains valid\n            if np.unique(new_solution).size == n:\n                base_solution = new_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7915452226123214,
            3.0301766395568848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Number of attempts to find improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                        distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n                        distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                        distance_matrix_2[base_solution[j], base_solution[(j+1)%n]] +\n                        distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                        distance_matrix_3[base_solution[j], base_solution[(j+1)%n]])\n\n        potential_cost = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                          distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] +\n                          distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                          distance_matrix_2[base_solution[i], base_solution[(j+1)%n]] +\n                          distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                          distance_matrix_3[base_solution[i], base_solution[(j+1)%n]])\n\n        # If potential cost is better in any objective, perform the swap\n        if potential_cost < current_cost:\n            new_solution = base_solution.copy()\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n            base_solution = new_solution.copy()\n\n        # Also consider objective-aware swaps\n        if np.random.rand() < 0.3:  # 30% chance for objective-aware swap\n            # Select a segment to swap based on objective diversity\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n\n            # Calculate segment costs in each objective\n            segment_costs = [\n                sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(start, end+1)),\n                sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(start, end+1)),\n                sum(distance_matrix_3[base_solution[k-1], base_solution[k]] for k in range(start, end+1))\n            ]\n\n            # Find the objective with highest segment cost (most room for improvement)\n            worst_obj = np.argmax(segment_costs)\n\n            # Perform a segment swap that prioritizes improving the worst objective\n            if worst_obj == 0:\n                new_solution[start:end+1] = np.flip(new_solution[start:end+1])\n            elif worst_obj == 1:\n                # More complex operation for second objective\n                new_solution[start:end+1] = np.roll(new_solution[start:end+1], 1)\n            else:\n                # Different operation for third objective\n                new_solution[start:end+1] = np.roll(new_solution[start:end+1], -1)\n\n            # Ensure solution remains valid\n            if np.unique(new_solution).size == n:\n                base_solution = new_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 294,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, min(5, len(archive)-1)) if len(archive) > 1 else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    operator = random.choice(['2opt', 'edge_insertion', 'swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt on the solution with the worst objective\n        worst_obj = max(archive, key=lambda x: sum(x[1]))[1]\n        if worst_obj[0] > archive[selected_idx][1][0]:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'edge_insertion':\n        # Edge insertion based on the most promising edge in the worst objective\n        worst_obj = max(archive, key=lambda x: sum(x[1]))[1]\n        if worst_obj[0] > archive[selected_idx][1][0]:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n        else:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'swap':\n        # Swap segments based on the objective with the highest improvement potential\n        obj_weights = np.array([obj for _, obj in archive])\n        worst_obj_idx = np.argmax(np.sum(obj_weights, axis=1))\n        worst_obj = archive[worst_obj_idx][1]\n\n        if worst_obj[0] > archive[selected_idx][1][0]:\n            # Focus on improving the first objective\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7984352142590362,
            1.0509910464286805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, min(5, len(archive)-1)) if len(archive) > 1 else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    operator = random.choice(['2opt', 'edge_insertion', 'swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt on the solution with the worst objective\n        worst_obj = max(archive, key=lambda x: sum(x[1]))[1]\n        if worst_obj[0] > archive[selected_idx][1][0]:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'edge_insertion':\n        # Edge insertion based on the most promising edge in the worst objective\n        worst_obj = max(archive, key=lambda x: sum(x[1]))[1]\n        if worst_obj[0] > archive[selected_idx][1][0]:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n        else:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'swap':\n        # Swap segments based on the objective with the highest improvement potential\n        obj_weights = np.array([obj for _, obj in archive])\n        worst_obj_idx = np.argmax(np.sum(obj_weights, axis=1))\n        worst_obj = archive[worst_obj_idx][1]\n\n        if worst_obj[0] > archive[selected_idx][1][0]:\n            # Focus on improving the first objective\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 295,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    def potential(solution, objective):\n        # Simple heuristic: solutions with higher objective values have more potential\n        return sum(objective)\n\n    candidates = [(sol, obj) for sol, obj in archive]\n    if len(candidates) > 1:\n        candidates.sort(key=lambda x: potential(x[0], x[1]), reverse=True)\n        selected_solution = candidates[0][0].copy()\n    else:\n        selected_solution = candidates[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 2-opt move (for TSP structure)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform objective-aware swap (for multi-objective optimization)\n        # Select two nodes that are far apart in at least one objective space\n        candidate_pairs = []\n        for a in range(n):\n            for b in range(a+1, n):\n                node_a = new_solution[a]\n                node_b = new_solution[b]\n                # Check if swapping these nodes would improve at least one objective\n                if (distance_matrix_1[node_a, node_b] + distance_matrix_1[new_solution[(a-1)%n], new_solution[(b+1)%n]] <\n                    distance_matrix_1[new_solution[(a-1)%n], node_a] + distance_matrix_1[node_b, new_solution[(b+1)%n]]):\n                    candidate_pairs.append((a, b))\n                elif (distance_matrix_2[node_a, node_b] + distance_matrix_2[new_solution[(a-1)%n], new_solution[(b+1)%n]] <\n                      distance_matrix_2[new_solution[(a-1)%n], node_a] + distance_matrix_2[node_b, new_solution[(b+1)%n]]):\n                    candidate_pairs.append((a, b))\n                elif (distance_matrix_3[node_a, node_b] + distance_matrix_3[new_solution[(a-1)%n], new_solution[(b+1)%n]] <\n                      distance_matrix_3[new_solution[(a-1)%n], node_a] + distance_matrix_3[node_b, new_solution[(b+1)%n]]):\n                    candidate_pairs.append((a, b))\n\n        if candidate_pairs:\n            a, b = random.choice(candidate_pairs)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5643075386533645,
            2.968290388584137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    def potential(solution, objective):\n        # Simple heuristic: solutions with higher objective values have more potential\n        return sum(objective)\n\n    candidates = [(sol, obj) for sol, obj in archive]\n    if len(candidates) > 1:\n        candidates.sort(key=lambda x: potential(x[0], x[1]), reverse=True)\n        selected_solution = candidates[0][0].copy()\n    else:\n        selected_solution = candidates[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 2-opt move (for TSP structure)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform objective-aware swap (for multi-objective optimization)\n        # Select two nodes that are far apart in at least one objective space\n        candidate_pairs = []\n        for a in range(n):\n            for b in range(a+1, n):\n                node_a = new_solution[a]\n                node_b = new_solution[b]\n                # Check if swapping these nodes would improve at least one objective\n                if (distance_matrix_1[node_a, node_b] + distance_matrix_1[new_solution[(a-1)%n], new_solution[(b+1)%n]] <\n                    distance_matrix_1[new_solution[(a-1)%n], node_a] + distance_matrix_1[node_b, new_solution[(b+1)%n]]):\n                    candidate_pairs.append((a, b))\n                elif (distance_matrix_2[node_a, node_b] + distance_matrix_2[new_solution[(a-1)%n], new_solution[(b+1)%n]] <\n                      distance_matrix_2[new_solution[(a-1)%n], node_a] + distance_matrix_2[node_b, new_solution[(b+1)%n]]):\n                    candidate_pairs.append((a, b))\n                elif (distance_matrix_3[node_a, node_b] + distance_matrix_3[new_solution[(a-1)%n], new_solution[(b+1)%n]] <\n                      distance_matrix_3[new_solution[(a-1)%n], node_a] + distance_matrix_3[node_b, new_solution[(b+1)%n]]):\n                    candidate_pairs.append((a, b))\n\n        if candidate_pairs:\n            a, b = random.choice(candidate_pairs)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 296,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (randomly weighted by objective values)\n    weights = [1.0 / (1.0 + sum(obj)) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n\n    # First, perform a 2-opt move (for general TSP improvement)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform objective-aware swaps based on the worst-performing objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the worst objective\n    max_edge_cost = -1\n    a, b = -1, -1\n    for i in range(n):\n        node_a = base_solution[i]\n        node_b = base_solution[(i + 1) % n]\n        edge_cost = distance_matrix[node_a, node_b]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            a, b = i, (i + 1) % n\n\n    # Try to replace the worst edge with a better one\n    if a != -1 and b != -1:\n        # Find the best possible replacement edge\n        best_replacement_cost = float('inf')\n        best_replacement = None\n\n        for i in range(n):\n            if i == a or i == b or (i + 1) % n == a or (i + 1) % n == b:\n                continue\n\n            node_x = base_solution[i]\n            node_y = base_solution[(i + 1) % n]\n\n            # Calculate the cost of replacing edge (a,b) with (x,y) and (b,a)\n            new_cost = (distance_matrix[node_x, base_solution[b]] +\n                        distance_matrix[base_solution[a], node_y])\n\n            if new_cost < best_replacement_cost:\n                best_replacement_cost = new_cost\n                best_replacement = (i, (i + 1) % n)\n\n        if best_replacement is not None:\n            i, j = best_replacement\n            # Perform the replacement\n            if i < j:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                # Handle wrap-around case\n                temp = np.concatenate((new_solution[i:], new_solution[:j+1]))\n                temp = temp[::-1]\n                new_solution = np.concatenate((temp[-j-1:], new_solution[j+1:i]))\n\n    return new_solution\n\n",
        "score": [
            -0.6881341810089359,
            1.5775883436203002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (randomly weighted by objective values)\n    weights = [1.0 / (1.0 + sum(obj)) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n\n    # First, perform a 2-opt move (for general TSP improvement)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform objective-aware swaps based on the worst-performing objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the worst objective\n    max_edge_cost = -1\n    a, b = -1, -1\n    for i in range(n):\n        node_a = base_solution[i]\n        node_b = base_solution[(i + 1) % n]\n        edge_cost = distance_matrix[node_a, node_b]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            a, b = i, (i + 1) % n\n\n    # Try to replace the worst edge with a better one\n    if a != -1 and b != -1:\n        # Find the best possible replacement edge\n        best_replacement_cost = float('inf')\n        best_replacement = None\n\n        for i in range(n):\n            if i == a or i == b or (i + 1) % n == a or (i + 1) % n == b:\n                continue\n\n            node_x = base_solution[i]\n            node_y = base_solution[(i + 1) % n]\n\n            # Calculate the cost of replacing edge (a,b) with (x,y) and (b,a)\n            new_cost = (distance_matrix[node_x, base_solution[b]] +\n                        distance_matrix[base_solution[a], node_y])\n\n            if new_cost < best_replacement_cost:\n                best_replacement_cost = new_cost\n                best_replacement = (i, (i + 1) % n)\n\n        if best_replacement is not None:\n            i, j = best_replacement\n            # Perform the replacement\n            if i < j:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                # Handle wrap-around case\n                temp = np.concatenate((new_solution[i:], new_solution[:j+1]))\n                temp = temp[::-1]\n                new_solution = np.concatenate((temp[-j-1:], new_solution[j+1:i]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 297,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(base_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct edges to modify\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Apply 2-opt on the first pair\n        if i > j:\n            i, j = j, i\n        if k > l:\n            k, l = l, k\n\n        # Perform edge exchange (similar to 2-opt but more flexible)\n        candidate = new_solution.copy()\n        candidate[i:j+1] = np.flip(candidate[i:j+1])\n        candidate[k:l+1] = np.flip(candidate[k:l+1])\n\n        # Check if the new solution is valid (no duplicates)\n        if len(np.unique(candidate)) == n:\n            new_solution = candidate\n\n    # Ensure the solution is a valid tour (circular)\n    if not np.array_equal(new_solution, base_solution):\n        return new_solution\n    else:\n        # If no improvement, perform a random 2-opt\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        return new_solution\n\n",
        "score": [
            -0.730662545390427,
            3.7084150433540346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(base_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct edges to modify\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Apply 2-opt on the first pair\n        if i > j:\n            i, j = j, i\n        if k > l:\n            k, l = l, k\n\n        # Perform edge exchange (similar to 2-opt but more flexible)\n        candidate = new_solution.copy()\n        candidate[i:j+1] = np.flip(candidate[i:j+1])\n        candidate[k:l+1] = np.flip(candidate[k:l+1])\n\n        # Check if the new solution is valid (no duplicates)\n        if len(np.unique(candidate)) == n:\n            new_solution = candidate\n\n    # Ensure the solution is a valid tour (circular)\n    if not np.array_equal(new_solution, base_solution):\n        return new_solution\n    else:\n        # If no improvement, perform a random 2-opt\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 298,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is not the best (to encourage exploration)\n        base_solution = random.choice(sorted_archive[1:min(3, len(sorted_archive))])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure the swap is non-trivial\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware edge swap: try to improve one objective while minimally affecting others\n        for _ in range(3):  # Try a few different edge swaps\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                # Calculate the change in all three objectives\n                delta_1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b], new_solution[a]] -\n                          distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_1[new_solution[b], new_solution[b+1 if b+1 < n else 0]])\n\n                delta_2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b], new_solution[a]] -\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_2[new_solution[b], new_solution[b+1 if b+1 < n else 0]])\n\n                delta_3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_3[new_solution[b], new_solution[a]] -\n                          distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_3[new_solution[b], new_solution[b+1 if b+1 < n else 0]])\n\n                # If this swap improves at least one objective while not worsening others too much\n                if (delta_1 <= 0 or delta_2 <= 0 or delta_3 <= 0) and not (delta_1 > 0 and delta_2 > 0 and delta_3 > 0):\n                    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7124927931085936,
            2.0750467658042906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is not the best (to encourage exploration)\n        base_solution = random.choice(sorted_archive[1:min(3, len(sorted_archive))])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure the swap is non-trivial\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware edge swap: try to improve one objective while minimally affecting others\n        for _ in range(3):  # Try a few different edge swaps\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                # Calculate the change in all three objectives\n                delta_1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b], new_solution[a]] -\n                          distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_1[new_solution[b], new_solution[b+1 if b+1 < n else 0]])\n\n                delta_2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b], new_solution[a]] -\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_2[new_solution[b], new_solution[b+1 if b+1 < n else 0]])\n\n                delta_3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_3[new_solution[b], new_solution[a]] -\n                          distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_3[new_solution[b], new_solution[b+1 if b+1 < n else 0]])\n\n                # If this swap improves at least one objective while not worsening others too much\n                if (delta_1 <= 0 or delta_2 <= 0 or delta_3 <= 0) and not (delta_1 > 0 and delta_2 > 0 and delta_3 > 0):\n                    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 299,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy: combine 2-opt with a novel multi-objective swap\n    new_solution = base_solution.copy()\n\n    # First, perform a random 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel multi-objective swap: select a node that improves at least one objective\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate the change in objectives\n        delta_cost1 = (distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[node_a, new_solution[(a+1)%n]] -\n                       distance_matrix_1[node_b, new_solution[(a-1)%n]] - distance_matrix_1[node_b, new_solution[(a+1)%n]])\n        delta_cost2 = (distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[node_a, new_solution[(a+1)%n]] -\n                       distance_matrix_2[node_b, new_solution[(a-1)%n]] - distance_matrix_2[node_b, new_solution[(a+1)%n]])\n        delta_cost3 = (distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[node_a, new_solution[(a+1)%n]] -\n                       distance_matrix_3[node_b, new_solution[(a-1)%n]] - distance_matrix_3[node_b, new_solution[(a+1)%n]])\n\n        # If the swap improves at least one objective, perform it\n        if delta_cost1 < 0 or delta_cost2 < 0 or delta_cost3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6912587934171068,
            1.0559077739715577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy: combine 2-opt with a novel multi-objective swap\n    new_solution = base_solution.copy()\n\n    # First, perform a random 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel multi-objective swap: select a node that improves at least one objective\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate the change in objectives\n        delta_cost1 = (distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[node_a, new_solution[(a+1)%n]] -\n                       distance_matrix_1[node_b, new_solution[(a-1)%n]] - distance_matrix_1[node_b, new_solution[(a+1)%n]])\n        delta_cost2 = (distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[node_a, new_solution[(a+1)%n]] -\n                       distance_matrix_2[node_b, new_solution[(a-1)%n]] - distance_matrix_2[node_b, new_solution[(a+1)%n]])\n        delta_cost3 = (distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[node_a, new_solution[(a+1)%n]] -\n                       distance_matrix_3[node_b, new_solution[(a-1)%n]] - distance_matrix_3[node_b, new_solution[(a+1)%n]])\n\n        # If the swap improves at least one objective, perform it\n        if delta_cost1 < 0 or delta_cost2 < 0 or delta_cost3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 300,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy combining 2-opt, swap, and insertion\n    search_strategy = np.random.choice(['2opt', 'swap', 'insertion'])\n\n    if search_strategy == '2opt':\n        # 2-opt local search with objective-aware edge selection\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif search_strategy == 'swap':\n        # Objective-aware swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # insertion\n        # Objective-aware insertion\n        i, j = np.random.choice(n, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to swap if insertion causes duplicates\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6220201629342028,
            2.158964693546295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy combining 2-opt, swap, and insertion\n    search_strategy = np.random.choice(['2opt', 'swap', 'insertion'])\n\n    if search_strategy == '2opt':\n        # 2-opt local search with objective-aware edge selection\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif search_strategy == 'swap':\n        # Objective-aware swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # insertion\n        # Objective-aware insertion\n        i, j = np.random.choice(n, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to swap if insertion causes duplicates\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    }
]